/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __toBinary = /* @__PURE__ */ (() => {
  var table = new Uint8Array(128);
  for (var i = 0; i < 64; i++)
    table[i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i * 4 - 205] = i;
  return (base64) => {
    var n = base64.length, bytes = new Uint8Array((n - (base64[n - 1] == "=") - (base64[n - 2] == "=")) * 3 / 4 | 0);
    for (var i2 = 0, j = 0; i2 < n; ) {
      var c0 = table[base64.charCodeAt(i2++)], c1 = table[base64.charCodeAt(i2++)];
      var c2 = table[base64.charCodeAt(i2++)], c3 = table[base64.charCodeAt(i2++)];
      bytes[j++] = c0 << 2 | c1 >> 4;
      bytes[j++] = c1 << 4 | c2 >> 2;
      bytes[j++] = c2 << 6 | c3;
    }
    return bytes;
  };
})();

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TypingTransformer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");
var import_state2 = require("@codemirror/state");
var import_commands = require("@codemirror/commands");
var import_view3 = require("@codemirror/view");

// wasm-binary:/home/runner/work/typing-transformer-obsidian/typing-transformer-obsidian/liberty-web/charliberty_bg.wasm
var charliberty_bg_default = __toBinary("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BCACQQhqIQIgBUEBayIFDQALCyABKAIMIgINAUEAIQIMBAsgASgCDCICRQ0BDAILIARBD0sNASACIQUgBygCBA0BC0EBIQZBACEEDAILIARBACAEQQBKG0EBdCEEC0EAIQUgBEEASA0BAkAgBEUEQEEBIQZBACEEDAELQQEhBSAEQQEQrwEiBkUNAgsgAiEFCyADQQA2AhAgAyAGNgIMIAMgBDYCCCABKAIIIQIgAyABKQIQNwIkIAMgBTYCICADIAI2AhwgAyAINgIYIAMgBzYCFCADQQhqQYCzwAAgA0EUahAuDQEgACADKQIINwIAIABBCGogA0EQaigCADYCACADQTBqJAAPCyAFIARBzLHAABCUAQALQeyxwABB1gAgA0EvakHcscAAQcSywAAQXQALjQQBAn8gACABaiECAkACQCAAKAIEIgNBAXENACADQQJxRQ0BIAAoAgAiAyABaiEBIAAgA2siAEG40sAAKAIARgRAIAIoAgRBA3FBA0cNAUGw0sAAIAE2AgAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCACIAE2AgAMAgsgACADEDoLAkACQAJAIAIoAgQiA0ECcUUEQCACQbzSwAAoAgBGDQIgAkG40sAAKAIARg0DIAIgA0F4cSICEDogACABIAJqIgFBAXI2AgQgACABaiABNgIAIABBuNLAACgCAEcNAUGw0sAAIAE2AgAPCyACIANBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUGAAk8EQCAAIAEQPA8LAn9BqNLAACgCACICQQEgAUEDdnQiA3FFBEBBqNLAACACIANyNgIAIAFB+AFxQaDQwABqIgEMAQsgAUH4AXEiAkGg0MAAaiEBIAJBqNDAAGooAgALIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIDwtBvNLAACAANgIAQbTSwABBtNLAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQbjSwAAoAgBHDQFBsNLAAEEANgIAQbjSwABBADYCAA8LQbjSwAAgADYCAEGw0sAAQbDSwAAoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIACwvpBAIIfwF+IwBB4ABrIgIkACACQRhqIAAgACgCACgCBBEAACACIAIoAhwiADYCJCACIAIoAhgiAzYCIAJAIAEtAApBgAFxRQRAIAIgAkEgaq1CgICAgOAFhDcDMCABKAIAIAEoAgQgAkIBNwJUQQEhACACQQE2AkwgAkGMrsAANgJIIAIgAkEwajYCUCACQcgAahAuDQEgAkEQaiACKAIgIAIoAiQoAhgRAAAgAigCECIDRQRAQQAhAAwCCyACKAIUIQQgASgCAEGUrsAAQQwgASgCBCgCDBECAA0BIAJBCGogAyAEKAIYEQAAIAJBKGqtQoCAgIDgBYQhCiACKAIIQQBHIQYDQAJAIAIgAyAEKAIYEQAAIAIoAgQgAigCACEIIAIgBDYCLCACIAM2AiggAkEANgJYIAJBATYCTCACQaSuwAA2AkggAkIENwJQIAEoAgAgASgCBCMAQSBrIgMkACADQRhqIAJByABqIgBBEGopAgA3AwAgA0EQaiAAQQhqKQIANwMAIAMgACkCADcDCCADQQhqEC4gA0EgaiQADQAgAkEAOgA8IAIgBTYCNCACIAY2AjAgAiABNgI4IAJBATYCTCACQYyuwAA2AkggAkIBNwJUIAIgCjcDQCACIAJBQGs2AlAjAEEgayIDJAAgA0EYaiAAQRBqKQIANwMAIANBEGogAEEIaikCADcDACADIAApAgA3AwggAkEwakGsrsAAIANBCGoQLiADQSBqJAANACAFQQFqIQVBACEAIQQgCCIDDQEMAwsLQQEhAAwBCyADIAEgACgCDBEBACEACyACQeAAaiQAIAALvwMBBX8jAEFAaiICJAAgAkEoaiABQdAAaigCACIDNgIAIAIgASkCSDcDICABQcgAaiEEAkAgAyABKAJMIgZPDQAgBCgCACADai0AAEEhRw0AIAEgA0EBaiIDNgJQCyABKAIIIQUCQAJAIANBfUsNACAGIANBAmoiBkkNACAEKAIAIANqLwAAQdu2AUcNACABIAY2AlAgAkE4aiAEQQhqKAIANgIAIAIgBCkCADcDMCACQRhqIAEQHCACKAIcIQEgAigCGCIDQQFxBH8gAwUgAkEQaiABEBwgAigCFCEBIAIoAhBBAXFFBEADQCACQQhqIAEQHCACKAIMIQEgAigCCEEBcUUNAAsLQQALQQFxBEAgASACKQMwNwJIIAFB0ABqIAJBOGooAgA2AgAgBSABKAIISw0BIAEgBTYCCAwBCyABKAJQIgNBfUsNACADQQJqIgQgASgCTEsNACABKAJIIANqLwAAQd26AUcNACABIAQ2AlBBACEDDAELIAEgAikDIDcCSCABQdAAaiACQShqKAIANgIAQQEhAyAFIAEoAghLDQAgASAFNgIICyAAIAE2AgQgACADNgIAIAJBQGskAAulAwEDfyMAQdAAayICJAAgAkHIAGogARAUIAIoAkwhASAAAn8CQCACKAJIQQFxRQ0AAkAgASgCUCIDIAEoAkxPDQAgASgCSCADai0AAEEgRw0AIAEgA0EBajYCUEEADAILIAJBQGsgARANIAIoAkQhASACKAJAQQFxRQ0AIAEoAiwhBCABKAJEIgMgASgCPEYEQCABQTxqQaCfwAAQTgsgASgCQCADQQJ0aiAENgIAIAEgA0EBajYCRCACQThqIAEQGCACKAI8IQEgAigCOEEBcUUEQCABKAJEIgNFDQEgASADQQFrNgJEDAELIAFBJGoQOyACQTBqIAEQHiACKAI0IQEgAigCMEEBcUUNACACQShqIAEQFyACKAIsIQEgAigCKEEBcUUNACACQSBqIAEQGSACKAIkIQEgAigCIEEBcUUNACACQRhqIAEQBiACKAIcIQEgAigCGEEBcUUNACACQRBqIAEQDiACKAIUIQEgAigCEEEBcUUNACACQQhqIAEQDyACKAIMIQEgAigCCAwBC0EACzYCACAAIAE2AgQgAkHQAGokAAudAwEJfyMAQSBrIgMkACADQRhqIgkgAUHQAGooAgAiAjYCACADIAEpAkg3AxBBASEHIAEoAgghCAJAAkAgAiABKAJMIgVPDQAgAUHIAGooAgAiBiACai0AAEEkRw0AIAEgAkEBaiIENgJQAkACQAJAIARBfUsNACACQQNqIgIgBUsNACAEIAZqLwAAQdzIAEcNACABIAI2AlAMAQsgA0EIaiABECogAygCDCEBIAMoAghBAXENAQsDQAJAIAEoAlAiAkF9Sw0AIAEoAkwiBSACQQJqSQ0AIAEoAkghBgNAIAIgBmovAABB3MgARw0BIAEgAkECaiIENgJQIARBfUsNASACQQRqIQogBCECIAUgCk8NAAsLIAMgARAqIAMoAgQhASADKAIAQQFxRQ0ACwsgASgCUCICIAEoAkxPDQAgASgCSCACai0AAEEkRw0AIAEgAkEBajYCUEEAIQcMAQsgASADKQMQNwJIIAFB0ABqIAkoAgA2AgAg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DAELIAEoAgQhAyABKAIAIAAoAgwoAgAiACkCACEEIAApAgghBSACIAApAhA3AhggAiAFNwIQIAIgBDcCCCADIAJBCGoQLgsgAkEgaiQAC9QDAQR/IwBBEGsiAyQAAn8gACgCAEGAgICAeEYEQCADIABBBGo2AgwjAEEQayIAJAAgASgCAEHCo8AAQQsgASgCBCgCDBECACECIABBADoADSAAIAI6AAwgACABNgIIIABBCGpBzaPAAEEHIANBDGpB1KHAABA+IQIgAC0ADSIEIAAtAAwiBXIhAQJAIAVBAXEgBEEBR3INACACKAIAIgEtAApBgAFxRQRAIAEoAgBBzbvAAEECIAEoAgQoAgwRAgAhAQwBCyABKAIAQcy7wABBASABKAIEKAIMEQIAIQELIABBEGokACABQQFxDAELIAMgAEEMajYCCCMAQRBrIgIkACABKAIAQaSjwABBDCABKAIEKAIMEQIAIQQgAkEAOgANIAIgBDoADCACIAE2AgggAkEIakGwo8AAQQkgAEGEo8AAED5BuaPAAEEJIANBCGpBlKPAABA+IQEgAi0ADSIEIAItAAwiBXIhAAJAIAVBAXEgBEEBR3INACABKAIAIgAtAApBgAFxRQRAIAAoAgBBzbvAAEECIAAoAgQoAgwRAgAhAAwBCyAAKAIAQcy7wABBASAAKAIEKAIMEQIAIQALIAJBEGokACAAQQFxCyADQRBqJAALZAECfyMAQRBrIgIkACAAKAIAIgAoAgghAyAAKAIEIQAgAkEEaiABEIcBIAMEQANAIAIgADYCDCACQQRqIAJBDGoQRyAAQQFqIQAgA0EBayIDDQALCyACQQRqEIEBIAJBEGokAAtqAQF/An8CfwJAIAMoAgQEQCADKAIIIgRFBEAgAg0CQQAMBAsgAygCACAEIAEgAhCmAQwCCyACDQBBAAwCCyACIAEQrwELIgMgASADGyEBIANFCyEDIAAgAjYCCCAAIAE2AgQgACADNgIAC18BAn8jAEEQayICJAAgACgCCCEDIAAoAgQhACACQQRqIAEQhwEgAwRAA0AgAiAANgIMIAJBBGogAkEMahBHIABBAWohACADQQFrIgMNAAsLIAJBBGoQgQEgAkEQaiQAC04BAn8jAEEgayICJAAgACgCACEAIAJBDGoiAyABEIMBIAIgADYCGCACIABBBGo2AhwgAyACQRhqEEggAyACQRxqEEggAxBcIAJBIGokAAuDBAEGfyMAQRBrIgIkAAJ/IAAoAgBBAUYEQCACIABBDGo2AgwgAEEEaiEEIAJBDGohBSMAQSBrIgAkAAJAIAEoAgAiBkH0n8AAQQQgASgCBCgCDCIHEQIABEBBASEDDAELAkAgAS0ACkGAAXFFBEBBASEDIAZBp7vAAEEBIAcRAgANAiAEIAFBzKHAACgCABEBAEUNAQwCCyAGQai7wABBAiAHEQIABEBBASEDDAILQQEhAyAAQQE6AA8gAEGsu8AANgIUIAAgASkCADcCACAAIAEpAgg3AhggACAAQQ9qNgIIIAAgADYCECAEIABBEGpBzKHAACgCABEBAA0BIAAoAhBBpbvAAEECIAAoAhQoAgwRAgANAQsCQCABLQAKQYABcUUEQCABKAIAQaK7wABBAiABKAIEKAIMEQIADQIgBSABQfCfwAAoAgARAQBFDQEMAgsgAEEBOgAPIABBrLvAADYCFCAAIAEpAgA3AgAgACABKQIINwIYIAAgAEEPajYCCCAAIAA2AhAgBSAAQRBqQfCfwAAoAgARAQANASAAKAIQQaW7wABBAiAAKAIUKAIMEQIADQELIAEoAgBBqrvAAEEBIAEoAgQoAgwRAgAhAwsgAEEgaiQAIAMMAQsgAiAAQQRqNgIIIAFB4J/AAEEDIAJBCGpB5J/AABBGCyACQRBqJAALEgAjAEEwayIAJAAgAEEwaiQAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQazNwAA2AgggA0ICNwIUIANCgICAgDAiBCADrYQ3AyggAyAEIANBBGqthDcDICADIANBIGo2AhAgA0EIaiACEIUBAAtHAQJ/IwBBIGsiAiQAIAJBDGoiAyABEIMBIAIgADYCGCACIABBBGo2AhwgAyACQRhqEEggAyACQRxqEEggAxBcIAJBIGokAAtbAQF/IAAoAgAiACgCDCIBBEAgACgCECABQQJ0EKsBCyAAKAIYIgEEQCAAKAIcIAFBAnQQqwELAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQSQQqwELC2MBAn8jAEEQayICJAAgAEEEaiEDAn8gACgCAEEBRgRAIAIgAzYCDCABQfSfwABBBCACQQxqQeSfwAAQRgwBCyACIAM2AgggAUHgn8AAQQMgAkEIakHQn8AAEEYLIAJBEGokAAtbAQF/IwBBMGsiAyQAIAMgATYCDCADIAA2AgggA0EBNgIUIANB1L3AADYCECADQgE3AhwgAyADQQhqrUKAgICA8AiENwMoIAMgA0EoajYCGCADQRBqIAIQhQEAC0wBAX8jAEEgayICJAAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgA3AwggAEH0rcAAIAJBCGoQLiACQSBqJAALTAEBfyMAQSBrIgIkACACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCAAQcSvwAAgAkEIahAuIAJBIGokAAtMAQF/IwBBIGsiAiQAIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgA3AwAgAiABKQIANwMIIABBgLPAACACQQhqEC4gAkEgaiQAC08BAX8CQAJ/IAAoAgAiAUGAgICAeEcEQCABBEAgACgCBCABEKsBCyAAKAIMIgFFDQJBEAwBCyAAKAIEIgFFDQFBCAsgAGooAgAgARCrAQsLVgECfyABKAIAIQIgAUEANgIAAkAgAgRAIAEoAgQhA0EIQQQQrwEiAUUNASABIAM2AgQgASACNgIAIABBpLDAADYCBCAAIAE2AgAPCwALQQRBCBC2AQALVQEBfyMAQRBrIgIkAAJ/IAAoAgAiACgCAEGAgICAeEcEQCACIAA2AgwgAUHkocAAQQQgAkEMakHUocAAEEYMAQsgAUHQocAAQQQQngELIAJBEGokAAtHAQF/IAAoAgAgACgCCCIDayACSQRAIAAgAyACEEMgACgCCCEDCyACBEAgACgCBCADaiABIAL8CgAACyAAIAIgA2o2AghBAAtDAQN/AkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAEEBaiEAIAFBAWohASACQQFrIgINAQwCCwsgBCAFayEDCyADC1ABAX8jAEEQayICJAACfyAAKAIAQYCAgIB4RwRAIAIgADYCDCABQeShwABBBCACQQxqQdShwAAQRgwBCyABQdChwABBBBCeAQsgAkEQaiQAC0cBAX8gACgCACAAKAIIIgNrIAJJBEAgACADIAIQTCAAKAIIIQMLIAIEQCAAKAIEIANqIAEgAvwKAAALIAAgAiADajYCCEEAC0QBAX8gACgCACIAKAIIIgEEQCAAKAIMIAFBDGwQqwELAkAgAEF/Rg0AIAAgACgCBEEBayIBNgIEIAENACAAQRQQqwELC08BAn8gACgCBCECIAAoAgAhAwJAIAAoAggiAC0AAEUNACADQc7OwABBBCACKAIMEQIARQ0AQQEPCyAAIAFBCkY6AAAgAyABIAIoAhARAQALRwEBfyMAQRBrIgIkACACQQhqIAEQfCACIAIoAgggAigCDCgCGBEAACACKAIEIQEgACACKAIANgIAIAAgATYCBCACQRBqJAALQQECfyAAKAIIIQIgACgCICIBIAAoAhhGBEAgAEEYakGgn8AAEE4LIAAoAhwgAUECdGogAjYCACAAIAFBAWo2AiALRgECfyABKAIEIQIgASgCACEDQQhBBBCvASIBRQRAQQRBCBC2AQALIAEgAjYCBCABIAM2AgAgAEGksMAANgIEIAAgATYCAAvJAgACQCAAIAJNBEAgACABTSABIAJLcg0BIwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkECNgIMIAJByL/AADYCCCACQgI3AhQgAiACQQRqrUKAgICAMIQ3AyggAiACrUKAgICAMIQ3AyAgAiACQSBqNgIQIAJBCGogAxCFAQALIwBBMGsiASQAIAEgAjYCBCABIAA2AgAgAUECNgIMIAFB9L7AADYCCCABQgI3AhQgASABQQRqrUKAgICAMIQ3AyggASABrUKAgICAMIQ3AyAgASABQSBqNgIQIAFBCGogAxCFAQALIwBBMGsiACQAIAAgAjYCBCAAIAE2AgAgAEECNgIMIABBlL/AADYCCCAAQgI3AhQgACAAQQRqrUKAgICAMIQ3AyggACAArUKAgICAMIQ3AyAgACAAQSBqNgIQIABBCGogAxCFAQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhQEACz4BAX8jAEEQayICJAAgAkEIaiABIAEoAgAoAgQRAAAgAigCDCEBIAAgAigCCDYCACAAIAE2AgQgAkEQaiQAC/ABAQN/IAAoAgAhAiABKAIIIgBBgICAEHFFBEAgAEGAgIAgcUUEQCACIAEQPQ8LQQAhACMAQRBrIgMkACACKAIAIQIDQCAAIANqQQ9qIAJBD3EtAJK7QDoAACAAQQFrIQAgAkEPSyACQQR2IQINAAsgAUGQu8AAQQIgACADakEQakEAIABrECUgA0EQaiQADwtBACEAIwBBEGsiAyQAIAIoAgAhAgNAIAAgA2pBD2ogAkEPcS0AgLtAOgAAIABBAWshACACQQ9LIAJBBHYhAg0ACyABQZC7wABBAiAAIANqQRBqQQAgAGsQJSADQRBqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAQBFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAgALLwEBfyMAQRBrIgIkACACQQhqIAAQfCACKAIIIAEgAigCDCgCEBEBACACQRBqJAALOgEBfyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABBqL7AADYCCCAAQgQ3AhAgAEEIakGwvsAAEIUBAAs4AQF/QQEhASAALQAERQRAIAAoAgAiASgCAEHQu8AAQQEgASgCBCgCDBECACEBCyAAIAE6AAQgAQskAAJAIAAgARCZAUUNACAABEAgACABEK8BIgFFDQELIAEPCwALMAAgACABKAIAQQFBACABKAIEKAIMEQIAOgAIIAAgATYCBCAAQQE6AAkgAEEANgIAC1ABAX8jAEEQayIDJAAgAyACNgIMIAMgATYCCCADIAA2AgQjAEEQayIAJAAgACADQQRqIgEpAgA3AgggAEEIakGor8AAIAEoAghBAUEAEE8AC/oBAgJ/AX4jAEEQayICJAAgAkEBOwEMIAIgATYCCCACIAA2AgQjAEEQayIBJAAgAkEEaiIAKQIAIQQgASAANgIMIAEgBDcCBCMAQRBrIgAkACABQQRqIgEoAgAiAigCDCEDAkACQAJAAkAgAigCBA4CAAECCyADDQFBASECQQAhAwwCCyADDQAgAigCACICKAIEIQMgAigCACECDAELIABBgICAgHg2AgAgACABNgIMIABB+K/AACABKAIEIAEoAggiAC0ACCAALQAJEE8ACyAAIAM2AgQgACACNgIAIABB3K/AACABKAIEIAEoAggiAC0ACCAALQAJEE8ACzEBAX8gACABKAI4QQ0gASgCLEGAgICAeEYiAhs2AgQgACABKAI0QeihwAAgAhs2AgALMgEBfyABKAIAQc+7wABBASABKAIEKAIMEQIAIQIgAEEAOgAFIAAgAjoA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o8AAQShBpKTAABB7AAtBoKfAAEEoQcinwAAQewALIAcgCSAEIANBgKfAABCgAQALQfyjwABBKEHEpMAAEHsACwJAAkAgCygCACICQYCAgIB4RwRAIAsoAgghBiALKAIEIQMgAQRAIAAgARCrAQsCQCACIAZNBEAgAyEADAELIAZFBEBBASEAIAMgAhCrAQwBCyADIAJBASAGEKYBIgBFDQILIA8gBjYCBCAPIAA2AgAgC0EQaiQADAILIAsgCygCBDYCDEH0pMAAQSsgC0EMakHkpMAAQaClwAAQXQALQQEgBkHwpcAAEJQBAAsgDygCACAPKAIEIA9BEGokAAshAAJAIAEgAxCZAQRAIAAgASADIAIQpgEiAA0BCwALIAALqgIBCH8jAEEQayICJAAjAEEQayIDJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACADIAQ2AgwgAyAANgIIIAMgAEEEajYCBCAAKAIMIgdBAnQhASAHQf////8DSyABQfz///8HS3INAyAAKAIIIQgCQCABRQRAQQQhBQwBC0EEIQYgAUEEEK8BIgVFDQQLIAEEQCAFIAggAfwKAAALIAAgACgCAEEBazYCACAEIAQoAgBBAWsiADYCACAARQRAIANBDGoQaAsgAiAHNgIEIAIgBTYCACADQRBqJAAMBAsQsQELAAsQsgEACyAGIAFBkKvAABCUAQALIAIoAgAgAigCBCACQRBqJAALqgIBCH8jAEEQayICJAAjAEEQayIDJAACQAJAAkACQCAABEAgAEEIayIEIAQoAgBBAWoiATYCACABRQ0BIAAoAgAiAUF/Rg0CIAAgAUEBajYCACADIAQ2AgwgAyAANgIIIAMgAEEEajYCBCAAKAIYIgdBAnQhASAHQf////8DSyABQfz///8HS3INAyAAKAIUIQgCQCABRQRAQQQhBQwBC0EEIQYgAUEEEK8BIgVFDQQLIAEEQCAFIAggAfwKAAALIAAgACgCAEEBazYCACAEIAQoAgBBAWsiADYCACAARQRAIANBDGoQaAsgAiAHNgIEIAIgBTYCACADQRBqJAAMBAsQsQELAAsQsgEACyAGIAFBkKvAABCUAQALIAIoAgAgAigCBCACQRBqJAALJAEBfyAAKAIAIgFB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ABCrAQsZAAJ/IAFBCU8EQCABIAAQOQwBCyAAEAILCwkAIAAgARAAAAsNAEGwq8AAQRsQsAEACw4AQcurwABBzwAQsAEACwsAIAAoAgAgARA1CwwAIAAgASkCADcDAAsOACABQcSxwABBBRCeAQsZACAAIAFB1NLAACgCACIAQS8gABsRAAAACwoAIAIgACABECgLDQAgAEGsu8AAIAEQLgsJACAAQQA2AgALCAAgACABEDULFAAgACgCACIAIAAoAgAoAgARAwALAgALC8xOFQBBgIDAAAuhEeOAgu+8jO+8m+OAge+8ge+8n++8mmZ0cDovL3BlZWsgd2FzIGNhbGxlZCBvbiBlbXB0eSBzdGFja2xpYnJhcnkvY29yZS9zcmMvc2xpY2Uvc29ydC9zaGFyZWQvc21hbGxzb3J0LnJzAC9ydXN0Yy9lZDYxZTdkN2UyNDI0OTRmYjcwNTdmMjY1NzMwMGQ5ZTc3YmI0ZmNiL2xpYnJhcnkvY29yZS9zcmMvc2xpY2Uvc29ydC9zdGFibGUvcXVpY2tzb3J0LnJzAGxpYnJhcnkvYWxsb2Mvc3JjL2ZtdC5ycwAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9wZXN0LTIuMS4zL3NyYy9pdGVyYXRvcnMvcGFpcnMucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzAC9ydXN0Yy9lZDYxZTdkN2UyNDI0OTRmYjcwNTdmMjY1NzMwMGQ5ZTc3YmI0ZmNiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0ci5ycwAvcnVzdGMvZWQ2MWU3ZDdlMjQyNDk0ZmI3MDU3ZjI2NTczMDBkOWU3N2JiNGZjYi9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3Blc3QtMi4xLjMvc3JjL2Vycm9yLnJzAC9ob21lL3J1bm5lci8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3Blc3QtMi4xLjMvc3JjL2l0ZXJhdG9ycy9wYWlyLnJzAHNyYy9wYXJzZXIucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcGVzdC0yLjEuMy9zcmMvcG9zaXRpb24ucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcGVzdC0yLjEuMy9zcmMvc3Bhbi5ycwAvaG9tZS9ydW5uZXIvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9wZXN0LTIuMS4zL3NyYy9zdGFjay5ycwAvcnVzdGMvZWQ2MWU3ZDdlMjQyNDk0ZmI3MDU3ZjI2NTczMDBkOWU3N2JiNGZjYi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcGVzdC0yLjEuMy9zcmMvcGFyc2VyX3N0YXRlLnJzAGxpYnJhcnkvY29yZS9zcmMvdW5pY29kZS9wcmludGFibGUucnMAL3J1c3RjL2VkNjFlN2Q3ZTI0MjQ5NGZiNzA1N2YyNjU3MzAwZDllNzdiYjRmY2IvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAbGlicmFyeS9jb3JlL3NyYy9mbXQvbW9kLnJzAC9ydXN0Yy9lZDYxZTdkN2UyNDI0OTRmYjcwNTdmMjY1NzMwMGQ5ZTc3YmI0ZmNiL2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMvbW9kLnJzAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjEwL3NyYy9kbG1hbGxvYy5ycwBsaWJyYXJ5L3N0ZC9zcmMvYWxsb2MucnMAL2hvbWUvcnVubmVyLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlv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");

// liberty-web/charliberty.js
var wasm;
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function getBlockRanges(line, cursor_pos) {
  const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
  const len0 = WASM_VECTOR_LEN;
  const ret = wasm.getBlockRanges(ptr0, len0, cursor_pos);
  return Blocks.__wrap(ret);
}
function formatLine(line) {
  let deferred2_0;
  let deferred2_1;
  try {
    const ptr0 = passStringToWasm0(line, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.formatLine(ptr0, len0);
    deferred2_0 = ret[0];
    deferred2_1 = ret[1];
    return getStringFromWasm0(ret[0], ret[1]);
  } finally {
    wasm.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}
var cachedUint32ArrayMemory0 = null;
function getUint32ArrayMemory0() {
  if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
    cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32ArrayMemory0;
}
function getArrayU32FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}
var BlocksFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm.__wbg_blocks_free(ptr >>> 0, 1));
var Blocks = class _Blocks {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(_Blocks.prototype);
    obj.__wbg_ptr = ptr;
    BlocksFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BlocksFinalization.unregister(this);
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_blocks_free(ptr, 0);
  }
  /**
   * @returns {Uint32Array}
   */
  get special() {
    const ret = wasm.blocks_special(this.__wbg_ptr);
    var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
  /**
   * @returns {Uint32Array}
   */
  get emphasis() {
    const ret = wasm.blocks_emphasis(this.__wbg_ptr);
    var v1 = getArrayU32FromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v1;
  }
};
function __wbg_load(module2, imports) {
  return __async(this, null, function* () {
    if (typeof Response === "function" && module2 instanceof Response) {
      if (typeof WebAssembly.instantiateStreaming === "function") {
        try {
          return yield WebAssembly.instantiateStreaming(module2, imports);
        } catch (e) {
          if (module2.headers.get("Content-Type") != "application/wasm") {
            console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
          } else {
            throw e;
          }
        }
      }
      const bytes = yield module2.arrayBuffer();
      return yield WebAssembly.instantiate(bytes, imports);
    } else {
      const instance = yield WebAssembly.instantiate(module2, imports);
      if (instance instanceof WebAssembly.Instance) {
        return { instance, module: module2 };
      } else {
        return instance;
      }
    }
  });
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_init_externref_table = function() {
    const table = wasm.__wbindgen_export_0;
    const offset = table.grow(4);
    table.set(0, void 0);
    table.set(offset + 0, void 0);
    table.set(offset + 1, null);
    table.set(offset + 2, true);
    table.set(offset + 3, false);
    ;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  return imports;
}
function __wbg_init_memory(imports, memory) {
}
function __wbg_finalize_init(instance, module2) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module2;
  cachedUint32ArrayMemory0 = null;
  cachedUint8ArrayMemory0 = null;
  wasm.__wbindgen_start();
  return wasm;
}
function __wbg_init(module_or_path) {
  return __async(this, null, function* () {
    if (wasm !== void 0)
      return wasm;
    if (typeof module_or_path !== "undefined") {
      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
        ({ module_or_path } = module_or_path);
      } else {
        console.warn("using deprecated parameters for the initialization function; pass a single object instead");
      }
    }
    if (typeof module_or_path === "undefined") {
      module_or_path = new URL("charliberty_bg.wasm", "");
    }
    const imports = __wbg_get_imports();
    if (typeof module_or_path === "string" || typeof Request === "function" && module_or_path instanceof Request || typeof URL === "function" && module_or_path instanceof URL) {
      module_or_path = fetch(module_or_path);
    }
    __wbg_init_memory(imports);
    const { instance, module: module2 } = yield __wbg_load(yield module_or_path, imports);
    return __wbg_finalize_init(instance, module2);
  });
}
var charliberty_default = __wbg_init;

// src/const.ts
var FW;
((FW2) => {
  FW2.DOT = "\xB7";
  FW2.MONEY = "\uFFE5";
  FW2.FULLSTOP = "\u3002";
  FW2.LT = "\u300A";
  FW2.GT = "\u300B";
  FW2.SLASH = "\u3001";
  FW2.LEFTQUO = "\u201C";
  FW2.RIGHTQUO = "\u201D";
  FW2.LEFTPAREN = "\uFF08";
  FW2.RIGHTPAREN = "\uFF09";
})(FW || (FW = {}));
var SW;
((SW2) => {
  SW2.DOT = "`";
  SW2.MONEY = "$";
  SW2.FULLSTOP = ".";
  SW2.LT = "<";
  SW2.GT = ">";
  SW2.SLASH = "/";
  SW2.LEFTQUO = '"';
  SW2.RIGHTQUO = '"';
  SW2.LEFTPAREN = "(";
  SW2.RIGHTPAREN = ")";
})(SW || (SW = {}));
var PUNCTS = new Set(" \uFF0C\u3002\uFF1A\uFF1F,.:?");
var DEFAULT_RULES = String.raw`
# Line head conversion
# Note: this rule can't apply to the very first line of the document
'\n|' -> '\n>|'
'\n|' -> '\n/|'

# CN symbols to EN
'|' -> '.|'
'|' -> '>|'
'|' -> '/|'
'|' -> ';|'
'|' -> ',|'

# Auto-pair, Input Conversion, and Deletion
'|' -> '<|' # this one take higer priority than the next line
'|'    -> '|'
'|'   -x '|'
'|' -> '(|)'
'|'     -> '|'
'|'   -x '|'

# Auto code block
'|'  -> '\`|\`' # inline block
'\`|\`' -> '\`\`\`|\n\`\`\`'

# have fun converting!
'dpx|' -> 'don\'t panic|'


# Selection Insert Rules
''  -> '\`' + '\`'
''  -> '$' + '$'
''  -> '' + ''
'<'  -> '<' + '>'
`.replaceAll("\\`", "`");

// src/utils.ts
var config;
function initLog(cfg) {
  config = cfg;
}
function log(format, ...parts) {
  if (config != void 0 && config.debug) {
    parts.forEach((v, idx) => {
      if (typeof v === "string" || v instanceof String) {
        parts[idx] = JSON.stringify(v);
      }
    });
    console.log(format, ...parts);
  }
}

// src/ext_convert.ts
var import_obsidian = require("obsidian");
var EOF = "EOF";
var ANCHOR = "\xA6";
var CLIPBOARD = "$CLIPBOARD";
var DEL_TRIG = "\u274C";
var ParseResult = class {
  constructor(value, error) {
    this.value = value;
    this.error = error;
  }
  get isOk() {
    return this.error == "";
  }
};
function Ok(val) {
  return new ParseResult(val, "");
}
function Err(err) {
  return new ParseResult(null, err);
}
function findOnlyAnchor(s) {
  let res = -1, idx = 0;
  for (const ch of s) {
    if (ch === ANCHOR) {
      if (res == -1) {
        res = idx;
      } else {
        return -2;
      }
    }
    idx++;
  }
  return res;
}
function prefixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = 0; i < s1.length; i++) {
    if (s1[i] != s2[i])
      return false;
  }
  return true;
}
function suffixOf(s1, s2) {
  if (s1.length > s2.length)
    return false;
  for (let i = s1.length - 1, j = s2.length - 1; i > -1; i--, j--) {
    if (s1[i] != s2[j])
      return false;
  }
  return true;
}
var Rule = class {
};
var SideRule = class {
  constructor(trig, left, right) {
    this.trig = trig;
    const leftArray = Array.from(left);
    const rightArray = Array.from(right);
    const leftAnchorPos = findOnlyAnchor(leftArray);
    const rightAnchorPos = findOnlyAnchor(rightArray);
    this.anchorValid = leftAnchorPos == -1 && rightAnchorPos == -1 || leftAnchorPos >= 0 && rightAnchorPos == -1 || leftAnchorPos == -1 && rightAnchorPos >= 0;
    this.left = left.replace(ANCHOR, "");
    this.right = right.replace(ANCHOR, "");
    if (leftAnchorPos >= 0) {
      this.cursorOffset = leftAnchorPos;
      this.cursorInLeft = true;
    } else if (rightAnchorPos >= 0) {
      this.cursorOffset = this.left.length + rightAnchorPos;
      this.cursorInLeft = false;
    } else {
      this.cursorOffset = this.left.length + this.right.length;
      this.cursorInLeft = false;
    }
  }
  get isAnchorValid() {
    return this.anchorValid;
  }
  get isTrigValid() {
    return this.trig.length === 1;
  }
  /**
   * Calculate cursor position after applying SideRule
   * @param basePos base position (usually fromB)
   * @param replacedLength length of the replaced text
   * @returns final cursor position
   * 
   * Examples:
   * - Rule: 'l' -> '[' + '][|]', selected text "hello" (length 5)
   *   cursor in right part, final text: "[hello][", cursor position = basePos + 1 + 5 + 2 = basePos + 8
   * 
   * - Rule: 'q' -> 'left|Text' + 'right', selected text "abc" (length 3)
   *   cursor in left part, final text: "leftTextabcright", cursor position = basePos + 4
   * 
   * - Rule: 'w' -> '|prefix' + 'suffix', selected text "xyz" (length 3)
   *   cursor in left part, final text: "prefixxyzsuffix", cursor position = basePos + 0 = basePos
   * 
   * - Rule: 'r' -> 'left' + 'right', selected text "test" (length 4)
   *   no cursor marker, default to end, final text: "lefttestright", cursor position = basePos + 4 + 4 + 5 = basePos + 13
   */
  calculateCursorPos(basePos, replacedLength) {
    if (this.cursorInLeft) {
      return basePos + this.cursorOffset;
    } else {
      return basePos + this.cursorOffset + replacedLength;
    }
  }
};
var ConvRule = class {
  constructor(left, right, isForDelete = false, isInitClipboard = false) {
    this.isForDelete = isForDelete;
    this.isInitClipboard = isInitClipboard;
    this.left = Array.from(left);
    this.right = Array.from(right);
    this.lanchor = findOnlyAnchor(this.left);
    this.ranchor = findOnlyAnchor(this.right);
    if (this.lanchor > 0 && isForDelete) {
      this.left.splice(this.lanchor, 0, DEL_TRIG);
      this.lanchor += 1;
    }
    this.innerTrig = this.left[this.lanchor - 1];
    this.rBeforeAnchorLen = this.right.slice(0, this.ranchor).reduce((acc, cur) => acc + cur.length, 0);
    this.lBeforeAnchorLen = this.left.slice(0, this.lanchor).reduce((acc, cur) => acc + cur.length, 0);
    this.lBefore2AnchorLen = this.left.slice(0, this.lanchor - 1).reduce((acc, cur) => acc + cur.length, 0);
    if (isForDelete) {
      this.lBefore3AnchorLen = this.left.slice(0, this.lanchor - 2).reduce((acc, cur) => acc + cur.length, 0);
    }
    this.lAfterAnchorLen = this.left.slice(this.lanchor + 1).reduce((acc, cur) => acc + cur.length, 0);
    this.replace = this.right.slice(0, this.ranchor).join("") + this.right.slice(this.ranchor + 1).join("");
  }
  get isValid() {
    return this.lanchor > 0 && this.ranchor >= 0;
  }
  invalidReasons() {
    const reasons = [];
    if (this.lanchor < 0) {
      reasons.push(`Expected one | on left side, but found ${this.lanchor == -1 ? "none" : "multiple"}`);
    } else if (this.lanchor === 0) {
      reasons.push("Invalid Placement of | on the left side. Note: left side cannot start with |");
    }
    if (this.ranchor < 0) {
      reasons.push(`Expected one | on right side, but found ${this.ranchor == -1 ? "none" : "multiple"}`);
    }
    return reasons.join("\n");
  }
  // trigHintChar is used to fill trigSet
  get trigHintChar() {
    if (this.isForDelete) {
      return this.left[this.lanchor - 2];
    } else {
      return this.left[this.lanchor - 1];
    }
  }
  canConvert(inputS, insChr, insPosBaseHead) {
    if (!this.isValid || insChr != this.innerTrig)
      return false;
    const { left, lanchor } = this;
    if (!suffixOf(left.slice(0, lanchor - 1), Array.from(inputS.slice(0, insPosBaseHead))))
      return false;
    return prefixOf(left.slice(lanchor + 1), Array.from(inputS.slice(insPosBaseHead)));
  }
  leftMatchPart() {
    return this.left.slice(0, this.lanchor);
  }
  // pos is the position of trigger char in the whole documnet
  mapToChanges(pos, isDel) {
    const { lBefore3AnchorLen, lBefore2AnchorLen, lBeforeAnchorLen, lAfterAnchorLen, rBeforeAnchorLen } = this;
    let modificationSpan;
    let startOffset;
    if (isDel) {
      pos = pos - 1;
      startOffset = lBefore3AnchorLen;
      modificationSpan = lBefore3AnchorLen + lAfterAnchorLen;
    } else {
      startOffset = lBefore2AnchorLen;
      modificationSpan = lBeforeAnchorLen + lAfterAnchorLen;
    }
    const from = pos - startOffset;
    if (from < 0) {
      console.log("bad pos for map", pos, lBefore2AnchorLen, this.left, this.right);
    }
    const to = from + modificationSpan;
    const newPos = from + rBeforeAnchorLen;
    return {
      changes: { from, to, insert: this.replace },
      selection: { anchor: newPos, head: newPos }
    };
  }
};
var readable = JSON.stringify;
var RuleParser = class {
  constructor(input, fileAdapter, justCheck = false) {
    this.idx = 0;
    this.input = Array.from(input);
    this.convRules = [];
    this.sideRules = /* @__PURE__ */ new Map();
    this.errors = [];
    this.justCheck = justCheck;
    this.fileAdapter = fileAdapter;
  }
  peek() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[idx];
  }
  eat() {
    const { idx, input } = this;
    if (idx == input.length) {
      return EOF;
    }
    return input[this.idx++];
  }
  rewind() {
    this.idx--;
  }
  ignoreSpace() {
    while (this.peek() === " ") {
      this.eat();
    }
  }
  parseString() {
    this.ignoreSpace();
    if (this.peek() != "'") {
      return Err("Expected a rule starting with ', but found " + readable(this.peek()));
    }
    this.eat();
    const result = [];
    let ch;
    while (true) {
      ch = this.eat();
      switch (ch) {
        case "\\":
          switch (this.peek()) {
            case "'":
            case "\\":
            case "|":
              result.push(this.eat());
              break;
            case "n":
              this.eat();
              result.push("\n");
              break;
            default:
              result.push(ch);
              break;
          }
          break;
        case "'":
          return Ok(result.join(""));
        case "\n":
          return Err("Expected a rule ending with ', but found newline. Note: escape intentional newline with '\\n'");
        case EOF:
          return Err("Expected a rule ending with ', but found nothing");
        case "|":
          result.push(ANCHOR);
          break;
        default:
          result.push(ch);
          break;
      }
    }
  }
  parseMapArrow() {
    this.ignoreSpace();
    const first = this.eat(), second = this.eat();
    if (first === "-" && second === ">") {
      return Ok(0 /* Insert */);
    } else if (first === "-" && second === "x") {
      return Ok(1 /* Delete */);
    } else if (first === "-" && second === "f") {
      return Ok(2 /* Import */);
    }
    return Err(`Expected ->, -x or -f, but found ${readable(first)}${readable(second)}`);
  }
  parseComment() {
    this.ignoreSpace();
    let ch = this.peek();
    if (ch === "#") {
      while (ch != "\n" && ch != EOF) {
        ch = this.eat();
      }
      if (ch === "\n") {
        this.rewind();
      }
    }
    if (ch != "\n" && ch != EOF) {
      return Err("Expected only one rule in each line, but found " + readable(ch));
    }
    return Ok("#no content#");
  }
  // a side insert rule is like 'x' -> 'xx' + 'yy'
  // isSideRule check if a '+' exists
  isSideRule() {
    this.ignoreSpace();
    const ch = this.peek();
    if (ch != "+") {
      return false;
    } else {
      this.eat();
      return true;
    }
  }
  parseOne() {
    return __async(this, null, function* () {
      const r1 = this.parseString();
      if (!r1.isOk) {
        return Err(r1.error);
      }
      const r2 = this.parseMapArrow();
      if (!r2.isOk) {
        return Err(r2.error);
      }
      const r3 = this.parseString();
      if (!r3.isOk) {
        return Err(r3.error);
      }
      const rule = new Rule();
      if (this.isSideRule()) {
        if (r2.value === 1 /* Delete */) {
          return Err("Expected ->, but found -x. Note: selection rules cannot be deletion rules");
        }
        const rightInsert = this.parseString();
        if (!rightInsert.isOk) {
          return Err(rightInsert.error);
        }
        const sideRule = new SideRule(r1.value, r3.value, rightInsert.value);
        if (!sideRule.isTrigValid) {
          return Err("Expected one char, but found multiple. Note: the selection rule trigger char can only be a single character");
        }
        if (!sideRule.isAnchorValid) {
          return Err("Expected at most one | on left or right side");
        }
        rule.type = 1 /* SideRule */;
        rule.side = sideRule;
      } else {
        const leftPart = r1.value;
        let rightPart = r3.value;
        let arrowType = r2.value;
        let initClipboard = false;
        if (r2.value === 2 /* Import */) {
          if (r3.value === "") {
            return Err(`Expect a text source, file or clipboard`);
          }
          if (r3.value.includes(CLIPBOARD)) {
            initClipboard = true;
            if (!rightPart.includes(ANCHOR)) {
              rightPart += ANCHOR;
            }
          } else {
            const path = (0, import_obsidian.normalizePath)(r3.value);
            const stat = yield this.fileAdapter.stat(path);
            if (!stat || stat.type === "folder") {
              return Err(`File not found: "${r3.value}"`);
            }
            if (this.justCheck) {
              rightPart = ANCHOR;
            } else {
              const content2 = yield this.fileAdapter.read(path);
              rightPart = content2 + ANCHOR;
            }
          }
          arrowType = 0 /* Insert */;
        }
        const convRule = new ConvRule(
          leftPart,
          rightPart,
          arrowType === 1 /* Delete */,
          initClipboard
        );
        if (!convRule.isValid) {
          return Err(convRule.invalidReasons());
        }
        rule.type = 0 /* ConvRule */;
        rule.conv = convRule;
      }
      const r4 = this.parseComment();
      if (!r4.isOk) {
        return Err(r4.error);
      }
      return Ok(rule);
    });
  }
  parse() {
    return __async(this, null, function* () {
      let line = 1;
      while (true) {
        const r = this.parseComment();
        if (!r.isOk) {
          const rRes = yield this.parseOne();
          if (!rRes.isOk) {
            for (const msg of rRes.error.split("\n")) {
              this.errors.push(`line ${line}: ` + msg);
            }
          } else if (rRes.value.type === 0 /* ConvRule */) {
            this.convRules.push(rRes.value.conv);
          } else {
            const s = rRes.value.side;
            this.sideRules.set(s.trig, s);
          }
        }
        const ch = this.eat();
        if (ch === "\n") {
          line++;
        } else {
          break;
        }
      }
    });
  }
};
var Rules = class {
  constructor() {
    this.rules = [];
    this.insertTrigSet = /* @__PURE__ */ new Set();
    this.deleteTrigSet = /* @__PURE__ */ new Set();
    this.lmax = this.rmax = 0;
  }
  parse(ruletxt, fileAdapter, justCheck = false) {
    return __async(this, null, function* () {
      const parser2 = new RuleParser(ruletxt, fileAdapter, justCheck);
      yield parser2.parse();
      this.errors = parser2.errors;
      if (this.errors.length > 0)
        return;
      if (justCheck)
        return;
      this.rules = parser2.convRules;
      this.index = newConvRulesIndex(this.rules);
      this.sideInsertMap = parser2.sideRules;
      for (const r of this.rules) {
        if (r.isForDelete) {
          this.deleteTrigSet.add(r.trigHintChar);
        } else {
          this.insertTrigSet.add(r.trigHintChar);
        }
        if (r.lBefore2AnchorLen > this.lmax)
          this.lmax = r.lBefore2AnchorLen;
        if (r.lAfterAnchorLen > this.rmax)
          this.rmax = r.lAfterAnchorLen;
      }
    });
  }
  // match a convert rule
  match(input, insChar, insPosBaseLineHead) {
    return __async(this, null, function* () {
      const leftMatch = Array.from(input.slice(0, insPosBaseLineHead));
      leftMatch.push(insChar);
      const candidates = this.index.collectIdxsAlong(leftMatch);
      for (const idx of candidates.sort((a, b) => a - b)) {
        const rule = this.rules[idx];
        if (rule.canConvert(input, insChar, insPosBaseLineHead)) {
          if (rule.isInitClipboard) {
            return yield newCompleteClipboardRule(rule);
          }
          return rule;
        }
      }
      return null;
    });
  }
};
function newCompleteClipboardRule(rule) {
  return __async(this, null, function* () {
    const clipboard = yield navigator.clipboard.readText();
    const left = rule.left.join("");
    let right = rule.right.join("");
    right = right.replace(CLIPBOARD, clipboard);
    return new ConvRule(left, right, rule.isForDelete);
  });
}
function newConvRulesIndex(rules) {
  const root = new TrieNode();
  for (let i = 0; i < rules.length; i++) {
    root.insert(rules[i], i);
  }
  return root;
}
var TrieNode = class _TrieNode {
  constructor() {
    this.next = /* @__PURE__ */ new Map();
    this.value = [];
  }
  isKeyStop() {
    return this.value.length > 0;
  }
  insert(rule, idx) {
    const key = rule.leftMatchPart();
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      const ch = key[i];
      if (node.next.has(ch)) {
        node = node.next.get(ch);
      } else {
        const newNode = new _TrieNode();
        node.next.set(ch, newNode);
        node = newNode;
      }
    }
    node.value.push(idx);
  }
  collectIdxsAlong(key) {
    const idxs = [];
    let node = this;
    for (let i = key.length - 1; i > -1; i--) {
      if (node.isKeyStop()) {
        idxs.push(...node.value);
      }
      node = node.next.get(key[i]);
      if (node === void 0) {
        break;
      }
    }
    if (node != void 0 && node.isKeyStop()) {
      idxs.push(...node.value);
    }
    return idxs;
  }
};

// src/ext_libertyzone.ts
var import_view = require("@codemirror/view");
function libertyZone(zonespotter) {
  return import_view.ViewPlugin.fromClass(class {
    constructor(_) {
      this.decorations = import_view.Decoration.none;
      this.cleanTimer = -1;
    }
    get isTimerActive() {
      return this.cleanTimer >= 0;
    }
    tryRemoveTimer() {
      if (this.isTimerActive) {
        window.clearTimeout(this.cleanTimer);
        this.cleanTimer = -1;
      }
    }
    update(update) {
      const range = zonespotter(update);
      if (range === void 0 || update.state.doc.lineAt(range.from).from == range.from) {
        this.tryRemoveTimer();
        this.cleanTimer = window.setTimeout(
          () => {
            if (this.decorations.size) {
              this.decorations = import_view.Decoration.none;
            }
          },
          1e3
          /* 1 second */
        );
        return;
      }
      this.decorations = import_view.Decoration.set(import_view.Decoration.widget({
        widget: new MarkWidget(15),
        side: 1
      }).range(range.from));
      this.tryRemoveTimer();
    }
  }, {
    decorations: (v) => v.decorations
  });
}
var MarkWidget = class extends import_view.WidgetType {
  constructor(lineHeight) {
    super();
    this.lineHeight = lineHeight;
  }
  toDOM() {
    const mark = document.createElement("span");
    mark.style.position = "relative";
    mark.style.top = `-${this.lineHeight}px`;
    mark.innerText = "\u2B50\uFE0F";
    const wrapper = document.createElement("div");
    wrapper.style.display = "inline-block";
    wrapper.style.position = "absolute";
    wrapper.append(mark);
    return wrapper;
  }
  ignoreEvent() {
    return false;
  }
};

// src/settings.ts
var import_obsidian2 = require("obsidian");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");
var import_language2 = require("@codemirror/language");

// node_modules/@lezer/common/dist/index.js
var DefaultBufferLength = 1024;
var nextPropID = 0;
var Range = class {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
};
var NodeProp = class {
  /**
  Create a new node prop type.
  */
  constructor(config3 = {}) {
    this.id = nextPropID++;
    this.perNode = !!config3.perNode;
    this.deserialize = config3.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
    this.combine = config3.combine || null;
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(match) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function")
      match = NodeType.match(match);
    return (type) => {
      let result = match(type);
      return result === void 0 ? null : [this, result];
    };
  }
};
NodeProp.closedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.openedBy = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.group = new NodeProp({ deserialize: (str) => str.split(" ") });
NodeProp.isolate = new NodeProp({ deserialize: (value) => {
  if (value && value != "rtl" && value != "ltr" && value != "auto")
    throw new RangeError("Invalid value for isolate: " + value);
  return value || "auto";
} });
NodeProp.contextHash = new NodeProp({ perNode: true });
NodeProp.lookAhead = new NodeProp({ perNode: true });
NodeProp.mounted = new NodeProp({ perNode: true });
var MountedTree = class {
  constructor(tree, overlay, parser2) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser2;
  }
  /**
  @internal
  */
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
};
var noProps = /* @__PURE__ */ Object.create(null);
var NodeType = class _NodeType {
  /**
  @internal
  */
  constructor(name2, props, id2, flags = 0) {
    this.name = name2;
    this.props = props;
    this.id = id2;
    this.flags = flags;
  }
  /**
  Define a node type.
  */
  static define(spec) {
    let props = spec.props && spec.props.length ? /* @__PURE__ */ Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new _NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props)
      for (let src of spec.props) {
        if (!Array.isArray(src))
          src = src(type);
        if (src) {
          if (src[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    return type;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(prop) {
    return this.props[prop.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(name2) {
    if (typeof name2 == "string") {
      if (this.name == name2)
        return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name2) > -1 : false;
    }
    return this.id == name2;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(map) {
    let direct = /* @__PURE__ */ Object.create(null);
    for (let prop in map)
      for (let name2 of prop.split(" "))
        direct[name2] = map[prop];
    return (node) => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found)
          return found;
      }
    };
  }
};
NodeType.none = new NodeType(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
var NodeSet = class _NodeSet {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++)
      if (types[i].id != i)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...props) {
    let newTypes = [];
    for (let type of this.types) {
      let newProps = null;
      for (let source of props) {
        let add = source(type);
        if (add) {
          if (!newProps)
            newProps = Object.assign({}, type.props);
          let value = add[1], prop = add[0];
          if (prop.combine && prop.id in newProps)
            value = prop.combine(newProps[prop.id], value);
          newProps[prop.id] = value;
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new _NodeSet(newTypes);
  }
};
var CachedNode = /* @__PURE__ */ new WeakMap();
var CachedInnerNode = /* @__PURE__ */ new WeakMap();
var IterMode;
(function(IterMode2) {
  IterMode2[IterMode2["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode2[IterMode2["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode2[IterMode2["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode2[IterMode2["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
var Tree = class _Tree {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [prop, value] of props)
        this.props[typeof prop == "number" ? prop : prop.id] = value;
    }
  }
  /**
  @internal
  */
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay)
      return mounted.tree.toString();
    let children = "";
    for (let ch of this.children) {
      let str = ch.toString();
      if (str) {
        if (children)
          children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(mode = 0) {
    return new TreeCursor(this.topNode, mode);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(pos, side = 0, mode = 0) {
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(pos, side = 0) {
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(pos, side = 0) {
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(pos, side = 0) {
    return stackIterator(this, pos, side);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(spec) {
    let { enter, leave, from = 0, to = this.length } = spec;
    let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous); ; ) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild())
          continue;
        entered = true;
      }
      for (; ; ) {
        if (entered && leave && (anon || !c.type.isAnonymous))
          leave(c);
        if (c.nextSibling())
          break;
        if (!c.parent())
          return;
        entered = true;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : void 0;
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let result = [];
    if (this.props)
      for (let id2 in this.props)
        result.push([+id2, this.props[id2]]);
    return result;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(config3 = {}) {
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new _Tree(this.type, children, positions, length, this.propValues), config3.makeTree || ((children, positions, length) => new _Tree(NodeType.none, children, positions, length)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(data) {
    return buildTree(data);
  }
};
Tree.empty = new Tree(NodeType.none, [], [], 0);
var FlatBufferCursor = class _FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new _FlatBufferCursor(this.buffer, this.index);
  }
};
var TreeBuffer = class _TreeBuffer {
  /**
  Create a tree buffer.
  */
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  /**
  @internal
  */
  get type() {
    return NodeType.none;
  }
  /**
  @internal
  */
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length; ) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  /**
  @internal
  */
  childString(index) {
    let id2 = this.buffer[index], endIndex = this.buffer[index + 3];
    let type = this.set.types[id2], result = type.name;
    if (/\W/.test(result) && !type.isError)
      result = JSON.stringify(result);
    index += 4;
    if (endIndex == index)
      return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(startIndex, endIndex, dir, pos, side) {
    let { buffer } = this, pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0)
          break;
      }
    }
    return pick;
  }
  /**
  @internal
  */
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI), len = 0;
    for (let i = startI, j = 0; i < endI; ) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new _TreeBuffer(copy, len, this.set);
  }
};
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent)
      return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays)
    for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
      if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
        node = parent;
    }
  for (; ; ) {
    let inner = node.enter(pos, side, mode);
    if (!inner)
      return node;
    node = inner;
  }
}
var BaseNode = class {
  cursor(mode = 0) {
    return new TreeCursor(this, mode);
  }
  getChild(type, before = null, after = null) {
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before = null, after = null) {
    return getChildren(this, type, before, after);
  }
  resolve(pos, side = 0) {
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side = 0) {
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos), node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to)
        break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
};
var TreeNode = class _TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode = 0) {
    for (let parent = this; ; ) {
      for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i], start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length))
          continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers)
            continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1)
            return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || (!next.type.isAnonymous || hasChild(next))) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
            return new _TreeNode(mounted.tree, start, i, parent);
          let inner = new _TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous)
        return null;
      if (parent.index >= 0)
        i = parent.index + dir;
      else
        i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent)
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.nextChild(
      0,
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this._tree.prop(prop);
  }
  enter(pos, side, mode = 0) {
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (let { from, to } of mounted.overlay) {
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos))
          return new _TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent)
      val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
};
function getChildren(node, type, before, after) {
  let cur = node.cursor(), result = [];
  if (!cur.firstChild())
    return result;
  if (before != null)
    for (let found = false; !found; ) {
      found = cur.type.is(before);
      if (!cur.nextSibling())
        return result;
    }
  for (; ; ) {
    if (after != null && cur.type.is(after))
      return result;
    if (cur.type.is(type))
      result.push(cur.node);
    if (!cur.nextSibling())
      return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i = context.length - 1) {
  for (let p = node; i >= 0; p = p.parent) {
    if (!p)
      return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name)
        return false;
      i--;
    }
  }
  return true;
}
var BufferContext = class {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
};
var BufferNode = class _BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(pos) {
    return this.child(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  childBefore(pos) {
    return this.child(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  prop(prop) {
    return this.type.prop(prop);
  }
  enter(pos, side, mode = 0) {
    if (mode & IterMode.ExcludeBuffers)
      return null;
    let { buffer } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new _BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + dir,
      dir,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
      return new _BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart)
      return this.externalSibling(-1);
    return new _BufferNode(this.context, this._parent, buffer.findChild(
      parentStart,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [], positions = [];
    let { buffer } = this.context;
    let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
};
function iterStack(heads) {
  if (!heads.length)
    return null;
  let pick = 0, picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next)
    newHeads[pick] = next;
  else
    newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
var StackIterator = class {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
};
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side), layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
var TreeCursor = class {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(node, mode = 0) {
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent)
        this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node)
      return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let { start, buffer } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  /**
  @internal
  */
  yield(node) {
    if (!node)
      return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(dir, pos, side) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let { buffer } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0)
      return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(pos) {
    return this.enterChild(
      1,
      pos,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(pos) {
    return this.enterChild(
      -1,
      pos,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(pos, side, mode = this.mode) {
    if (!this.buffer)
      return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  /**
  @internal
  */
  sibling(dir) {
    if (!this.buffer)
      return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let { buffer } = this.buffer, d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart)
        return this.yieldBuf(buffer.findChild(
          parentStart,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
        return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index, parent, { buffer } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length)
          return false;
      } else {
        for (let i = 0; i < this.index; i++)
          if (buffer.buffer.buffer[i + 3] < this.index)
            return false;
      }
      ({ index, parent } = buffer);
    } else {
      ({ index, _parent: parent } = this._tree);
    }
    for (; parent; { index, _parent: parent } = parent) {
      if (index > -1)
        for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
          let child = parent._tree.children[i];
          if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))
            return false;
        }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(
      dir,
      0,
      4
      /* Side.DontCare */
    ))
      return true;
    for (; ; ) {
      if (this.sibling(dir))
        return true;
      if (this.atLastNode(dir) || !this.parent())
        return false;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(enter = true) {
    return this.move(1, enter);
  }
  /**
  Move to the next node in a last-to-first pre-order traversal. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(enter = true) {
    return this.move(-1, enter);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(pos, side = 0) {
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos))
      if (!this.parent())
        break;
    while (this.enterChild(1, pos, side)) {
    }
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let cache2 = this.bufferNode, result = null, depth = 0;
    if (cache2 && cache2.context == this.buffer) {
      scan:
        for (let index = this.index, d = this.stack.length; d >= 0; ) {
          for (let c = cache2; c; c = c._parent)
            if (c.index == index) {
              if (index == this.index)
                return c;
              result = c;
              depth = d + 1;
              break scan;
            }
          index = this.stack[--d];
        }
    }
    for (let i = depth; i < this.stack.length; i++)
      result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(enter, leave) {
    for (let depth = 0; ; ) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous)
          mustLeave = true;
      }
      for (; ; ) {
        if (mustLeave && leave)
          leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth)
          return;
        if (this.nextSibling())
          break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(context) {
    if (!this.buffer)
      return matchNodeContext(this.node.parent, context);
    let { buffer } = this.buffer, { types } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0)
        return matchNodeContext(this._tree, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name)
          return false;
        i--;
      }
    }
    return true;
  }
};
function hasChild(tree) {
  return tree.children.some((ch) => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0, lookAhead = 0;
  function takeNode(parentStart, minPos, children2, positions2, inRepeat, depth) {
    let { id: id2, start, end, size } = cursor;
    let lookAheadAtStart = lookAhead, contextAtStart = contextHash;
    if (size < 0) {
      cursor.next();
      if (size == -1) {
        let node2 = reused[id2];
        children2.push(node2);
        positions2.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id2;
        return;
      } else if (size == -4) {
        lookAhead = id2;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id2], node, buffer2;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer2 = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data2 = new Uint16Array(buffer2.size - buffer2.skip);
      let endPos = cursor.pos - buffer2.size, index = data2.length;
      while (cursor.pos > endPos)
        index = copyToBuffer(buffer2.start, data2, index);
      node = new TreeBuffer(data2, end - buffer2.start, nodeSet);
      startPos = buffer2.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [], localPositions = [];
      let localInRepeat = id2 >= minRepeatType ? id2 : -1;
      let lastGroup = 0, lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children2.push(node);
    positions2.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children2, positions2) {
    let nodes = [];
    let nodeCount = 0, stopAt = -1;
    while (cursor.pos > minPos) {
      let { id: id2, start, end, size } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0)
          stopAt = end - maxBufferLength;
        nodes.push(id2, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer2 = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer2[j++] = nodes[i];
        buffer2[j++] = nodes[i + 1] - start;
        buffer2[j++] = nodes[i + 2] - start;
        buffer2[j++] = j;
      }
      children2.push(new TreeBuffer(buffer2, nodes[2] - start, nodeSet));
      positions2.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash2) {
    return (children2, positions2, length2) => {
      let lookAhead2 = 0, lastI = children2.length - 1, last, lookAheadProp;
      if (lastI >= 0 && (last = children2[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length2)
          return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead))
          lookAhead2 = positions2[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children2, positions2, length2, lookAhead2, contextHash2);
    };
  }
  function makeRepeatLeaf(children2, positions2, base, i, from, to, type, lookAhead2, contextHash2) {
    let localChildren = [], localPositions = [];
    while (children2.length > i) {
      localChildren.push(children2.pop());
      localPositions.push(positions2.pop() + base - from);
    }
    children2.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead2 - to, contextHash2));
    positions2.push(from - base);
  }
  function makeTree(type, children2, positions2, length2, lookAhead2, contextHash2, props) {
    if (contextHash2) {
      let pair2 = [NodeProp.contextHash, contextHash2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    if (lookAhead2 > 25) {
      let pair2 = [NodeProp.lookAhead, lookAhead2];
      props = props ? [pair2].concat(props) : [pair2];
    }
    return new Tree(type, children2, positions2, length2, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
    let result = { size: 0, start: 0, skip: 0 };
    scan:
      for (let minPos = fork.pos - maxSize; fork.pos > minPos; ) {
        let nodeSize2 = fork.size;
        if (fork.id == inRepeat && nodeSize2 >= 0) {
          result.size = size;
          result.start = start;
          result.skip = skip;
          skip += 4;
          size += 4;
          fork.next();
          continue;
        }
        let startPos = fork.pos - nodeSize2;
        if (nodeSize2 < 0 || startPos < minPos || fork.start < minStart)
          break;
        let localSkipped = fork.id >= minRepeatType ? 4 : 0;
        let nodeStart = fork.start;
        fork.next();
        while (fork.pos > startPos) {
          if (fork.size < 0) {
            if (fork.size == -3 || fork.size == -4)
              localSkipped += 4;
            else
              break scan;
          } else if (fork.id >= minRepeatType) {
            localSkipped += 4;
          }
          fork.next();
        }
        start = nodeStart;
        size += nodeSize2;
        skip += localSkipped;
      }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : void 0;
  }
  function copyToBuffer(bufferStart, buffer2, index) {
    let { id: id2, start, end, size } = cursor;
    cursor.next();
    if (size >= 0 && id2 < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos)
          index = copyToBuffer(bufferStart, buffer2, index);
      }
      buffer2[--index] = startIndex;
      buffer2[--index] = end - bufferStart;
      buffer2[--index] = start - bufferStart;
      buffer2[--index] = id2;
    } else if (size == -3) {
      contextHash = id2;
    } else if (size == -4) {
      lookAhead = id2;
    }
    return index;
  }
  let children = [], positions = [];
  while (cursor.pos > 0)
    takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
var nodeSizeCache = /* @__PURE__ */ new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
    return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (let child of node.children) {
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++)
    total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(
    total * 1.5 / 8
    /* Balance.BranchFactor */
  );
  let localChildren = [], localPositions = [];
  function divide(children2, positions2, from2, to2, offset) {
    for (let i = from2; i < to2; ) {
      let groupFrom = i, groupStart = positions2[i], groupSize = nodeSize(balanceType, children2[i]);
      i++;
      for (; i < to2; i++) {
        let nextSize = nodeSize(balanceType, children2[i]);
        if (groupSize + nextSize >= maxChild)
          break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children2[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions2[groupFrom] + offset);
          continue;
        }
        localChildren.push(children2[groupFrom]);
      } else {
        let length2 = positions2[i - 1] + children2[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children2, positions2, groupFrom, i, groupStart, length2, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
var NodeWeakMap = class {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner)
      this.map.set(buffer, inner = /* @__PURE__ */ new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  /**
  Set the value for this syntax node.
  */
  set(node, value) {
    if (node instanceof BufferNode)
      this.setBuffer(node.context.buffer, node.index, value);
    else if (node instanceof TreeNode)
      this.map.set(node.tree, value);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(node) {
    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(cursor, value) {
    if (cursor.buffer)
      this.setBuffer(cursor.buffer.buffer, cursor.index, value);
    else
      this.map.set(cursor.tree, value);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(cursor) {
    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
  }
};
var Parser = class {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(input, fragments, ranges) {
    if (typeof input == "string")
      input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map((r) => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (; ; ) {
      let done = parse.advance();
      if (done)
        return done;
    }
  }
};
var StringInput = class {
  constructor(string2) {
    this.string = string2;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
};
var stoppedInner = new NodeProp({ perNode: true });

// node_modules/@lezer/lr/dist/index.js
var Stack = class _Stack {
  /**
  @internal
  */
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead = 0, parent) {
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(p, state, pos = 0) {
    let cx = p.parser.context;
    return new _Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(action) {
    var _a;
    let depth = action >> 19, type = action & 65535;
    let { parser: parser2 } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25 && this.setLookAhead(this.pos);
    let dPrec = parser2.dynamicPrecedence(type);
    if (dPrec)
      this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser2.getGoto(this.state, type, true), this.reducePos);
      if (type < parser2.minRepeatTerm)
        this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
    if (size >= 2e3 && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser2.minRepeatTerm || action & 131072) {
      let pos = parser2.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser2.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base)
      this.stack.pop();
    this.reduceContext(type, start);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(term, start, end, size = 4, mustSink = false) {
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this, top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end)
          return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && (this.buffer[index - 4] != 0 || this.buffer[index - 1] < 0)) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove)
          while (index > 0 && this.buffer[index - 2] > end) {
            this.buffer[index] = this.buffer[index - 4];
            this.buffer[index + 1] = this.buffer[index - 3];
            this.buffer[index + 2] = this.buffer[index - 2];
            this.buffer[index + 3] = this.buffer[index - 1];
            index -= 4;
            if (size > 4)
              size -= 4;
          }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action, { parser: parser2 } = this.p;
      if (end > this.pos || type <= parser2.maxNode) {
        this.pos = end;
        if (!parser2.stateFlag(
          nextState,
          1
          /* StateFlag.Skipped */
        ))
          this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser2.maxNode)
        this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode)
        this.buffer.push(type, start, end, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536)
      this.reduce(action);
    else
      this.shift(action, next, nextStart, nextEnd);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(
      index,
      start,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    );
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
      off -= 4;
    let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase)
      parent = parent.parent;
    return new _Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode)
      this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(term) {
    for (let sim = new SimulatedStack(this); ; ) {
      let action = this.p.parser.stateSlot(
        sim.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(sim.state, term);
      if (action == 0)
        return false;
      if ((action & 65536) == 0)
        return true;
      sim.reduce(action);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(next) {
    if (this.stack.length >= 300)
      return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
          best.push(nextStates[i], s);
      }
      if (this.stack.length < 120)
        for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
          let s = nextStates[i + 1];
          if (!best.some((v, i2) => i2 & 1 && v == s))
            best.push(nextStates[i], s);
        }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state)
        continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: parser2 } = this.p;
    let reduce = parser2.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if ((reduce & 65536) == 0)
      return false;
    if (!parser2.validAction(this.state, reduce)) {
      let depth = reduce >> 19, term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser2.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null)
          return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: parser2 } = this.p, seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state))
        return;
      seen.push(state);
      return parser2.allActions(state, (action) => {
        if (action & (262144 | 131072))
          ;
        else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535, target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser2.getGoto(this.stack[target], term, false) >= 0)
              return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null)
            return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    while (!this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    )) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return false;
    let { parser: parser2 } = this.p;
    return parser2.data[parser2.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !parser2.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length)
      return false;
    for (let i = 0; i < this.stack.length; i += 3)
      if (this.stack[i] != other.stack[i])
        return false;
    return true;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext)
      this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  /**
  @internal
  */
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3)
      this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4)
      this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash)
        this.emitContext();
      this.curContext = newCx;
    }
  }
  /**
  @internal
  */
  setLookAhead(lookAhead) {
    if (lookAhead <= this.lookAhead)
      return false;
    this.emitLookAhead();
    this.lookAhead = lookAhead;
    return true;
  }
  /**
  @internal
  */
  close() {
    if (this.curContext && this.curContext.tracker.strict)
      this.emitContext();
    if (this.lookAhead > 0)
      this.emitLookAhead();
  }
};
var StackContext = class {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
};
var SimulatedStack = class {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535, depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack)
        this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
};
var StackBufferCursor = class _StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0)
      this.maybeNext();
  }
  static create(stack, pos = stack.bufferBase + stack.buffer.length) {
    return new _StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0)
      this.maybeNext();
  }
  fork() {
    return new _StackBufferCursor(this.stack, this.pos, this.index);
  }
};
function decodeArray(input, Type = Uint16Array) {
  if (typeof input != "string")
    return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length; ) {
    let value = 0;
    for (; ; ) {
      let next = input.charCodeAt(pos++), stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92)
        next--;
      if (next >= 34)
        next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop)
        break;
      value *= 46;
    }
    if (array)
      array[out++] = value;
    else
      array = new Type(value);
  }
  return array;
}
var CachedToken = class {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
};
var nullToken = new CachedToken();
var InputStream = class {
  /**
  @internal
  */
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(offset, assoc) {
    let range = this.range, index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index)
        return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1)
        return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  /**
  @internal
  */
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to)
      return pos;
    for (let range of this.ranges)
      if (range.to > pos)
        return Math.max(pos, range.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(offset) {
    let idx = this.chunkOff + offset, pos, result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null)
        return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex, range = this.range;
        while (range.to <= pos)
          range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to)
          this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead)
      this.token.lookAhead = pos + 1;
    return result;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(token, endOffset = 0) {
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk, chunkPos } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length)
        return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(n = 1) {
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead)
      this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  /**
  @internal
  */
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from)
        this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to)
        this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to)
      return this.input.read(from, to);
    let result = "";
    for (let r of this.ranges) {
      if (r.from >= to)
        break;
      if (r.to > from)
        result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
};
var TokenGroup = class {
  constructor(data, id2) {
    this.data = data;
    this.id = id2;
  }
  token(input, stack) {
    let { parser: parser2 } = stack.p;
    readToken(this.data, input, stack, this.id, parser2.data, parser2.tokenPrecTable);
  }
};
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var LocalTokenGroup = class {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos, skipped = 0;
    for (; ; ) {
      let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (!atEof)
        skipped++;
      if (nextPos == null)
        break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
};
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
var ExternalTokenizer = class {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(token, options = {}) {
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
};
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
  scan:
    for (; ; ) {
      if ((groupMask & data[state]) == 0)
        break;
      let accEnd = data[state + 1];
      for (let i = state + 3; i < accEnd; i += 2)
        if ((data[i + 1] & groupMask) > 0) {
          let term = data[i];
          if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
            input.acceptToken(term);
            break;
          }
        }
      let next = input.next, low = 0, high = data[state + 2];
      if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
        state = data[accEnd + high * 3 - 1];
        continue scan;
      }
      for (; low < high; ) {
        let mid = low + high >> 1;
        let index = accEnd + mid + (mid << 1);
        let from = data[index], to = data[index + 1] || 65536;
        if (next < from)
          high = mid;
        else if (next >= to)
          low = mid + 1;
        else {
          state = data[index + 2];
          input.advance();
          continue scan;
        }
      }
      break;
    }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++)
    if (next == term)
      return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
var verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
var stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(IterMode.IncludeAnonymous);
  cursor.moveTo(pos);
  for (; ; ) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
      for (; ; ) {
        if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
          return side < 0 ? Math.max(0, Math.min(
            cursor.to - 1,
            pos - 25
            /* Lookahead.Margin */
          )) : Math.min(tree.length, Math.max(
            cursor.from + 1,
            pos + 25
            /* Lookahead.Margin */
          ));
        if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
          break;
        if (!cursor.parent())
          return side < 0 ? 0 : tree.length;
      }
  }
}
var FragmentCursor = class {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(pos) {
    if (pos < this.nextStart)
      return null;
    while (this.fragment && this.safeTo <= pos)
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last], index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof Tree) {
        if (start == pos) {
          if (start < this.safeFrom)
            return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(NodeProp.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to)
              return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
};
var TokenCache = class {
  constructor(parser2, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser2.tokenizers.map((_) => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let { parser: parser2 } = stack.p, { tokenizers } = parser2;
    let mask = parser2.stateSlot(
      stack.state,
      3
      /* ParseState.TokenizerMask */
    );
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0)
        continue;
      let tokenizer = tokenizers[i], token = this.tokens[i];
      if (main && !tokenizer.fallback)
        continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25)
        lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1)
          actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex)
            break;
        }
      }
    }
    while (this.actions.length > actionIndex)
      this.actions.pop();
    if (lookAhead)
      stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken)
      return this.mainToken;
    let main = new CachedToken(), { pos, p } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let { parser: parser2 } = stack.p;
      for (let i = 0; i < parser2.specialized.length; i++)
        if (parser2.specialized[i] == token.value) {
          let result = parser2.specializers[i](this.stream.read(token.start, token.end), stack);
          if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
            if ((result & 1) == 0)
              token.value = result >> 1;
            else
              token.extended = result >> 1;
            break;
          }
        }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3)
      if (this.actions[i] == action)
        return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let { state } = stack, { parser: parser2 } = stack.p, { data } = parser2;
    for (let set = 0; set < 2; set++) {
      for (let i = parser2.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ); ; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2)
              index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token)
          index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
};
var Parse = class {
  constructor(parser2, input, fragments, ranges) {
    this.parser = parser2;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 9812;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser2, this.stream);
    this.topTerm = parser2.top[1];
    let { from } = ranges[0];
    this.stacks = [Stack.start(this, parser2.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser2.bufferLength * 4 ? new FragmentCursor(fragments, parser2.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let stacks = this.stacks, pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {
      }
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (; ; ) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose)
          console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped)
          console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering)
        this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose)
          console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining)
          newStacks.pop();
      }
      if (newStacks.some((s) => s.reducePos > pos))
        this.recovering--;
    } else if (newStacks.length > 1) {
      outer:
        for (let i = 0; i < newStacks.length - 1; i++) {
          let stack = newStacks[i];
          for (let j = i + 1; j < newStacks.length; j++) {
            let other = newStacks[j];
            if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
              if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
                newStacks.splice(j--, 1);
              } else {
                newStacks.splice(i--, 1);
                continue outer;
              }
            }
          }
        }
      if (newStacks.length > 12)
        newStacks.splice(
          12,
          newStacks.length - 12
          /* Rec.MaxStackCount */
        );
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++)
      if (newStacks[i].pos < this.minStackPos)
        this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(stack, stacks, split) {
    let start = stack.pos, { parser: parser2 } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt)
      return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached; ) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser2.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose)
            console.log(base + this.stackID(stack) + ` (via reuse of ${parser2.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)
          break;
        let inner = cached.children[0];
        if (inner instanceof Tree && cached.positions[0] == 0)
          cached = inner;
        else
          break;
      }
    }
    let defaultReduce = parser2.stateSlot(
      stack.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose)
        console.log(base + this.stackID(stack) + ` (via always-reduce ${parser2.getName(
          defaultReduce & 65535
          /* Action.ValueMask */
        )})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6e3 && stack.forceReduce()) {
      }
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length; ) {
      let action = actions[i++], term = actions[i++], end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose)
        console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser2.getName(
          action & 65535
          /* Action.ValueMask */
        )}`} for ${parser2.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last)
        return true;
      else if (localStack.pos > start)
        stacks.push(localStack);
      else
        split.push(localStack);
    }
    return false;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (; ; ) {
      if (!this.advanceStack(stack, null, null))
        return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null, restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted)
          continue;
        restarted = true;
        stack.restart();
        if (verbose)
          console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done)
          continue;
      }
      let force = stack.split(), forceBase = base;
      for (let j = 0; j < 10 && force.forceReduce(); j++) {
        if (verbose)
          console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done)
          break;
        if (verbose)
          forceBase = this.stackID(force) + " -> ";
      }
      for (let insert of stack.recoverByInsert(token)) {
        if (verbose)
          console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose)
          console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(stack) {
    stack.close();
    return Tree.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id2 = (stackIDs || (stackIDs = /* @__PURE__ */ new WeakMap())).get(stack);
    if (!id2)
      stackIDs.set(stack, id2 = String.fromCodePoint(this.nextStackID++));
    return id2 + stack;
  }
};
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score)
        newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
var Dialect = class {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
};
var id = (x) => x;
var ContextTracker = class {
  /**
  Define a context tracker.
  */
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
};
var LRParser = class _LRParser extends Parser {
  /**
  @internal
  */
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14)
      throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++)
      nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map((r) => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++)
      nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps)
      for (let propSpec of spec.nodeProps) {
        let prop = propSpec[0];
        if (typeof prop == "string")
          prop = NodeProp[prop];
        for (let i = 1; i < propSpec.length; ) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--)
              setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    this.nodeSet = new NodeSet(nodeNames.map((name2, i) => NodeType.define({
      name: i >= this.minRepeatTerm ? void 0 : name2,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources)
      this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = DefaultBufferLength;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++)
      this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map((value) => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (let w of this.wrappers)
      parse = w(parse, input, fragments, ranges);
    return parse;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(state, term, loose = false) {
    let table = this.goto;
    if (term >= table[0])
      return -1;
    for (let pos = table[term + 1]; ; ) {
      let groupTag = table[pos++], last = groupTag & 1;
      let target = table[pos++];
      if (last && loose)
        return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++)
        if (table[pos] == state)
          return target;
      if (last)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(
        state,
        set ? 2 : 1
        /* ParseState.Actions */
      ), next; ; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1)
            next = data[i = pair(data, i + 2)];
          else if (data[i + 1] == 2)
            return pair(data, i + 2);
          else
            break;
        }
        if (next == terminal || next == 0)
          return pair(data, i + 1);
      }
    }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  /**
  @internal
  */
  stateFlag(state, flag) {
    return (this.stateSlot(
      state,
      0
      /* ParseState.Flags */
    ) & flag) > 0;
  }
  /**
  @internal
  */
  validAction(state, action) {
    return !!this.allActions(state, (a) => a == action ? true : null);
  }
  /**
  @internal
  */
  allActions(state, action) {
    let deflt = this.stateSlot(
      state,
      4
      /* ParseState.DefaultReduce */
    );
    let result = deflt ? action(deflt) : void 0;
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(
      state,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1)
          i = pair(this.data, i + 2);
        else
          break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i2) => i2 & 1 && v == value))
          result.push(this.data[i], value);
      }
    }
    return result;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(config3) {
    let copy = Object.assign(Object.create(_LRParser.prototype), this);
    if (config3.props)
      copy.nodeSet = this.nodeSet.extend(...config3.props);
    if (config3.top) {
      let info = this.topRules[config3.top];
      if (!info)
        throw new RangeError(`Invalid top rule name ${config3.top}`);
      copy.top = info;
    }
    if (config3.tokenizers)
      copy.tokenizers = this.tokenizers.map((t2) => {
        let found = config3.tokenizers.find((r) => r.from == t2);
        return found ? found.to : t2;
      });
    if (config3.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config3.specializers.find((r) => r.from == s.external);
        if (!found)
          return s;
        let spec = Object.assign(Object.assign({}, s), { external: found.to });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config3.contextTracker)
      copy.context = config3.contextTracker;
    if (config3.dialect)
      copy.dialect = this.parseDialect(config3.dialect);
    if (config3.strict != null)
      copy.strict = config3.strict;
    if (config3.wrap)
      copy.wrappers = copy.wrappers.concat(config3.wrap);
    if (config3.bufferLength != null)
      copy.bufferLength = config3.bufferLength;
    return copy;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  /**
  @internal
  */
  parseDialect(dialect) {
    let values = Object.keys(this.dialects), flags = values.map(() => false);
    if (dialect)
      for (let part of dialect.split(" ")) {
        let id2 = values.indexOf(part);
        if (id2 >= 0)
          flags[id2] = true;
      }
    let disabled = null;
    for (let i = 0; i < values.length; i++)
      if (!flags[i]) {
        for (let j = this.dialects[values[i]], id2; (id2 = this.data[j++]) != 65535; )
          (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id2] = 1;
      }
    return new Dialect(dialect, flags, disabled);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(spec) {
    return new _LRParser(spec);
  }
};
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (let stack of stacks) {
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(
      stack.state,
      2
      /* StateFlag.Accepting */
    ) && (!best || best.score < stack.score))
      best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}

// node_modules/@lezer/highlight/dist/index.js
var nextTagID = 0;
var Tag = class _Tag {
  /**
  @internal
  */
  constructor(name2, set, base, modified) {
    this.name = name2;
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let { name: name2 } = this;
    for (let mod of this.modified)
      if (mod.name)
        name2 = `${mod.name}(${name2})`;
    return name2;
  }
  static define(nameOrParent, parent) {
    let name2 = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof _Tag)
      parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base)
      throw new Error("Can not derive from a modified tag");
    let tag = new _Tag(name2, [], null, []);
    tag.set.push(tag);
    if (parent)
      for (let t2 of parent.set)
        tag.set.push(t2);
    return tag;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier(name2) {
    let mod = new Modifier(name2);
    return (tag) => {
      if (tag.modified.indexOf(mod) > -1)
        return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
};
var nextModifierID = 0;
var Modifier = class _Modifier {
  constructor(name2) {
    this.name = name2;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length)
      return base;
    let exists = mods[0].instances.find((t2) => t2.base == base && sameArray(mods, t2.modified));
    if (exists)
      return exists;
    let set = [], tag = new Tag(base.name, set, base, mods);
    for (let m of mods)
      m.instances.push(tag);
    let configs = powerSet(mods);
    for (let parent of base.set)
      if (!parent.modified.length)
        for (let config3 of configs)
          set.push(_Modifier.get(parent, config3));
    return tag;
  }
};
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = /* @__PURE__ */ Object.create(null);
  for (let prop in spec) {
    let tags2 = spec[prop];
    if (!Array.isArray(tags2))
      tags2 = [tags2];
    for (let part of prop.split(" "))
      if (part) {
        let pieces = [], mode = 2, rest = part;
        for (let pos = 0; ; ) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m)
            throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length)
            break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/")
            throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1, inner = pieces[last];
        if (!inner)
          throw new RangeError("Invalid path: " + part);
        let rule = new Rule2(tags2, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
  }
  return ruleNodeProp.add(byName);
}
var ruleNodeProp = new NodeProp({
  combine(a, b) {
    let cur, root, take;
    while (a || b) {
      if (!a || b && a.depth >= b.depth) {
        take = b;
        b = b.next;
      } else {
        take = a;
        a = a.next;
      }
      if (cur && cur.mode == take.mode && !take.context && !cur.context)
        continue;
      let copy = new Rule2(take.tags, take.mode, take.context);
      if (cur)
        cur.next = copy;
      else
        root = copy;
      cur = copy;
    }
    return root;
  }
});
var Rule2 = class {
  constructor(tags2, mode, context, next) {
    this.tags = tags2;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
};
Rule2.empty = new Rule2([], 2, null);
function tagHighlighter(tags2, options) {
  let map = /* @__PURE__ */ Object.create(null);
  for (let style of tags2) {
    if (!Array.isArray(style.tag))
      map[style.tag.id] = style.class;
    else
      for (let tag of style.tag)
        map[tag.id] = style.class;
  }
  let { scope, all = null } = options || {};
  return {
    style: (tags3) => {
      let cls = all;
      for (let tag of tags3) {
        for (let sub of tag.set) {
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
var t = Tag.define;
var comment = t();
var name = t();
var typeName = t(name);
var propertyName = t(name);
var literal = t();
var string = t(literal);
var number = t(literal);
var content = t();
var heading = t(content);
var keyword = t();
var operator = t();
var punctuation = t();
var bracket = t(punctuation);
var meta = t();
var tags = {
  /**
  A comment.
  */
  comment,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: t(comment),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: t(comment),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: t(comment),
  /**
  Any kind of identifier.
  */
  name,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: t(name),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: t(typeName),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: t(propertyName),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: t(name),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: t(name),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: t(name),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: t(name),
  /**
  A literal value.
  */
  literal,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: t(string),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: t(string),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: t(string),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: t(number),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: t(number),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: t(literal),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: t(literal),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: t(literal),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: t(literal),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: t(literal),
  /**
  A language keyword.
  */
  keyword,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: t(keyword),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: t(keyword),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: t(keyword),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: t(keyword),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: t(keyword),
  /**
  An operator.
  */
  operator,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: t(operator),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: t(operator),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: t(operator),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: t(operator),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: t(operator),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: t(operator),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: t(operator),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: t(operator),
  /**
  Program or markup punctuation.
  */
  punctuation,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: t(punctuation),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: t(bracket),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: t(bracket),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: t(bracket),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: t(bracket),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: t(heading),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: t(heading),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: t(heading),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: t(heading),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: t(heading),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: t(heading),
  /**
  A prose [content](#highlight.tags.content) separator (such as a horizontal rule).
  */
  contentSeparator: t(content),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: t(content),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: t(content),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: t(content),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: t(content),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: t(content),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: t(content),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: t(content),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: t(),
  /**
  Deleted text.
  */
  deleted: t(),
  /**
  Changed text.
  */
  changed: t(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: t(),
  /**
  Metadata or meta-instruction.
  */
  meta,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: t(meta),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: t(meta),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: t(meta),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Tag.defineModifier("definition"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Tag.defineModifier("constant"),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Tag.defineModifier("function"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Tag.defineModifier("standard"),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Tag.defineModifier("local"),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Tag.defineModifier("special")
};
for (let name2 in tags) {
  let val = tags[name2];
  if (val instanceof Tag)
    val.name = name2;
}
var classHighlighter = tagHighlighter([
  { tag: tags.link, class: "tok-link" },
  { tag: tags.heading, class: "tok-heading" },
  { tag: tags.emphasis, class: "tok-emphasis" },
  { tag: tags.strong, class: "tok-strong" },
  { tag: tags.keyword, class: "tok-keyword" },
  { tag: tags.atom, class: "tok-atom" },
  { tag: tags.bool, class: "tok-bool" },
  { tag: tags.url, class: "tok-url" },
  { tag: tags.labelName, class: "tok-labelName" },
  { tag: tags.inserted, class: "tok-inserted" },
  { tag: tags.deleted, class: "tok-deleted" },
  { tag: tags.literal, class: "tok-literal" },
  { tag: tags.string, class: "tok-string" },
  { tag: tags.number, class: "tok-number" },
  { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
  { tag: tags.variableName, class: "tok-variableName" },
  { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
  { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
  { tag: tags.special(tags.variableName), class: "tok-variableName2" },
  { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
  { tag: tags.typeName, class: "tok-typeName" },
  { tag: tags.namespace, class: "tok-namespace" },
  { tag: tags.className, class: "tok-className" },
  { tag: tags.macroName, class: "tok-macroName" },
  { tag: tags.propertyName, class: "tok-propertyName" },
  { tag: tags.operator, class: "tok-operator" },
  { tag: tags.comment, class: "tok-comment" },
  { tag: tags.meta, class: "tok-meta" },
  { tag: tags.invalid, class: "tok-invalid" },
  { tag: tags.punctuation, class: "tok-punctuation" }
]);

// node_modules/@lezer/python/dist/index.js
var printKeyword = 1;
var indent = 194;
var dedent = 195;
var newline$1 = 196;
var blankLineStart = 197;
var newlineBracketed = 198;
var eof = 199;
var stringContent = 200;
var Escape = 2;
var replacementStart = 3;
var stringEnd = 201;
var ParenL = 24;
var ParenthesizedExpression = 25;
var TupleExpression = 49;
var ComprehensionExpression = 50;
var BracketL = 55;
var ArrayExpression = 56;
var ArrayComprehensionExpression = 57;
var BraceL = 59;
var DictionaryExpression = 60;
var DictionaryComprehensionExpression = 61;
var SetExpression = 62;
var SetComprehensionExpression = 63;
var ArgList = 65;
var subscript = 238;
var String$1 = 71;
var stringStart = 241;
var stringStartD = 242;
var stringStartL = 243;
var stringStartLD = 244;
var stringStartR = 245;
var stringStartRD = 246;
var stringStartRL = 247;
var stringStartRLD = 248;
var FormatString = 72;
var stringStartF = 249;
var stringStartFD = 250;
var stringStartFL = 251;
var stringStartFLD = 252;
var stringStartFR = 253;
var stringStartFRD = 254;
var stringStartFRL = 255;
var stringStartFRLD = 256;
var FormatReplacement = 73;
var nestedFormatReplacement = 77;
var importList = 263;
var TypeParamList = 112;
var ParamList = 130;
var SequencePattern = 151;
var MappingPattern = 152;
var PatternArgList = 155;
var newline = 10;
var carriageReturn = 13;
var space = 32;
var tab = 9;
var hash = 35;
var parenOpen = 40;
var dot = 46;
var braceOpen = 123;
var braceClose = 125;
var singleQuote = 39;
var doubleQuote = 34;
var backslash = 92;
var letter_o = 111;
var letter_x = 120;
var letter_N = 78;
var letter_u = 117;
var letter_U = 85;
var bracketed = /* @__PURE__ */ new Set([
  ParenthesizedExpression,
  TupleExpression,
  ComprehensionExpression,
  importList,
  ArgList,
  ParamList,
  ArrayExpression,
  ArrayComprehensionExpression,
  subscript,
  SetExpression,
  SetComprehensionExpression,
  FormatString,
  FormatReplacement,
  nestedFormatReplacement,
  DictionaryExpression,
  DictionaryComprehensionExpression,
  SequencePattern,
  MappingPattern,
  PatternArgList,
  TypeParamList
]);
function isLineBreak(ch) {
  return ch == newline || ch == carriageReturn;
}
function isHex(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
var newlines = new ExternalTokenizer((input, stack) => {
  let prev;
  if (input.next < 0) {
    input.acceptToken(eof);
  } else if (stack.context.flags & cx_Bracketed) {
    if (isLineBreak(input.next))
      input.acceptToken(newlineBracketed, 1);
  } else if (((prev = input.peek(-1)) < 0 || isLineBreak(prev)) && stack.canShift(blankLineStart)) {
    let spaces = 0;
    while (input.next == space || input.next == tab) {
      input.advance();
      spaces++;
    }
    if (input.next == newline || input.next == carriageReturn || input.next == hash)
      input.acceptToken(blankLineStart, -spaces);
  } else if (isLineBreak(input.next)) {
    input.acceptToken(newline$1, 1);
  }
}, { contextual: true });
var indentation = new ExternalTokenizer((input, stack) => {
  let context = stack.context;
  if (context.flags)
    return;
  let prev = input.peek(-1);
  if (prev == newline || prev == carriageReturn) {
    let depth = 0, chars = 0;
    for (; ; ) {
      if (input.next == space)
        depth++;
      else if (input.next == tab)
        depth += 8 - depth % 8;
      else
        break;
      input.advance();
      chars++;
    }
    if (depth != context.indent && input.next != newline && input.next != carriageReturn && input.next != hash) {
      if (depth < context.indent)
        input.acceptToken(dedent, -chars);
      else
        input.acceptToken(indent);
    }
  }
});
var cx_Bracketed = 1;
var cx_String = 2;
var cx_DoubleQuote = 4;
var cx_Long = 8;
var cx_Raw = 16;
var cx_Format = 32;
function Context(parent, indent2, flags) {
  this.parent = parent;
  this.indent = indent2;
  this.flags = flags;
  this.hash = (parent ? parent.hash + parent.hash << 8 : 0) + indent2 + (indent2 << 4) + flags + (flags << 6);
}
var topIndent = new Context(null, 0, 0);
function countIndent(space2) {
  let depth = 0;
  for (let i = 0; i < space2.length; i++)
    depth += space2.charCodeAt(i) == tab ? 8 - depth % 8 : 1;
  return depth;
}
var stringFlags = new Map([
  [stringStart, 0],
  [stringStartD, cx_DoubleQuote],
  [stringStartL, cx_Long],
  [stringStartLD, cx_Long | cx_DoubleQuote],
  [stringStartR, cx_Raw],
  [stringStartRD, cx_Raw | cx_DoubleQuote],
  [stringStartRL, cx_Raw | cx_Long],
  [stringStartRLD, cx_Raw | cx_Long | cx_DoubleQuote],
  [stringStartF, cx_Format],
  [stringStartFD, cx_Format | cx_DoubleQuote],
  [stringStartFL, cx_Format | cx_Long],
  [stringStartFLD, cx_Format | cx_Long | cx_DoubleQuote],
  [stringStartFR, cx_Format | cx_Raw],
  [stringStartFRD, cx_Format | cx_Raw | cx_DoubleQuote],
  [stringStartFRL, cx_Format | cx_Raw | cx_Long],
  [stringStartFRLD, cx_Format | cx_Raw | cx_Long | cx_DoubleQuote]
].map(([term, flags]) => [term, flags | cx_String]));
var trackIndent = new ContextTracker({
  start: topIndent,
  reduce(context, term, _, input) {
    if (context.flags & cx_Bracketed && bracketed.has(term) || (term == String$1 || term == FormatString) && context.flags & cx_String)
      return context.parent;
    return context;
  },
  shift(context, term, stack, input) {
    if (term == indent)
      return new Context(context, countIndent(input.read(input.pos, stack.pos)), 0);
    if (term == dedent)
      return context.parent;
    if (term == ParenL || term == BracketL || term == BraceL || term == replacementStart)
      return new Context(context, 0, cx_Bracketed);
    if (stringFlags.has(term))
      return new Context(context, 0, stringFlags.get(term) | context.flags & cx_Bracketed);
    return context;
  },
  hash(context) {
    return context.hash;
  }
});
var legacyPrint = new ExternalTokenizer((input) => {
  for (let i = 0; i < 5; i++) {
    if (input.next != "print".charCodeAt(i))
      return;
    input.advance();
  }
  if (/\w/.test(String.fromCharCode(input.next)))
    return;
  for (let off = 0; ; off++) {
    let next = input.peek(off);
    if (next == space || next == tab)
      continue;
    if (next != parenOpen && next != dot && next != newline && next != carriageReturn && next != hash)
      input.acceptToken(printKeyword);
    return;
  }
});
var strings = new ExternalTokenizer((input, stack) => {
  let { flags } = stack.context;
  let quote = flags & cx_DoubleQuote ? doubleQuote : singleQuote;
  let long = (flags & cx_Long) > 0;
  let escapes = !(flags & cx_Raw);
  let format = (flags & cx_Format) > 0;
  let start = input.pos;
  for (; ; ) {
    if (input.next < 0) {
      break;
    } else if (format && input.next == braceOpen) {
      if (input.peek(1) == braceOpen) {
        input.advance(2);
      } else {
        if (input.pos == start) {
          input.acceptToken(replacementStart, 1);
          return;
        }
        break;
      }
    } else if (escapes && input.next == backslash) {
      if (input.pos == start) {
        input.advance();
        let escaped = input.next;
        if (escaped >= 0) {
          input.advance();
          skipEscape(input, escaped);
        }
        input.acceptToken(Escape);
        return;
      }
      break;
    } else if (input.next == backslash && !escapes && input.peek(1) > -1) {
      input.advance(2);
    } else if (input.next == quote && (!long || input.peek(1) == quote && input.peek(2) == quote)) {
      if (input.pos == start) {
        input.acceptToken(stringEnd, long ? 3 : 1);
        return;
      }
      break;
    } else if (input.next == newline) {
      if (long) {
        input.advance();
      } else if (input.pos == start) {
        input.acceptToken(stringEnd);
        return;
      }
      break;
    } else {
      input.advance();
    }
  }
  if (input.pos > start)
    input.acceptToken(stringContent);
});
function skipEscape(input, ch) {
  if (ch == letter_o) {
    for (let i = 0; i < 2 && input.next >= 48 && input.next <= 55; i++)
      input.advance();
  } else if (ch == letter_x) {
    for (let i = 0; i < 2 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_u) {
    for (let i = 0; i < 4 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_U) {
    for (let i = 0; i < 8 && isHex(input.next); i++)
      input.advance();
  } else if (ch == letter_N) {
    if (input.next == braceOpen) {
      input.advance();
      while (input.next >= 0 && input.next != braceClose && input.next != singleQuote && input.next != doubleQuote && input.next != newline)
        input.advance();
      if (input.next == braceClose)
        input.advance();
    }
  }
}
var pythonHighlighting = styleTags({
  'async "*" "**" FormatConversion FormatSpec': tags.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": tags.controlKeyword,
  "in not and or is del": tags.operatorKeyword,
  "from def class global nonlocal lambda": tags.definitionKeyword,
  import: tags.moduleKeyword,
  "with as print": tags.keyword,
  Boolean: tags.bool,
  None: tags.null,
  VariableName: tags.variableName,
  "CallExpression/VariableName": tags.function(tags.variableName),
  "FunctionDefinition/VariableName": tags.function(tags.definition(tags.variableName)),
  "ClassDefinition/VariableName": tags.definition(tags.className),
  PropertyName: tags.propertyName,
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  Comment: tags.lineComment,
  Number: tags.number,
  String: tags.string,
  FormatString: tags.special(tags.string),
  Escape: tags.escape,
  UpdateOp: tags.updateOperator,
  "ArithOp!": tags.arithmeticOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  AssignOp: tags.definitionOperator,
  Ellipsis: tags.punctuation,
  At: tags.meta,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  ".": tags.derefOperator,
  ", ;": tags.separator
});
var spec_identifier = { __proto__: null, await: 44, or: 54, and: 56, in: 60, not: 62, is: 64, if: 70, else: 72, lambda: 76, yield: 94, from: 96, async: 102, for: 104, None: 162, True: 164, False: 164, del: 178, pass: 182, break: 186, continue: 190, return: 194, raise: 202, import: 206, as: 208, global: 212, nonlocal: 214, assert: 218, type: 223, elif: 236, while: 240, try: 246, except: 248, finally: 250, with: 254, def: 258, class: 268, match: 279, case: 285 };
var parser = LRParser.deserialize({
  version: 14,
  states: "##jO`QeOOP$}OSOOO&WQtO'#HUOOQS'#Co'#CoOOQS'#Cp'#CpO'vQdO'#CnO*UQtO'#HTOOQS'#HU'#HUOOQS'#DU'#DUOOQS'#HT'#HTO*rQdO'#D_O+VQdO'#DfO+gQdO'#DjO+zOWO'#DuO,VOWO'#DvO.[QtO'#GuOOQS'#Gu'#GuO'vQdO'#GtO0ZQtO'#GtOOQS'#Eb'#EbO0rQdO'#EcOOQS'#Gs'#GsO0|QdO'#GrOOQV'#Gr'#GrO1XQdO'#FYOOQS'#G^'#G^O1^QdO'#FXOOQV'#IS'#ISOOQV'#Gq'#GqOOQV'#Fq'#FqQ`QeOOO'vQdO'#CqO1lQdO'#C}O1sQdO'#DRO2RQdO'#HYO2cQtO'#EVO'vQdO'#EWOOQS'#EY'#EYOOQS'#E['#E[OOQS'#E^'#E^O2wQdO'#E`O3_QdO'#EdO3rQdO'#EfO3zQtO'#EfO1XQdO'#EiO0rQdO'#ElO1XQdO'#EnO0rQdO'#EtO0rQdO'#EwO4VQdO'#EyO4^QdO'#FOO4iQdO'#EzO0rQdO'#FOO1XQdO'#FQO1XQdO'#FVO4nQdO'#F[P4uOdO'#GpPOOO)CBd)CBdOOQS'#Ce'#CeOOQS'#Cf'#CfOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Cl'#ClO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO'vQdO,59OO5TQdO'#DoOOQS,5:Y,5:YO5hQdO'#HdOOQS,5:],5:]O5uQ!fO,5:]O5zQtO,59YO1lQdO,59bO1lQdO,59bO1lQdO,59bO8jQdO,59bO8oQdO,59bO8vQdO,59jO8}QdO'#HTO:TQdO'#HSOOQS'#HS'#HSOOQS'#D['#D[O:lQdO,59aO'vQdO,59aO:zQdO,59aOOQS,59y,59yO;PQdO,5:RO'vQdO,5:ROOQS,5:Q,5:QO;_QdO,5:QO;dQdO,5:XO'vQdO,5:XO'vQdO,5:VOOQS,5:U,5:UO;uQdO,5:UO;zQdO,5:WOOOW'#Fy'#FyO<POWO,5:aOOQS,5:a,5:aO<[QdO'#HwOOOW'#Dw'#DwOOOW'#Fz'#FzO<lOWO,5:bOOQS,5:b,5:bOOQS'#F}'#F}O<zQtO,5:iO?lQtO,5=`O@VQ#xO,5=`O@vQtO,5=`OOQS,5:},5:}OA_QeO'#GWOBqQdO,5;^OOQV,5=^,5=^OB|QtO'#IPOCkQdO,5;tOOQS-E:[-E:[OOQV,5;s,5;sO4dQdO'#FQOOQV-E9o-E9oOCsQtO,59]OEzQtO,59iOFeQdO'#HVOFpQdO'#HVO1XQdO'#HVOF{QdO'#DTOGTQdO,59mOGYQdO'#HZO'vQdO'#HZO0rQdO,5=tOOQS,5=t,5=tO0rQdO'#EROOQS'#ES'#ESOGwQdO'#GPOHXQdO,58|OHXQdO,58|O*xQdO,5:oOHgQtO'#H]OOQS,5:r,5:rOOQS,5:z,5:zOHzQdO,5;OOI]QdO'#IOO1XQdO'#H}OOQS,5;Q,5;QOOQS'#GT'#GTOIqQtO,5;QOJPQdO,5;QOJUQdO'#IQOOQS,5;T,5;TOJdQdO'#H|OOQS,5;W,5;WOJuQdO,5;YO4iQdO,5;`O4iQdO,5;cOJ}QtO'#ITO'vQdO'#ITOKXQdO,5;eO4VQdO,5;eO0rQdO,5;jO1XQdO,5;lOK^QeO'#EuOLjQgO,5;fO!!kQdO'#IUO4iQdO,5;jO!!vQdO,5;lO!#OQdO,5;qO!#ZQtO,5;vO'vQdO,5;vPOOO,5=[,5=[P!#bOSO,5=[P!#jOdO,5=[O!&bQtO1G.jO!&iQtO1G.jO!)YQtO1G.jO!)dQtO1G.jO!+}QtO1G.jO!,bQtO1G.jO!,uQdO'#HcO!-TQtO'#GuO0rQdO'#HcO!-_QdO'#HbOOQS,5:Z,5:ZO!-gQdO,5:ZO!-lQdO'#HeO!-wQdO'#HeO!.[QdO,5>OOOQS'#Ds'#DsOOQS1G/w1G/wOOQS1G.|1G.|O!/[QtO1G.|O!/cQtO1G.|O1lQdO1G.|O!0OQdO1G/UOOQS'#DZ'#DZO0rQdO,59tOOQS1G.{1G.{O!0VQdO1G/eO!0gQdO1G/eO!0oQdO1G/fO'vQdO'#H[O!0tQdO'#H[O!0yQtO1G.{O!1ZQdO,59iO!2aQdO,5=zO!2qQdO,5=zO!2yQdO1G/mO!3OQtO1G/mOOQS1G/l1G/lO!3`QdO,5=uO!4VQdO,5=uO0rQdO1G/qO!4tQdO1G/sO!4yQtO1G/sO!5ZQtO1G/qOOQS1G/p1G/pOOQS1G/r1G/rOOOW-E9w-E9wOOQS1G/{1G/{O!5kQdO'#HxO0rQdO'#HxO!5|QdO,5>cOOOW-E9x-E9xOOQS1G/|1G/|OOQS-E9{-E9{O!6[Q#xO1G2zO!6{QtO1G2zO'vQdO,5<jOOQS,5<j,5<jOOQS-E9|-E9|OOQS,5<r,5<rOOQS-E:U-E:UOOQV1G0x1G0xO1XQdO'#GRO!7dQtO,5>kOOQS1G1`1G1`O!8RQdO1G1`OOQS'#DV'#DVO0rQdO,5=qOOQS,5=q,5=qO!8WQdO'#FrO!8cQdO,59oO!8kQdO1G/XO!8uQtO,5=uOOQS1G3`1G3`OOQS,5:m,5:mO!9fQdO'#GtOOQS,5<k,5<kOOQS-E9}-E9}O!9wQdO1G.hOOQS1G0Z1G0ZO!:VQdO,5=wO!:gQdO,5=wO0rQdO1G0jO0rQdO1G0jO!:xQdO,5>jO!;ZQdO,5>jO1XQdO,5>jO!;lQdO,5>iOOQS-E:R-E:RO!;qQdO1G0lO!;|QdO1G0lO!<RQdO,5>lO!<aQdO,5>lO!<oQdO,5>hO!=VQdO,5>hO!=hQdO'#EpO0rQdO1G0tO!=sQdO1G0tO!=xQgO1G0zO!AvQgO1G0}O!EqQdO,5>oO!E{QdO,5>oO!FTQtO,5>oO0rQdO1G1PO!F_QdO1G1PO4iQdO1G1UO!!vQdO1G1WOOQV,5;a,5;aO!FdQfO,5;aO!FiQgO1G1QO!JjQdO'#GZO4iQdO1G1QO4iQdO1G1QO!JzQdO,5>pO!KXQdO,5>pO1XQdO,5>pOOQV1G1U1G1UO!KaQdO'#FSO!KrQ!fO1G1WO!KzQdO1G1WOOQV1G1]1G1]O4iQdO1G1]O!LPQdO1G1]O!LXQdO'#F^OOQV1G1b1G1bO!#ZQtO1G1bPOOO1G2v1G2vP!L^OSO1G2vOOQS,5=},5=}OOQS'#Dp'#DpO0rQdO,5=}O!LfQdO,5=|O!LyQdO,5=|OOQS1G/u1G/uO!MRQdO,5>PO!McQdO,5>PO!MkQdO,5>PO!NOQdO,5>PO!N`QdO,5>POOQS1G3j1G3jOOQS7+$h7+$hO!8kQdO7+$pO#!RQdO1G.|O#!YQdO1G.|OOQS1G/`1G/`OOQS,5<`,5<`O'vQdO,5<`OOQS7+%P7+%PO#!aQdO7+%POOQS-E9r-E9rOOQS7+%Q7+%QO#!qQdO,5=vO'vQdO,5=vOOQS7+$g7+$gO#!vQdO7+%PO##OQdO7+%QO##TQdO1G3fOOQS7+%X7+%XO##eQdO1G3fO##mQdO7+%XOOQS,5<_,5<_O'vQdO,5<_O##rQdO1G3aOOQS-E9q-E9qO#$iQdO7+%]OOQS7+%_7+%_O#$wQdO1G3aO#%fQdO7+%_O#%kQdO1G3gO#%{QdO1G3gO#&TQdO7+%]O#&YQdO,5>dO#&sQdO,5>dO#&sQdO,5>dOOQS'#Dx'#DxO#'UO&jO'#DzO#'aO`O'#HyOOOW1G3}1G3}O#'fQdO1G3}O#'nQdO1G3}O#'yQ#xO7+(fO#(jQtO1G2UP#)TQdO'#GOOOQS,5<m,5<mOOQS-E:P-E:POOQS7+&z7+&zOOQS1G3]1G3]OOQS,5<^,5<^OOQS-E9p-E9pOOQS7+$s7+$sO#)bQdO,5=`O#){QdO,5=`O#*^QtO,5<aO#*qQdO1G3cOOQS-E9s-E9sOOQS7+&U7+&UO#+RQdO7+&UO#+aQdO,5<nO#+uQdO1G4UOOQS-E:Q-E:QO#,WQdO1G4UOOQS1G4T1G4TOOQS7+&W7+&WO#,iQdO7+&WOOQS,5<p,5<pO#,tQdO1G4WOOQS-E:S-E:SOOQS,5<l,5<lO#-SQdO1G4SOOQS-E:O-E:OO1XQdO'#EqO#-jQdO'#EqO#-uQdO'#IRO#-}QdO,5;[OOQS7+&`7+&`O0rQdO7+&`O#.SQgO7+&fO!JmQdO'#GXO4iQdO7+&fO4iQdO7+&iO#2QQtO,5<tO'vQdO,5<tO#2[QdO1G4ZOOQS-E:W-E:WO#2fQdO1G4ZO4iQdO7+&kO0rQdO7+&kOOQV7+&p7+&pO!KrQ!fO7+&rO!KzQdO7+&rO`QeO1G0{OOQV-E:X-E:XO4iQdO7+&lO4iQdO7+&lOOQV,5<u,5<uO#2nQdO,5<uO!JmQdO,5<uOOQV7+&l7+&lO#2yQgO7+&lO#6tQdO,5<vO#7PQdO1G4[OOQS-E:Y-E:YO#7^QdO1G4[O#7fQdO'#IWO#7tQdO'#IWO1XQdO'#IWOOQS'#IW'#IWO#8PQdO'#IVOOQS,5;n,5;nO#8XQdO,5;nO0rQdO'#FUOOQV7+&r7+&rO4iQdO7+&rOOQV7+&w7+&wO4iQdO7+&wO#8^QfO,5;xOOQV7+&|7+&|POOO7+(b7+(bO#8cQdO1G3iOOQS,5<c,5<cO#8qQdO1G3hOOQS-E9u-E9uO#9UQdO,5<dO#9aQdO,5<dO#9tQdO1G3kOOQS-E9v-E9vO#:UQdO1G3kO#:^QdO1G3kO#:nQdO1G3kO#:UQdO1G3kOOQS<<H[<<H[O#:yQtO1G1zOOQS<<Hk<<HkP#;WQdO'#FtO8vQdO1G3bO#;eQdO1G3bO#;jQdO<<HkOOQS<<Hl<<HlO#;zQdO7+)QOOQS<<Hs<<HsO#<[QtO1G1yP#<{QdO'#FsO#=YQdO7+)RO#=jQdO7+)RO#=rQdO<<HwO#=wQdO7+({OOQS<<Hy<<HyO#>nQdO,5<bO'vQdO,5<bOOQS-E9t-E9tOOQS<<Hw<<HwOOQS,5<g,5<gO0rQdO,5<gO#>sQdO1G4OOOQS-E9y-E9yO#?^QdO1G4OO<[QdO'#H{OOOO'#D{'#D{OOOO'#F|'#F|O#?oO&jO,5:fOOOW,5>e,5>eOOOW7+)i7+)iO#?zQdO7+)iO#@SQdO1G2zO#@mQdO1G2zP'vQdO'#FuO0rQdO<<IpO1XQdO1G2YP1XQdO'#GSO#AOQdO7+)pO#AaQdO7+)pOOQS<<Ir<<IrP1XQdO'#GUP0rQdO'#GQOOQS,5;],5;]O#ArQdO,5>mO#BQQdO,5>mOOQS1G0v1G0vOOQS<<Iz<<IzOOQV-E:V-E:VO4iQdO<<JQOOQV,5<s,5<sO4iQdO,5<sOOQV<<JQ<<JQOOQV<<JT<<JTO#BYQtO1G2`P#BdQdO'#GYO#BkQdO7+)uO#BuQgO<<JVO4iQdO<<JVOOQV<<J^<<J^O4iQdO<<J^O!KrQ!fO<<J^O#FpQgO7+&gOOQV<<JW<<JWO#FzQgO<<JWOOQV1G2a1G2aO1XQdO1G2aO#JuQdO1G2aO4iQdO<<JWO1XQdO1G2bP0rQdO'#G[O#KQQdO7+)vO#K_QdO7+)vOOQS'#FT'#FTO0rQdO,5>rO#KgQdO,5>rO#KrQdO,5>rO#K}QdO,5>qO#L`QdO,5>qOOQS1G1Y1G1YOOQS,5;p,5;pOOQV<<Jc<<JcO#LhQdO1G1dOOQS7+)T7+)TP#LmQdO'#FwO#L}QdO1G2OO#MbQdO1G2OO#MrQdO1G2OP#M}QdO'#FxO#N[QdO7+)VO#NlQdO7+)VO#NlQdO7+)VO#NtQdO7+)VO$ UQdO7+(|O8vQdO7+(|OOQSAN>VAN>VO$ oQdO<<LmOOQSAN>cAN>cO0rQdO1G1|O$!PQtO1G1|P$!ZQdO'#FvOOQS1G2R1G2RP$!hQdO'#F{O$!uQdO7+)jO$#`QdO,5>gOOOO-E9z-E9zOOOW<<MT<<MTO$#nQdO7+(fOOQSAN?[AN?[OOQS7+'t7+'tO$$XQdO<<M[OOQS,5<q,5<qO$$jQdO1G4XOOQS-E:T-E:TOOQVAN?lAN?lOOQV1G2_1G2_O4iQdOAN?qO$$xQgOAN?qOOQVAN?xAN?xO4iQdOAN?xOOQV<<JR<<JRO4iQdOAN?rO4iQdO7+'{OOQV7+'{7+'{O1XQdO7+'{OOQVAN?rAN?rOOQS7+'|7+'|O$(sQdO<<MbOOQS1G4^1G4^O0rQdO1G4^OOQS,5<w,5<wO$)QQdO1G4]OOQS-E:Z-E:ZOOQU'#G_'#G_O$)cQfO7+'OO$)nQdO'#F_O$*uQdO7+'jO$+VQdO7+'jOOQS7+'j7+'jO$+bQdO<<LqO$+rQdO<<LqO$+rQdO<<LqO$+zQdO'#H^OOQS<<Lh<<LhO$,UQdO<<LhOOQS7+'h7+'hOOQS'#D|'#D|OOOO1G4R1G4RO$,oQdO1G4RO$,wQdO1G4RP!=hQdO'#GVOOQVG25]G25]O4iQdOG25]OOQVG25dG25dOOQVG25^G25^OOQV<<Kg<<KgO4iQdO<<KgOOQS7+)x7+)xP$-SQdO'#G]OOQU-E:]-E:]OOQV<<Jj<<JjO$-vQtO'#FaOOQS'#Fc'#FcO$.WQdO'#FbO$.xQdO'#FbOOQS'#Fb'#FbO$.}QdO'#IYO$)nQdO'#FiO$)nQdO'#FiO$/fQdO'#FjO$)nQdO'#FkO$/mQdO'#IZOOQS'#IZ'#IZO$0[QdO,5;yOOQS<<KU<<KUO$0dQdO<<KUO$0tQdOANB]O$1UQdOANB]O$1^QdO'#H_OOQS'#H_'#H_O1sQdO'#DcO$1wQdO,5=xOOQSANBSANBSOOOO7+)m7+)mO$2`QdO7+)mOOQVLD*wLD*wOOQVANARANARO5uQ!fO'#GaO$2hQtO,5<SO$)nQdO'#FmOOQS,5<W,5<WOOQS'#Fd'#FdO$3YQdO,5;|O$3_QdO,5;|OOQS'#Fg'#FgO$)nQdO'#G`O$4PQdO,5<QO$4kQdO,5>tO$4{QdO,5>tO1XQdO,5<PO$5^QdO,5<TO$5cQdO,5<TO$)nQdO'#I[O$5hQdO'#I[O$5mQdO,5<UOOQS,5<V,5<VO0rQdO'#FpOOQU1G1e1G1eO4iQdO1G1eOOQSAN@pAN@pO$5rQdOG27wO$6SQdO,59}OOQS1G3d1G3dOOOO<<MX<<MXOOQS,5<{,5<{OOQS-E:_-E:_O$6XQtO'#FaO$6`QdO'#I]O$6nQdO'#I]O$6vQdO,5<XOOQS1G1h1G1hO$6{QdO1G1hO$7QQdO,5<zOOQS-E:^-E:^O$7lQdO,5=OO$8TQdO1G4`OOQS-E:b-E:bOOQS1G1k1G1kOOQS1G1o1G1oO$8eQdO,5>vO$)nQdO,5>vOOQS1G1p1G1pOOQS,5<[,5<[OOQU7+'P7+'PO$+zQdO1G/iO$)nQdO,5<YO$8sQdO,5>wO$8zQdO,5>wOOQS1G1s1G1sOOQS7+'S7+'SP$)nQdO'#GdO$9SQdO1G4bO$9^QdO1G4bO$9fQdO1G4bOOQS7+%T7+%TO$9tQdO1G1tO$:SQtO'#FaO$:ZQdO,5<}OOQS,5<},5<}O$:iQdO1G4cOOQS-E:a-E:aO$)nQdO,5<|O$:pQdO,5<|O$:uQdO7+)|OOQS-E:`-E:`O$;PQdO7+)|O$)nQdO,5<ZP$)nQdO'#GcO$;XQdO1G2hO$)nQdO1G2hP$;gQdO'#GbO$;nQdO<<MhO$;xQdO1G1uO$<WQdO7+(SO8vQdO'#C}O8vQdO,59bO8vQdO,59bO8vQdO,59bO$<fQtO,5=`O8vQdO1G.|O0rQdO1G/XO0rQdO7+$pP$<yQdO'#GOO'vQdO'#GtO$=WQdO,59bO$=]QdO,59bO$=dQdO,59mO$=iQdO1G/UO1sQdO'#DRO8vQdO,59j",
  stateData: "$>S~O%cOS%^OSSOS%]PQ~OPdOVaOfoOhYOopOs!POvqO!PrO!Q{O!T!SO!U!RO!XZO!][O!h`O!r`O!s`O!t`O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#l!QO#o!TO#s!UO#u!VO#z!WO#}hO$P!XO%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~O%]!YO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%j![O%k!]O%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aO~Ok%xXl%xXm%xXn%xXo%xXp%xXs%xXz%xX{%xX!x%xX#g%xX%[%xX%_%xX%z%xXg%xX!T%xX!U%xX%{%xX!W%xX![%xX!Q%xX#[%xXt%xX!m%xX~P%SOfoOhYO!XZO!][O!h`O!r`O!s`O!t`O%oRO%pRO%tSO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O~Oz%wX{%wX#g%wX%[%wX%_%wX%z%wX~Ok!pOl!qOm!oOn!oOo!rOp!sOs!tO!x%wX~P)pOV!zOg!|Oo0cOv0qO!PrO~P'vOV#OOo0cOv0qO!W#PO~P'vOV#SOa#TOo0cOv0qO![#UO~P'vOQ#XO%`#XO%a#ZO~OQ#^OR#[O%`#^O%a#`O~OV%iX_%iXa%iXh%iXk%iXl%iXm%iXn%iXo%iXp%iXs%iXz%iX!X%iX!f%iX%j%iX%k%iX%l%iX%m%iX%n%iX%o%iX%p%iX%q%iX%r%iX%s%iXg%iX!T%iX!U%iX~O&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O&c^O&d^O&e^O&f^O&g^O&h^O&i^O&j^O{%iX!x%iX#g%iX%[%iX%_%iX%z%iX%{%iX!W%iX![%iX!Q%iX#[%iXt%iX!m%iX~P,eOz#dO{%hX!x%hX#g%hX%[%hX%_%hX%z%hX~Oo0cOv0qO~P'vO#g#gO%[#iO%_#iO~O%uWO~O!T#nO#u!VO#z!WO#}hO~OopO~P'vOV#sOa#tO%uWO{wP~OV#xOo0cOv0qO!Q#yO~P'vO{#{O!x$QO%z#|O#g!yX%[!yX%_!yX~OV#xOo0cOv0qO#g#SX%[#SX%_#SX~P'vOo0cOv0qO#g#WX%[#WX%_#WX~P'vOh$WO%uWO~O!f$YO!r$YO%uWO~OV$eO~P'vO!U$gO#s$hO#u$iO~O{$jO~OV$qO~P'vOS$sO%[$rO%_$rO%c$tO~OV$}Oa$}Og%POo0cOv0qO~P'vOo0cOv0qO{%SO~P'vO&Y%UO~Oa!bOh!iO!X!kO!f!mOVba_bakbalbambanbaobapbasbazba{ba!xba#gba%[ba%_ba%jba%kba%lba%mba%nba%oba%pba%qba%rba%sba%zbagba!Tba!Uba%{ba!Wba![ba!Qba#[batba!mba~On%ZO~Oo%ZO~P'vOo0cO~P'vOk0eOl0fOm0dOn0dOo0mOp0nOs0rOg%wX!T%wX!U%wX%{%wX!W%wX![%wX!Q%wX#[%wX!m%wX~P)pO%{%]Og%vXz%vX!T%vX!U%vX!W%vX{%vX~Og%_Oz%`O!T%dO!U%cO~Og%_O~Oz%gO!T%dO!U%cO!W&SX~O!W%kO~Oz%lO{%nO!T%dO!U%cO![%}X~O![%rO~O![%sO~OQ#XO%`#XO%a%uO~OV%wOo0cOv0qO!PrO~P'vOQ#^OR#[O%`#^O%a%zO~OV!qa_!qaa!qah!qak!qal!qam!qan!qao!qap!qas!qaz!qa{!qa!X!qa!f!qa!x!qa#g!qa%[!qa%_!qa%j!qa%k!qa%l!qa%m!qa%n!qa%o!qa%p!qa%q!qa%r!qa%s!qa%z!qag!qa!T!qa!U!qa%{!qa!W!qa![!qa!Q!qa#[!qat!qa!m!qa~P#yOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P%SOV&OOopOvqO{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~P'vOz%|O{%ha!x%ha#g%ha%[%ha%_%ha%z%ha~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO#g$zX%[$zX%_$zX~P'vO#g#gO%[&TO%_&TO~O!f&UOh&sX%[&sXz&sX#[&sX#g&sX%_&sX#Z&sXg&sX~Oh!iO%[&WO~Okealeameaneaoeapeaseazea{ea!xea#gea%[ea%_ea%zeagea!Tea!Uea%{ea!Wea![ea!Qea#[eatea!mea~P%SOsqazqa{qa#gqa%[qa%_qa%zqa~Ok!pOl!qOm!oOn!oOo!rOp!sO!xqa~PEcO%z&YOz%yX{%yX~O%uWOz%yX{%yX~Oz&]O{wX~O{&_O~Oz%lO#g%}X%[%}X%_%}Xg%}X{%}X![%}X!m%}X%z%}X~OV0lOo0cOv0qO!PrO~P'vO%z#|O#gUa%[Ua%_Ua~Oz&hO#g&PX%[&PX%_&PXn&PX~P%SOz&kO!Q&jO#g#Wa%[#Wa%_#Wa~Oz&lO#[&nO#g&rX%[&rX%_&rXg&rX~O!f$YO!r$YO#Z&qO%uWO~O#Z&qO~Oz&sO#g&tX%[&tX%_&tX~Oz&uO#g&pX%[&pX%_&pX{&pX~O!X&wO%z&xO~Oz&|On&wX~P%SOn'PO~OPdOVaOopOvqO!PrO!Q{O!{tO!}uO#PvO#RwO#TxO#XyO#ZzO#^|O#_|O#a}O#c!OO%['UO~P'vOt'YO#p'WO#q'XOP#naV#naf#nah#nao#nas#nav#na!P#na!Q#na!T#na!U#na!X#na!]#na!h#na!r#na!s#na!t#na!{#na!}#na#P#na#R#na#T#na#X#na#Z#na#^#na#_#na#a#na#c#na#l#na#o#na#s#na#u#na#z#na#}#na$P#na%X#na%o#na%p#na%t#na%u#na&Z#na&[#na&]#na&^#na&_#na&`#na&a#na&b#na&c#na&d#na&e#na&f#na&g#na&h#na&i#na&j#na%Z#na%_#na~Oz'ZO#[']O{&xX~Oh'_O!X&wO~Oh!iO{$jO!X&wO~O{'eO~P%SO%['hO%_'hO~OS'iO%['hO%_'hO~OV!aO_!aOa!bOh!iO!X!kO!f!mO%l!^O%m!_O%n!_O%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%k!]O~P!#uO%kWi~P!#uOV!aO_!aOa!bOh!iO!X!kO!f!mO%o!`O%p!`O%q!aO%r!aO%s!aOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~O%m!_O%n!_O~P!&pO%mWi%nWi~P!&pOa!bOh!iO!X!kO!f!mOkWilWimWinWioWipWisWizWi{Wi!xWi#gWi%[Wi%_Wi%jWi%kWi%lWi%mWi%nWi%oWi%pWi%zWigWi!TWi!UWi%{Wi!WWi![Wi!QWi#[WitWi!mWi~OV!aO_!aO%q!aO%r!aO%s!aO~P!)nOVWi_Wi%qWi%rWi%sWi~P!)nO!T%dO!U%cOg&VXz&VX~O%z'kO%{'kO~P,eOz'mOg&UX~Og'oO~Oz'pO{'rO!W&XX~Oo0cOv0qOz'pO{'sO!W&XX~P'vO!W'uO~Om!oOn!oOo!rOp!sOkjisjizji{ji!xji#gji%[ji%_ji%zji~Ol!qO~P!.aOlji~P!.aOk0eOl0fOm0dOn0dOo0mOp0nO~Ot'wO~P!/jOV'|Og'}Oo0cOv0qO~P'vOg'}Oz(OO~Og(QO~O!U(SO~Og(TOz(OO!T%dO!U%cO~P%SOk0eOl0fOm0dOn0dOo0mOp0nOgqa!Tqa!Uqa%{qa!Wqa![qa!Qqa#[qatqa!mqa~PEcOV'|Oo0cOv0qO!W&Sa~P'vOz(WO!W&Sa~O!W(XO~Oz(WO!T%dO!U%cO!W&Sa~P%SOV(]Oo0cOv0qO![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~P'vOz(^O![%}a#g%}a%[%}a%_%}ag%}a{%}a!m%}a%z%}a~O![(aO~Oz(^O!T%dO!U%cO![%}a~P%SOz(dO!T%dO!U%cO![&Ta~P%SOz(gO{&lX![&lX!m&lX%z&lX~O{(kO![(mO!m(nO%z(jO~OV&OOopOvqO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~P'vOz(pO{%hi!x%hi#g%hi%[%hi%_%hi%z%hi~O!f&UOh&sa%[&saz&sa#[&sa#g&sa%_&sa#Z&sag&sa~O%[(uO~OV#sOa#tO%uWO~Oz&]O{wa~OopOvqO~P'vOz(^O#g%}a%[%}a%_%}ag%}a{%}a![%}a!m%}a%z%}a~P%SOz(zO#g%hX%[%hX%_%hX%z%hX~O%z#|O#gUi%[Ui%_Ui~O#g&Pa%[&Pa%_&Pan&Pa~P'vOz(}O#g&Pa%[&Pa%_&Pan&Pa~O%uWO#g&ra%[&ra%_&rag&ra~Oz)SO#g&ra%[&ra%_&rag&ra~Og)VO~OV)WOh$WO%uWO~O#Z)XO~O%uWO#g&ta%[&ta%_&ta~Oz)ZO#g&ta%[&ta%_&ta~Oo0cOv0qO#g&pa%[&pa%_&pa{&pa~P'vOz)^O#g&pa%[&pa%_&pa{&pa~OV)`Oa)`O%uWO~O%z)eO~Ot)hO#j)gOP#hiV#hif#hih#hio#his#hiv#hi!P#hi!Q#hi!T#hi!U#hi!X#hi!]#hi!h#hi!r#hi!s#hi!t#hi!{#hi!}#hi#P#hi#R#hi#T#hi#X#hi#Z#hi#^#hi#_#hi#a#hi#c#hi#l#hi#o#hi#s#hi#u#hi#z#hi#}#hi$P#hi%X#hi%o#hi%p#hi%t#hi%u#hi&Z#hi&[#hi&]#hi&^#hi&_#hi&`#hi&a#hi&b#hi&c#hi&d#hi&e#hi&f#hi&g#hi&h#hi&i#hi&j#hi%Z#hi%_#hi~Ot)iOP#kiV#kif#kih#kio#kis#kiv#ki!P#ki!Q#ki!T#ki!U#ki!X#ki!]#ki!h#ki!r#ki!s#ki!t#ki!{#ki!}#ki#P#ki#R#ki#T#ki#X#ki#Z#ki#^#ki#_#ki#a#ki#c#ki#l#ki#o#ki#s#ki#u#ki#z#ki#}#ki$P#ki%X#ki%o#ki%p#ki%t#ki%u#ki&Z#ki&[#ki&]#ki&^#ki&_#ki&`#ki&a#ki&b#ki&c#ki&d#ki&e#ki&f#ki&g#ki&h#ki&i#ki&j#ki%Z#ki%_#ki~OV)kOn&wa~P'vOz)lOn&wa~Oz)lOn&wa~P%SOn)pO~O%Y)tO~Ot)wO#p'WO#q)vOP#niV#nif#nih#nio#nis#niv#ni!P#ni!Q#ni!T#ni!U#ni!X#ni!]#ni!h#ni!r#ni!s#ni!t#ni!{#ni!}#ni#P#ni#R#ni#T#ni#X#ni#Z#ni#^#ni#_#ni#a#ni#c#ni#l#ni#o#ni#s#ni#u#ni#z#ni#}#ni$P#ni%X#ni%o#ni%p#ni%t#ni%u#ni&Z#ni&[#ni&]#ni&^#ni&_#ni&`#ni&a#ni&b#ni&c#ni&d#ni&e#ni&f#ni&g#ni&h#ni&i#ni&j#ni%Z#ni%_#ni~OV)zOo0cOv0qO{$jO~P'vOo0cOv0qO{&xa~P'vOz*OO{&xa~OV*SOa*TOg*WO%q*UO%uWO~O{$jO&{*YO~Oh'_O~Oh!iO{$jO~O%[*_O~O%[*aO%_*aO~OV$}Oa$}Oo0cOv0qOg&Ua~P'vOz*dOg&Ua~Oo0cOv0qO{*gO!W&Xa~P'vOz*hO!W&Xa~Oo0cOv0qOz*hO{*kO!W&Xa~P'vOo0cOv0qOz*hO!W&Xa~P'vOz*hO{*kO!W&Xa~Om0dOn0dOo0mOp0nOgjikjisjizji!Tji!Uji%{ji!Wji{ji![ji#gji%[ji%_ji!Qji#[jitji!mji%zji~Ol0fO~P!NkOlji~P!NkOV'|Og*pOo0cOv0qO~P'vOn*rO~Og*pOz*tO~Og*uO~OV'|Oo0cOv0qO!W&Si~P'vOz*vO!W&Si~O!W*wO~OV(]Oo0cOv0qO![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~P'vOz*zO!T%dO!U%cO![&Ti~Oz*}O![%}i#g%}i%[%}i%_%}ig%}i{%}i!m%}i%z%}i~O![+OO~Oa+QOo0cOv0qO![&Ti~P'vOz*zO![&Ti~O![+SO~OV+UOo0cOv0qO{&la![&la!m&la%z&la~P'vOz+VO{&la![&la!m&la%z&la~O!]+YO&n+[O![!nX~O![+^O~O{(kO![+_O~O{(kO![+_O!m+`O~OV&OOopOvqO{%hq!x%hq#g%hq%[%hq%_%hq%z%hq~P'vOz$ri{$ri!x$ri#g$ri%[$ri%_$ri%z$ri~P%SOV&OOopOvqO~P'vOV&OOo0cOv0qO#g%ha%[%ha%_%ha%z%ha~P'vOz+aO#g%ha%[%ha%_%ha%z%ha~Oz$ia#g$ia%[$ia%_$ian$ia~P%SO#g&Pi%[&Pi%_&Pin&Pi~P'vOz+dO#g#Wq%[#Wq%_#Wq~O#[+eOz$va#g$va%[$va%_$vag$va~O%uWO#g&ri%[&ri%_&rig&ri~Oz+gO#g&ri%[&ri%_&rig&ri~OV+iOh$WO%uWO~O%uWO#g&ti%[&ti%_&ti~Oo0cOv0qO#g&pi%[&pi%_&pi{&pi~P'vO{#{Oz#eX!W#eX~Oz+mO!W&uX~O!W+oO~Ot+rO#j)gOP#hqV#hqf#hqh#hqo#hqs#hqv#hq!P#hq!Q#hq!T#hq!U#hq!X#hq!]#hq!h#hq!r#hq!s#hq!t#hq!{#hq!}#hq#P#hq#R#hq#T#hq#X#hq#Z#hq#^#hq#_#hq#a#hq#c#hq#l#hq#o#hq#s#hq#u#hq#z#hq#}#hq$P#hq%X#hq%o#hq%p#hq%t#hq%u#hq&Z#hq&[#hq&]#hq&^#hq&_#hq&`#hq&a#hq&b#hq&c#hq&d#hq&e#hq&f#hq&g#hq&h#hq&i#hq&j#hq%Z#hq%_#hq~On$|az$|a~P%SOV)kOn&wi~P'vOz+yOn&wi~Oz,TO{$jO#[,TO~O#q,VOP#nqV#nqf#nqh#nqo#nqs#nqv#nq!P#nq!Q#nq!T#nq!U#nq!X#nq!]#nq!h#nq!r#nq!s#nq!t#nq!{#nq!}#nq#P#nq#R#nq#T#nq#X#nq#Z#nq#^#nq#_#nq#a#nq#c#nq#l#nq#o#nq#s#nq#u#nq#z#nq#}#nq$P#nq%X#nq%o#nq%p#nq%t#nq%u#nq&Z#nq&[#nq&]#nq&^#nq&_#nq&`#nq&a#nq&b#nq&c#nq&d#nq&e#nq&f#nq&g#nq&h#nq&i#nq&j#nq%Z#nq%_#nq~O#[,WOz%Oa{%Oa~Oo0cOv0qO{&xi~P'vOz,YO{&xi~O{#{O%z,[Og&zXz&zX~O%uWOg&zXz&zX~Oz,`Og&yX~Og,bO~O%Y,eO~O!T%dO!U%cOg&Viz&Vi~OV$}Oa$}Oo0cOv0qOg&Ui~P'vO{,hOz$la!W$la~Oo0cOv0qO{,iOz$la!W$la~P'vOo0cOv0qO{*gO!W&Xi~P'vOz,lO!W&Xi~Oo0cOv0qOz,lO!W&Xi~P'vOz,lO{,oO!W&Xi~Og$hiz$hi!W$hi~P%SOV'|Oo0cOv0qO~P'vOn,qO~OV'|Og,rOo0cOv0qO~P'vOV'|Oo0cOv0qO!W&Sq~P'vOz$gi![$gi#g$gi%[$gi%_$gig$gi{$gi!m$gi%z$gi~P%SOV(]Oo0cOv0qO~P'vOa+QOo0cOv0qO![&Tq~P'vOz,sO![&Tq~O![,tO~OV(]Oo0cOv0qO![%}q#g%}q%[%}q%_%}qg%}q{%}q!m%}q%z%}q~P'vO{,uO~OV+UOo0cOv0qO{&li![&li!m&li%z&li~P'vOz,zO{&li![&li!m&li%z&li~O!]+YO&n+[O![!na~O{(kO![,}O~OV&OOo0cOv0qO#g%hi%[%hi%_%hi%z%hi~P'vOz-OO#g%hi%[%hi%_%hi%z%hi~O%uWO#g&rq%[&rq%_&rqg&rq~Oz-RO#g&rq%[&rq%_&rqg&rq~OV)`Oa)`O%uWO!W&ua~Oz-TO!W&ua~On$|iz$|i~P%SOV)kO~P'vOV)kOn&wq~P'vOt-XOP#myV#myf#myh#myo#mys#myv#my!P#my!Q#my!T#my!U#my!X#my!]#my!h#my!r#my!s#my!t#my!{#my!}#my#P#my#R#my#T#my#X#my#Z#my#^#my#_#my#a#my#c#my#l#my#o#my#s#my#u#my#z#my#}#my$P#my%X#my%o#my%p#my%t#my%u#my&Z#my&[#my&]#my&^#my&_#my&`#my&a#my&b#my&c#my&d#my&e#my&f#my&g#my&h#my&i#my&j#my%Z#my%_#my~O%Z-]O%_-]O~P`O#q-^OP#nyV#nyf#nyh#nyo#nys#nyv#ny!P#ny!Q#ny!T#ny!U#ny!X#ny!]#ny!h#ny!r#ny!s#ny!t#ny!{#ny!}#ny#P#ny#R#ny#T#ny#X#ny#Z#ny#^#ny#_#ny#a#ny#c#ny#l#ny#o#ny#s#ny#u#ny#z#ny#}#ny$P#ny%X#ny%o#ny%p#ny%t#ny%u#ny&Z#ny&[#ny&]#ny&^#ny&_#ny&`#ny&a#ny&b#ny&c#ny&d#ny&e#ny&f#ny&g#ny&h#ny&i#ny&j#ny%Z#ny%_#ny~Oz-aO{$jO#[-aO~Oo0cOv0qO{&xq~P'vOz-dO{&xq~O%z,[Og&zaz&za~O{#{Og&zaz&za~OV*SOa*TO%q*UO%uWOg&ya~Oz-hOg&ya~O$S-lO~OV$}Oa$}Oo0cOv0qO~P'vOo0cOv0qO{-mOz$li!W$li~P'vOo0cOv0qOz$li!W$li~P'vO{-mOz$li!W$li~Oo0cOv0qO{*gO~P'vOo0cOv0qO{*gO!W&Xq~P'vOz-pO!W&Xq~Oo0cOv0qOz-pO!W&Xq~P'vOs-sO!T%dO!U%cOg&Oq!W&Oq![&Oqz&Oq~P!/jOa+QOo0cOv0qO![&Ty~P'vOz$ji![$ji~P%SOa+QOo0cOv0qO~P'vOV+UOo0cOv0qO~P'vOV+UOo0cOv0qO{&lq![&lq!m&lq%z&lq~P'vO{(kO![-xO!m-yO%z-wO~OV&OOo0cOv0qO#g%hq%[%hq%_%hq%z%hq~P'vO%uWO#g&ry%[&ry%_&ryg&ry~OV)`Oa)`O%uWO!W&ui~Ot-}OP#m!RV#m!Rf#m!Rh#m!Ro#m!Rs#m!Rv#m!R!P#m!R!Q#m!R!T#m!R!U#m!R!X#m!R!]#m!R!h#m!R!r#m!R!s#m!R!t#m!R!{#m!R!}#m!R#P#m!R#R#m!R#T#m!R#X#m!R#Z#m!R#^#m!R#_#m!R#a#m!R#c#m!R#l#m!R#o#m!R#s#m!R#u#m!R#z#m!R#}#m!R$P#m!R%X#m!R%o#m!R%p#m!R%t#m!R%u#m!R&Z#m!R&[#m!R&]#m!R&^#m!R&_#m!R&`#m!R&a#m!R&b#m!R&c#m!R&d#m!R&e#m!R&f#m!R&g#m!R&h#m!R&i#m!R&j#m!R%Z#m!R%_#m!R~Oo0cOv0qO{&xy~P'vOV*SOa*TO%q*UO%uWOg&yi~O$S-lO%Z.VO%_.VO~OV.aOh._O!X.^O!].`O!h.YO!s.[O!t.[O%p.XO%uWO&Z]O&[]O&]]O&^]O&_]O&`]O&a]O&b]O~Oo0cOv0qOz$lq!W$lq~P'vO{.fOz$lq!W$lq~Oo0cOv0qO{*gO!W&Xy~P'vOz.gO!W&Xy~Oo0cOv.kO~P'vOs-sO!T%dO!U%cOg&Oy!W&Oy![&Oyz&Oy~P!/jO{(kO![.nO~O{(kO![.nO!m.oO~OV*SOa*TO%q*UO%uWO~Oh.tO!f.rOz$TX#[$TX%j$TXg$TX~Os$TX{$TX!W$TX![$TX~P$-bO%o.vO%p.vOs$UXz$UX{$UX#[$UX%j$UX!W$UXg$UX![$UX~O!h.xO~Oz.|O#[/OO%j.yOs&|X{&|X!W&|Xg&|X~Oa/RO~P$)zOh.tOs&}Xz&}X{&}X#[&}X%j&}X!W&}Xg&}X![&}X~Os/VO{$jO~Oo0cOv0qOz$ly!W$ly~P'vOo0cOv0qO{*gO!W&X!R~P'vOz/ZO!W&X!R~Og&RXs&RX!T&RX!U&RX!W&RX![&RXz&RX~P!/jOs-sO!T%dO!U%cOg&Qa!W&Qa![&Qaz&Qa~O{(kO![/^O~O!f.rOh$[as$[az$[a{$[a#[$[a%j$[a!W$[ag$[a![$[a~O!h/eO~O%o.vO%p.vOs$Uaz$Ua{$Ua#[$Ua%j$Ua!W$Uag$Ua![$Ua~O%j.yOs$Yaz$Ya{$Ya#[$Ya!W$Yag$Ya![$Ya~Os&|a{&|a!W&|ag&|a~P$)nOz/jOs&|a{&|a!W&|ag&|a~O!W/mO~Og/mO~O{/oO~O![/pO~Oo0cOv0qO{*gO!W&X!Z~P'vO{/sO~O%z/tO~P$-bOz/uO#[/OO%j.yOg'PX~Oz/uOg'PX~Og/wO~O!h/xO~O#[/OOs%Saz%Sa{%Sa%j%Sa!W%Sag%Sa![%Sa~O#[/OO%j.yOs%Waz%Wa{%Wa!W%Wag%Wa~Os&|i{&|i!W&|ig&|i~P$)nOz/zO#[/OO%j.yO!['Oa~Og'Pa~P$)nOz0SOg'Pa~Oa0UO!['Oi~P$)zOz0WO!['Oi~Oz0WO#[/OO%j.yO!['Oi~O#[/OO%j.yOg$biz$bi~O%z0ZO~P$-bO#[/OO%j.yOg%Vaz%Va~Og'Pi~P$)nO{0^O~Oa0UO!['Oq~P$)zOz0`O!['Oq~O#[/OO%j.yOz%Ui![%Ui~Oa0UO~P$)zOa0UO!['Oy~P$)zO#[/OO%j.yOg$ciz$ci~O#[/OO%j.yOz%Uq![%Uq~Oz+aO#g%ha%[%ha%_%ha%z%ha~P%SOV&OOo0cOv0qO~P'vOn0hO~Oo0hO~P'vO{0iO~Ot0jO~P!/jO&]&Z&j&h&i&g&f&d&e&c&b&`&a&_&^&[%u~",
  goto: "!=j'QPPPPPP'RP'Z*s+[+t,_,y-fP.SP'Z.r.r'ZPPP'Z2[PPPPPP2[5PPP5PP7b7k=sPP=v>h>kPP'Z'ZPP>zPP'Z'ZPP'Z'Z'Z'Z'Z?O?w'ZP?zP@QDXGuGyPG|HWH['ZPPPH_Hk'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RP'RPHqH}IVPI^IdPI^PI^I^PPPI^PKrPK{LVL]KrPI^LfPI^PLmLsPLwM]MzNeLwLwNkNxLwLwLwLw! ^! d! g! l! o! y!!P!!]!!o!!u!#P!#V!#s!#y!$P!$Z!$a!$g!$y!%T!%Z!%a!%k!%q!%w!%}!&T!&Z!&e!&k!&u!&{!'U!'[!'k!'s!'}!(UPPPPPPPPPPP!([!(_!(e!(n!(x!)TPPPPPPPPPPPP!-u!/Z!3^!6oPP!6w!7W!7a!8Y!8P!8c!8i!8l!8o!8r!8z!9jPPPPPPPPPPPPPPPPP!9m!9q!9wP!:]!:a!:m!:v!;S!;j!;m!;p!;v!;|!<S!<VP!<_!<h!=d!=g]eOn#g$j)t,P'}`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r{!cQ#c#p$R$d$p%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g}!dQ#c#p$R$d$p$u%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!P!eQ#c#p$R$d$p$u$v%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!R!fQ#c#p$R$d$p$u$v$w%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!T!gQ#c#p$R$d$p$u$v$w$x%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!V!hQ#c#p$R$d$p$u$v$w$x$y%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g!Z!hQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0g'}TOTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0r&eVOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0r%oXOYZ[dnrxy}!P!Q!U!i!k#[#d#g#y#{#}$Q$h$j$}%S%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#vqQ/[.kR0o0q't`OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rh#jhz{$W$Z&l&q)S)X+f+g-RW#rq&].k0qQ$]|Q$a!OQ$n!VQ$o!WW$|!i'm*d,gS&[#s#tQ'S$iQ(s&UQ)U&nU)Y&s)Z+jW)a&w+m-T-{Q*Q']W*R'_,`-h.TQ+l)`S,_*S*TQ-Q+eQ-_,TQ-c,WQ.R-al.W-l.^._.a.z.|/R/j/o/t/y0U0Z0^Q/S.`Q/a.tQ/l/OU0P/u0S0[X0V/z0W0_0`R&Z#r!_!wYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZR%^!vQ!{YQ%x#[Q&d#}Q&g$QR,{+YT.j-s/s!Y!jQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gQ&X#kQ'c$oR*^'dR'l$|Q%V!mR/_.r'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rS#a_#b!P.[-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`'|_OTYZ[adnoprtxy}!P!Q!R!U!X!c!d!e!f!g!h!i!k!o!p!q!s!t!z#O#S#T#[#d#g#x#y#{#}$Q$e$g$h$j$q$}%S%Z%^%`%c%g%l%n%w%|&O&Z&_&h&j&k&u&x&|'P'W'Z'l'm'p'r's'w'|(O(S(W(](^(d(g(p(r(z(})^)e)g)k)l)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+Q+U+V+Y+a+c+d+k+x+y,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0l0n0rT#a_#bT#^^#_R(o%xa(l%x(n(o+`,{-y-z.oT+[(k+]R-z,{Q$PsQ+l)aQ,^*RR-e,_X#}s$O$P&fQ&y$aQ'a$nQ'd$oR)s'SQ)b&wV-S+m-T-{ZgOn$j)t,PXkOn)t,PQ$k!TQ&z$bQ&{$cQ'^$mQ'b$oQ)q'RQ)x'WQ){'XQ)|'YQ*Z'`S*]'c'dQ+s)gQ+u)hQ+v)iQ+z)oS+|)r*[Q,Q)vQ,R)wS,S)y)zQ,d*^Q-V+rQ-W+tQ-Y+{S-Z+},OQ-`,UQ-b,VQ-|-XQ.O-[Q.P-^Q.Q-_Q.p-}Q.q.RQ/W.dR/r/XWkOn)t,PR#mjQ'`$nS)r'S'aR,O)sQ,]*RR-f,^Q*['`Q+})rR-[,OZiOjn)t,PQ'f$pR*`'gT-j,e-ku.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^t.c-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^Q/S.`X0V/z0W0_0`!P.Z-l.^._.`.a.t.z.|/R/j/o/t/u/y/z0S0U0W0Z0[0^0_0`Q.w.YR/f.xg.z.].{/b/i/n/|0O0Q0]0a0bu.b-l.^._.a.t.z.|/R/j/o/t/u/y0S0U0Z0[0^X.u.W.b/a0PR/c.tV0R/u0S0[R/X.dQnOS#on,PR,P)tQ&^#uR(x&^S%m#R#wS(_%m(bT(b%p&`Q%a!yQ%h!}W(P%a%h(U(YQ(U%eR(Y%jQ&i$RR)O&iQ(e%qQ*{(`T+R(e*{Q'n%OR*e'nS'q%R%SY*i'q*j,m-q.hU*j'r's'tU,m*k*l*mS-q,n,oR.h-rQ#Y]R%t#YQ#_^R%y#_Q(h%vS+W(h+XR+X(iQ+](kR,|+]Q#b_R%{#bQ#ebQ%}#cW&Q#e%}({+bQ({&cR+b0gQ$OsS&e$O&fR&f$PQ&v$_R)_&vQ&V#jR(t&VQ&m$VS)T&m+hR+h)UQ$Z{R&p$ZQ&t$]R)[&tQ+n)bR-U+nQ#hfR&S#hQ)f&zR+q)fQ&}$dS)m&})nR)n'OQ'V$kR)u'VQ'[$lS*P'[,ZR,Z*QQ,a*VR-i,aWjOn)t,PR#ljQ-k,eR.U-kd.{.]/b/i/n/|0O0Q0]0a0bR/h.{U.s.W/a0PR/`.sQ/{/nS0X/{0YR0Y/|S/v/b/cR0T/vQ.}.]R/k.}R!ZPXmOn)t,PWlOn)t,PR'T$jYfOn$j)t,PR&R#g[sOn#g$j)t,PR&d#}&dQOYZ[dnprxy}!P!Q!U!i!k!o!p!q!s!t#[#d#g#y#{#}$Q$h$j$}%S%Z%^%`%g%l%n%w%|&Z&_&j&k&u&x'P'W'Z'l'm'p'r's'w(O(W(^(d(g(p(r(z)^)e)g)p)t)z*O*Y*d*g*h*k*q*r*t*v*y*z*}+U+V+Y+a+d+k,P,X,Y,],g,h,i,k,l,o,q,s,u,w,y,z-O-d-f-m-p-s.f.g/V/Z/s0c0d0e0f0h0i0j0k0n0rQ!nTQ#caQ#poU$Rt%c(SS$d!R$gQ$p!XQ$u!cQ$v!dQ$w!eQ$x!fQ$y!gQ$z!hQ%e!zQ%j#OQ%p#SQ%q#TQ&`#xQ'O$eQ'g$qQ(q&OU(|&h(}+cW)j&|)l+x+yQ*o'|Q*x(]Q+w)kQ,v+QR0g0lQ!yYQ!}ZQ$b!PQ$c!QQ%R!kQ't%S^'{%`%g(O(W*q*t*v^*f'p*h,k,l-p.g/ZQ*l'rQ*m'sQ+t)gQ,j*gQ,n*kQ-n,hQ-o,iQ-r,oQ.e-mR/Y.f[bOn#g$j)t,P!^!vYZ!P!Q!k%S%`%g'p'r's(O(W)g*g*h*k*q*t*v,h,i,k,l,o-m-p.f.g/ZQ#R[Q#fdS#wrxQ$UyW$_}$Q'P)pS$l!U$hW${!i'm*d,gS%v#[+Y`&P#d%|(p(r(z+a-O0kQ&a#yQ&b#{Q&c#}Q'j$}Q'z%^W([%l(^*y*}Q(`%nQ(i%wQ(v&ZS(y&_0iQ)P&jQ)Q&kU)]&u)^+kQ)d&xQ)y'WY)}'Z*O,X,Y-dQ*b'lS*n'w0jW+P(d*z,s,wW+T(g+V,y,zQ+p)eQ,U)zQ,c*YQ,x+UQ-P+dQ-e,]Q-v,uQ.S-fR/q/VhUOn#d#g$j%|&_'w(p(r)t,P%U!uYZ[drxy}!P!Q!U!i!k#[#y#{#}$Q$h$}%S%^%`%g%l%n%w&Z&j&k&u&x'P'W'Z'l'm'p'r's(O(W(^(d(g(z)^)e)g)p)z*O*Y*d*g*h*k*q*t*v*y*z*}+U+V+Y+a+d+k,X,Y,],g,h,i,k,l,o,s,u,w,y,z-O-d-f-m-p.f.g/V/Z0i0j0kQ#qpW%W!o!s0d0nQ%X!pQ%Y!qQ%[!tQ%f0cS'v%Z0hQ'x0eQ'y0fQ,p*rQ-u,qS.i-s/sR0p0rU#uq.k0qR(w&][cOn#g$j)t,PZ!xY#[#}$Q+YQ#W[Q#zrR$TxQ%b!yQ%i!}Q%o#RQ'j${Q(V%eQ(Z%jQ(c%pQ(f%qQ*|(`Q,f*bQ-t,pQ.m-uR/].lQ$StQ(R%cR*s(SQ.l-sR/}/sR#QZR#V[R%Q!iQ%O!iV*c'm*d,g!Z!lQ!n#c#p$R$d$p$u$v$w$x$y$z%e%j%p%q&`'O'g(q(|)j*o*x+w,v0gR%T!kT#]^#_Q%x#[R,{+YQ(m%xS+_(n(oQ,}+`Q-x,{S.n-y-zR/^.oT+Z(k+]Q$`}Q&g$QQ)o'PR+{)pQ$XzQ)W&qR+i)XQ$XzQ&o$WQ)W&qR+i)XQ#khW$Vz$W&q)XQ$[{Q&r$ZZ)R&l)S+f+g-RR$^|R)c&wXlOn)t,PQ$f!RR'Q$gQ$m!UR'R$hR*X'_Q*V'_V-g,`-h.TQ.d-lQ/P.^R/Q._U.]-l.^._Q/U.aQ/b.tQ/g.zU/i.|/j/yQ/n/RQ/|/oQ0O/tU0Q/u0S0[Q0]0UQ0a0ZR0b0^R/T.`R/d.t",
  nodeNames: "\u26A0 print Escape { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatSelfDoc FormatConversion FormatSpec FormatReplacement FormatSelfDoc ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert TypeDefinition type TypeParamList TypeParam StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: trackIndent,
  nodeProps: [
    ["isolate", -5, 4, 71, 72, 73, 77, ""],
    ["group", -15, 6, 85, 87, 88, 90, 92, 94, 96, 98, 99, 100, 102, 105, 108, 110, "Statement Statement", -22, 8, 18, 21, 25, 40, 49, 50, 56, 57, 60, 61, 62, 63, 64, 67, 70, 71, 72, 79, 80, 81, 82, "Expression", -10, 114, 116, 119, 121, 122, 126, 128, 133, 135, 138, "Statement", -9, 143, 144, 147, 148, 150, 151, 152, 153, 154, "Pattern"],
    ["openedBy", 23, "(", 54, "[", 58, "{"],
    ["closedBy", 24, ")", 55, "]", 59, "}"]
  ],
  propSources: [pythonHighlighting],
  skippedNodes: [0, 4],
  repeatNodeCount: 34,
  tokenData: "!2|~R!`OX%TXY%oY[%T[]%o]p%Tpq%oqr'ars)Yst*xtu%Tuv,dvw-hwx.Uxy/tyz0[z{0r{|2S|}2p}!O3W!O!P4_!P!Q:Z!Q!R;k!R![>_![!]Do!]!^Es!^!_FZ!_!`Gk!`!aHX!a!b%T!b!cIf!c!dJU!d!eK^!e!hJU!h!i!#f!i!tJU!t!u!,|!u!wJU!w!x!.t!x!}JU!}#O!0S#O#P&o#P#Q!0j#Q#R!1Q#R#SJU#S#T%T#T#UJU#U#VK^#V#YJU#Y#Z!#f#Z#fJU#f#g!,|#g#iJU#i#j!.t#j#oJU#o#p!1n#p#q!1s#q#r!2a#r#s!2f#s$g%T$g;'SJU;'S;=`KW<%lOJU`%YT&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T`%lP;=`<%l%To%v]&n`%c_OX%TXY%oY[%T[]%o]p%Tpq%oq#O%T#O#P&o#P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To&tX&n`OY%TYZ%oZ]%T]^%o^#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc'f[&n`O!_%T!_!`([!`#T%T#T#U(r#U#f%T#f#g(r#g#h(r#h#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(cTmR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc(yT!mR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk)aV&n`&[ZOr%Trs)vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk){V&n`Or%Trs*bs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk*iT&n`&^ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To+PZS_&n`OY*xYZ%TZ]*x]^%T^#o*x#o#p+r#p#q*x#q#r+r#r;'S*x;'S;=`,^<%lO*x_+wTS_OY+rZ]+r^;'S+r;'S;=`,W<%lO+r_,ZP;=`<%l+ro,aP;=`<%l*xj,kV%rQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-XT!xY&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj-oV%lQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.]V&n`&ZZOw%Twx.rx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk.wV&n`Ow%Twx/^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/eT&n`&]ZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk/{ThZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc0cTgR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk0yXVZ&n`Oz%Tz{1f{!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk1mVaR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk2ZV%oZ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc2wTzR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To3_W%pZ&n`O!_%T!_!`-Q!`!a3w!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Td4OT&{S&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk4fX!fQ&n`O!O%T!O!P5R!P!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5WV&n`O!O%T!O!P5m!P#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk5tT!rZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti6[a!hX&n`O!Q%T!Q![6T![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S6T#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti7fZ&n`O{%T{|8X|}%T}!O8X!O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8^V&n`O!Q%T!Q![8s![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti8z]!hX&n`O!Q%T!Q![8s![!l%T!l!m9s!m#R%T#R#S8s#S#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti9zT!hX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk:bX%qR&n`O!P%T!P!Q:}!Q!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj;UV%sQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti;ro!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!d%T!d!e?q!e!g%T!g!h7a!h!l%T!l!m9s!m!q%T!q!rA]!r!z%T!z!{Bq!{#R%T#R#S>_#S#U%T#U#V?q#V#X%T#X#Y7a#Y#^%T#^#_9s#_#c%T#c#dA]#d#l%T#l#mBq#m#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti=xV&n`O!Q%T!Q![6T![#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti>fc!hX&n`O!O%T!O!P=s!P!Q%T!Q![>_![!g%T!g!h7a!h!l%T!l!m9s!m#R%T#R#S>_#S#X%T#X#Y7a#Y#^%T#^#_9s#_#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti?vY&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Ti@mY!hX&n`O!Q%T!Q!R@f!R!S@f!S#R%T#R#S@f#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiAbX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBUX!hX&n`O!Q%T!Q!YA}!Y#R%T#R#SA}#S#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiBv]&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TiCv]!hX&n`O!Q%T!Q![Co![!c%T!c!iCo!i#R%T#R#SCo#S#T%T#T#ZCo#Z#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToDvV{_&n`O!_%T!_!`E]!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TcEdT%{R&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkEzT#gZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkFbXmR&n`O!^%T!^!_F}!_!`([!`!a([!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjGUV%mQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkGrV%zZ&n`O!_%T!_!`([!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkH`WmR&n`O!_%T!_!`([!`!aHx!a#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TjIPV%nQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkIoV_Q#}P&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%ToJ_]&n`&YS%uZO!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoKZP;=`<%lJUoKge&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!tJU!t!uLx!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#gLx#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUoMRa&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUkN_V&n`&`ZOr%TrsNts#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%TkNyV&n`Or%Trs! `s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! gT&n`&bZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk! }V&n`&_ZOw%Twx!!dx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!!iV&n`Ow%Twx!#Ox#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!#VT&n`&aZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!#oe&n`&YS%uZOr%Trs!%Qsw%Twx!&px!Q%T!Q![JU![!c%T!c!tJU!t!u!(`!u!}JU!}#R%T#R#SJU#S#T%T#T#fJU#f#g!(`#g#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!%XV&n`&dZOr%Trs!%ns#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!%sV&n`Or%Trs!&Ys#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&aT&n`&fZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!&wV&n`&cZOw%Twx!'^x#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!'cV&n`Ow%Twx!'xx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!(PT&n`&eZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!(ia&n`&YS%uZOr%Trs!)nsw%Twx!+^x!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!)uV&n`&hZOr%Trs!*[s#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*aV&n`Or%Trs!*vs#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!*}T&n`&jZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!+eV&n`&gZOw%Twx!+zx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,PV&n`Ow%Twx!,fx#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tk!,mT&n`&iZO#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%To!-Vi&n`&YS%uZOr%TrsNWsw%Twx! vx!Q%T!Q![JU![!c%T!c!dJU!d!eLx!e!hJU!h!i!(`!i!}JU!}#R%T#R#SJU#S#T%T#T#UJU#U#VLx#V#YJU#Y#Z!(`#Z#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUo!.}a&n`&YS%uZOr%Trs)Ysw%Twx.Ux!Q%T!Q![JU![!c%T!c!}JU!}#R%T#R#SJU#S#T%T#T#oJU#p#q%T#r$g%T$g;'SJU;'S;=`KW<%lOJUk!0ZT!XZ&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tc!0qT!WR&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%Tj!1XV%kQ&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!1sO!]~k!1zV%jR&n`O!_%T!_!`-Q!`#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T~!2fO![~i!2mT%tX&n`O#o%T#p#q%T#r;'S%T;'S;=`%i<%lO%T",
  tokenizers: [legacyPrint, indentation, newlines, strings, 0, 1, 2, 3, 4],
  topRules: { "Script": [0, 5] },
  specialized: [{ term: 221, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 7668
});

// node_modules/@codemirror/lang-python/dist/index.js
var import_language = require("@codemirror/language");
var import_autocomplete = require("@codemirror/autocomplete");
var cache = /* @__PURE__ */ new NodeWeakMap();
var ScopeNodes = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function defID(type) {
  return (node, def, outer) => {
    if (outer)
      return false;
    let id2 = node.node.getChild("VariableName");
    if (id2)
      def(id2, type);
    return true;
  };
}
var gatherCompletions = {
  FunctionDefinition: /* @__PURE__ */ defID("function"),
  ClassDefinition: /* @__PURE__ */ defID("class"),
  ForStatement(node, def, outer) {
    if (outer)
      for (let child = node.node.firstChild; child; child = child.nextSibling) {
        if (child.name == "VariableName")
          def(child, "variable");
        else if (child.name == "in")
          break;
      }
  },
  ImportStatement(_node, def) {
    var _a, _b;
    let { node } = _node;
    let isFrom = ((_a = node.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "from";
    for (let ch = node.getChild("import"); ch; ch = ch.nextSibling) {
      if (ch.name == "VariableName" && ((_b = ch.nextSibling) === null || _b === void 0 ? void 0 : _b.name) != "as")
        def(ch, isFrom ? "variable" : "namespace");
    }
  },
  AssignStatement(node, def) {
    for (let child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName")
        def(child, "variable");
      else if (child.name == ":" || child.name == "AssignOp")
        break;
    }
  },
  ParamList(node, def) {
    for (let prev = null, child = node.node.firstChild; child; child = child.nextSibling) {
      if (child.name == "VariableName" && (!prev || !/\*|AssignOp/.test(prev.name)))
        def(child, "variable");
      prev = child;
    }
  },
  CapturePattern: /* @__PURE__ */ defID("variable"),
  AsPattern: /* @__PURE__ */ defID("variable"),
  __proto__: null
};
function getScope(doc, node) {
  let cached = cache.get(node);
  if (cached)
    return cached;
  let completions = [], top = true;
  function def(node2, type) {
    let name2 = doc.sliceString(node2.from, node2.to);
    completions.push({ label: name2, type });
  }
  node.cursor(IterMode.IncludeAnonymous).iterate((node2) => {
    if (node2.name) {
      let gather = gatherCompletions[node2.name];
      if (gather && gather(node2, def, top) || !top && ScopeNodes.has(node2.name))
        return false;
      top = false;
    } else if (node2.to - node2.from > 8192) {
      for (let c of getScope(doc, node2.node))
        completions.push(c);
      return false;
    }
  });
  cache.set(node, completions);
  return completions;
}
var Identifier = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/;
var dontComplete = ["String", "FormatString", "Comment", "PropertyName"];
function localCompletionSource(context) {
  let inner = (0, import_language.syntaxTree)(context.state).resolveInner(context.pos, -1);
  if (dontComplete.indexOf(inner.name) > -1)
    return null;
  let isWord = inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
  if (!isWord && !context.explicit)
    return null;
  let options = [];
  for (let pos = inner; pos; pos = pos.parent) {
    if (ScopeNodes.has(pos.name))
      options = options.concat(getScope(context.state.doc, pos));
  }
  return {
    options,
    from: isWord ? inner.from : context.pos,
    validFor: Identifier
  };
}
var globals = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((n) => ({ label: n, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((n) => ({ label: n, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((n) => ({ label: n, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((n) => ({ label: n, type: "function" })));
var snippets = [
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	\n", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ (0, import_autocomplete.snippetCompletion)("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
];
var globalCompletion = /* @__PURE__ */ (0, import_autocomplete.ifNotIn)(dontComplete, /* @__PURE__ */ (0, import_autocomplete.completeFromList)(/* @__PURE__ */ globals.concat(snippets)));
function innerBody(context) {
  let { node, pos } = context;
  let lineIndent = context.lineIndent(pos, -1);
  let found = null;
  for (; ; ) {
    let before = node.childBefore(pos);
    if (!before) {
      break;
    } else if (before.name == "Comment") {
      pos = before.from;
    } else if (before.name == "Body" || before.name == "MatchBody") {
      if (context.baseIndentFor(before) + context.unit <= lineIndent)
        found = before;
      node = before;
    } else if (before.name == "MatchClause") {
      node = before;
    } else if (before.type.is("Statement")) {
      node = before;
    } else {
      break;
    }
  }
  return found;
}
function indentBody(context, node) {
  let base = context.baseIndentFor(node);
  let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
  if (/^\s*($|#)/.test(line.text) && context.node.to < to + 100 && !/\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base)
    return null;
  if (/^\s*(else:|elif |except |finally:|case\s+[^=:]+:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
    return null;
  return base + context.unit;
}
var pythonLanguage = /* @__PURE__ */ import_language.LRLanguage.define({
  name: "python",
  parser: /* @__PURE__ */ parser.configure({
    props: [
      /* @__PURE__ */ import_language.indentNodeProp.add({
        Body: (context) => {
          var _a;
          let body = /^\s*(#|$)/.test(context.textAfter) && innerBody(context) || context.node;
          return (_a = indentBody(context, body)) !== null && _a !== void 0 ? _a : context.continue();
        },
        MatchBody: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = indentBody(context, inner || context.node)) !== null && _a !== void 0 ? _a : context.continue();
        },
        IfStatement: (cx) => /^\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        "ForStatement WhileStatement": (cx) => /^\s*else:/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        TryStatement: (cx) => /^\s*(except[ :]|finally:|else:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
        MatchStatement: (cx) => {
          if (/^\s*case /.test(cx.textAfter))
            return cx.baseIndent + cx.unit;
          return cx.continue();
        },
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ (0, import_language.delimitedIndent)({ closing: "]" }),
        MemberExpression: (cx) => cx.baseIndent + cx.unit,
        "String FormatString": () => null,
        Script: (context) => {
          var _a;
          let inner = innerBody(context);
          return (_a = inner && indentBody(context, inner)) !== null && _a !== void 0 ? _a : context.continue();
        }
      }),
      /* @__PURE__ */ import_language.foldNodeProp.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": import_language.foldInside,
        Body: (node, state) => ({ from: node.from + 1, to: node.to - (node.to == state.doc.length ? 0 : 1) }),
        "String FormatString": (node, state) => ({ from: state.doc.lineAt(node.from).to, to: node.to })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    // Indent logic logic are triggered upon below input patterns
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|case\s+[^:]*:?)$/
  }
});
function python() {
  return new import_language.LanguageSupport(pythonLanguage, [
    pythonLanguage.data.of({ autocomplete: localCompletionSource }),
    pythonLanguage.data.of({ autocomplete: globalCompletion })
  ]);
}

// src/settings.ts
var config2 = {
  name: "obsidian",
  dark: false,
  background: "var(--background-primary)",
  foreground: "var(--text-normal)",
  selection: "var(--text-selection)",
  cursor: "var(--text-normal)",
  activeLine: "var(--background-primary)",
  string: "var(--text-accent)",
  constant: "var(--text-accent-hover)",
  comment: "var(--text-faint)",
  invalid: "var(--text-error)"
};
var obsidianHighlightStyle = import_language2.HighlightStyle.define([
  { tag: [tags.processingInstruction, tags.string, tags.inserted, tags.special(tags.string)], color: config2.string },
  { tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)], color: config2.constant },
  { tag: tags.comment, color: config2.comment },
  { tag: tags.invalid, color: config2.invalid }
]);
var obsidianTheme = import_view2.EditorView.theme({
  "&": {
    color: config2.foreground,
    backgroundColor: config2.background
  },
  ".cm-content": { caretColor: config2.cursor },
  "&.cm-focused .cm-cursor": { borderLeftColor: config2.cursor },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, & ::selection": { backgroundColor: config2.selection },
  ".cm-activeLine": { backgroundColor: config2.activeLine },
  ".cm-activeLineGutter": { backgroundColor: config2.background },
  ".cm-selectionMatch": { backgroundColor: config2.selection },
  ".cm-gutters": {
    backgroundColor: config2.background,
    color: config2.comment,
    borderRight: "1px solid var(--background-modifier-border)"
  },
  ".cm-lineNumbers, .cm-gutterElement": { color: "inherit" }
});
var BaseProfileName = "global";
var ProfileSwitch = import_state.Annotation.define();
var DEFAULT_SETTINGS = {
  debug: false,
  convertRules: DEFAULT_RULES,
  zoneIndicatorOn: false,
  autoFormatOn: true,
  profiles: [
    { title: BaseProfileName, content: DEFAULT_RULES }
  ],
  activeProfile: BaseProfileName
};
var SettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
    this.editorState = {
      selectedProfileName: BaseProfileName,
      selectedProfileEl: void 0,
      baseProfileEl: void 0,
      profilesMap: new Map(plugin.settings.profiles.map((p) => {
        return [p.title, p.content];
      })),
      editedProfile: /* @__PURE__ */ new Set()
    };
  }
  hide() {
    return __async(this, null, function* () {
      var _a;
      (_a = this.ruleEditor) == null ? void 0 : _a.destroy();
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = this.editorState;
      if (set.size > 0) {
        const newProfiles = [];
        for (const [key, value] of map) {
          newProfiles.push({ title: key, content: value });
        }
        this.plugin.settings.profiles = newProfiles;
        log("setting: save profiles");
        yield this.plugin.saveSettings();
      }
      const activeProfile = this.plugin.settings.activeProfile;
      if (target != activeProfile || set.has(BaseProfileName) || set.has(activeProfile)) {
        const newRule = target === BaseProfileName ? map.get(BaseProfileName) : map.get(BaseProfileName) + "\n" + map.get(target);
        yield this.plugin.configureProfile(target, newRule);
      }
    });
  }
  display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Typing Transformer Settings" });
    new import_obsidian2.Setting(containerEl).setName("Debug Log").setDesc("Enable debug log to console.").addToggle(
      (comp) => comp.setValue(plugin.settings.debug).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleDebugLog();
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Auto Format").setDesc("Enable the auto insertion of spaces.").addToggle(
      (comp) => comp.setValue(plugin.settings.autoFormatOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleAutoFormat();
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Zone Indicator").setDesc("Enable indication of a zone's start point with '\u2B50\uFE0F'").addToggle(
      (comp) => comp.setValue(plugin.settings.zoneIndicatorOn).onChange((_val) => __async(this, null, function* () {
        return yield plugin.toggleIndicator();
      }))
    );
    this.ruleEditor = createRuleEditorInContainer(containerEl, plugin, this.editorState);
  }
};
function createRuleEditorInContainer(container, plugin, state) {
  const fragment = document.createDocumentFragment();
  fragment.createEl("span", { text: "Enter conversion, selection, and deletion rules here. NOTES:" });
  const ol = fragment.createEl("ol");
  ol.createEl("li", { text: "Each line is one rule. Rules that come first have higher priority." });
  ol.createEl("li", { text: 'Lines starting with "#" are treated as comments and ignored. Inline comments are also allowed' });
  ol.createEl("li", { text: "The character '|' indicates where your cursor will be placed after the rule is applied." });
  ol.createEl("li", { text: "To use special characters like '|' for conversion, you escape them with a backslash, for example: '\\|' " });
  ol.createEl("li", { text: "Whatever tab you are on when the plugin settings tab quits will be the profile that is chosen" });
  ol.createEl("li", { text: "The 'global' profile will always be active" });
  const convertRulesSetting = new import_obsidian2.Setting(container).setName("Rules").setDesc(fragment).setClass("rules-text-area");
  const profilesContainer = convertRulesSetting.controlEl.createDiv("rules-profiles");
  const customCSSWrapper = convertRulesSetting.controlEl.createDiv("rules-editor-wrapper");
  const rulesFooter = convertRulesSetting.controlEl.createDiv("rules-footer");
  const validity = rulesFooter.createDiv("rules-editor-validity");
  const validityIndicator = new import_obsidian2.ExtraButtonComponent(validity);
  validityIndicator.setIcon("checkmark").extraSettingsEl.addClass("rules-editor-validity-indicator");
  const validityText = validity.createDiv("rules-editor-validity-text");
  validityText.classList.add("setting-item-description", "rules-editor-validity-txt");
  function resetValidityIndicator() {
    validityIndicator.setIcon("");
    validityIndicator.extraSettingsEl.removeClasses(["invalid", "valid"]);
    validityText.setText("");
  }
  function tryResetValidityIndicator() {
    return __async(this, null, function* () {
      if (validityIndicator.extraSettingsEl.hasClass("invalid")) {
        return new Promise((resolve, _reject) => {
          new ConfirmationModal(
            app,
            "Are you sure you want to discard changes?",
            (ans) => __async(this, null, function* () {
              if (ans)
                resetValidityIndicator();
              resolve(ans);
            })
          ).open();
        });
      } else {
        resetValidityIndicator();
        return new Promise((resolve, _reject) => resolve(true));
      }
    });
  }
  function updateValidityIndicator(success, errs) {
    validityIndicator.setIcon(success ? "checkmark" : "cross");
    validityIndicator.extraSettingsEl.removeClass(success ? "invalid" : "valid");
    validityIndicator.extraSettingsEl.addClass(success ? "valid" : "invalid");
    const fragment2 = document.createDocumentFragment();
    for (const err of errs) {
      fragment2.createEl("div", { text: err });
    }
    validityText.setText(success ? "Saved" : fragment2);
  }
  const extensions = [
    obsidianTheme,
    (0, import_view2.lineNumbers)(),
    import_view2.EditorView.lineWrapping,
    python(),
    // it is better to write a language support for rules
    (0, import_language2.syntaxHighlighting)(obsidianHighlightStyle),
    import_view2.EditorView.updateListener.of((v) => __async(this, null, function* () {
      if (v.docChanged) {
        if (v.transactions.reduce((swtich, tr) => swtich || tr.annotation(ProfileSwitch), false)) {
          return;
        }
        const value = v.state.doc.toString();
        yield feedRules(value);
      }
    }))
  ];
  const feedRules = (newRule) => __async(this, null, function* () {
    const errs = yield plugin.checkRules(newRule);
    if (errs.length != 0) {
      updateValidityIndicator(false, errs);
    } else {
      updateValidityIndicator(true, []);
      const { selectedProfileName: target, profilesMap: map, editedProfile: set } = state;
      map.set(target, newRule);
      set.add(target);
    }
  });
  const setCMEditorContent = (text) => {
    convertRulesEditor.dispatch({
      changes: { from: 0, to: convertRulesEditor.state.doc.length, insert: text },
      annotations: ProfileSwitch.of(true)
    });
  };
  const convertRulesEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({ doc: plugin.settings.convertRules, extensions })
  });
  customCSSWrapper.appendChild(convertRulesEditor.dom);
  const buttonsDiv = rulesFooter.createDiv("rules-editor-buttons");
  const reset = new import_obsidian2.ButtonComponent(buttonsDiv);
  reset.setIcon("switch").setTooltip("Reset to default rules").onClick(() => __async(this, null, function* () {
    convertRulesEditor.setState(import_state.EditorState.create({ doc: DEFAULT_RULES, extensions }));
    yield feedRules(DEFAULT_RULES);
  }));
  const onProfileClick = (name2, el) => __async(this, null, function* () {
    var _a;
    if (!(yield tryResetValidityIndicator()))
      return;
    (_a = state.selectedProfileEl) == null ? void 0 : _a.removeClass("selected");
    el == null ? void 0 : el.addClass("selected");
    state.selectedProfileEl = el;
    state.selectedProfileName = name2;
    setCMEditorContent(state.profilesMap.get(name2));
  });
  const onRemoveProfileClick = (name2, el) => {
    if (el === state.selectedProfileEl)
      onProfileClick(BaseProfileName, state.baseProfileEl);
    state.profilesMap.delete(name2);
    state.editedProfile.add(name2);
    profilesContainer.removeChild(el);
  };
  const addProfile = (profile, selected) => {
    const button = new import_obsidian2.ExtraButtonComponent(profilesContainer);
    const el = button.extraSettingsEl;
    el.accessKey = profile.title;
    button.onClick(() => onProfileClick(profile.title, el));
    el.addClass("rules-profile-button");
    el.setText(profile.title);
    if (profile.title != BaseProfileName) {
      const closeEl = new import_obsidian2.ExtraButtonComponent(el).setIcon("cross").extraSettingsEl;
      closeEl.onClickEvent((ev) => {
        ev.stopPropagation();
        onRemoveProfileClick(profile.title, el);
      });
      closeEl.addClass("rules-profile-close");
    } else {
      state.baseProfileEl = el;
    }
    if (selected) {
      onProfileClick(profile.title, el);
    }
  };
  for (const profile of plugin.settings.profiles) {
    addProfile(profile, profile.title === plugin.settings.activeProfile);
  }
  const addButton = new import_obsidian2.ExtraButtonComponent(profilesContainer).onClick(() => {
    if (state.profilesMap.size > 5) {
      new import_obsidian2.Notice("You can only have 6 profiles at most.");
      return;
    }
    new StringInputModal(app, (value) => {
      if (state.profilesMap.has(value))
        return false;
      if (value === void 0)
        return true;
      state.profilesMap.set(value, "");
      state.editedProfile.add(value);
      profilesContainer.removeChild(addButton.extraSettingsEl);
      addProfile({ title: value, content: "" }, true);
      profilesContainer.appendChild(addButton.extraSettingsEl);
      return true;
    }).open();
  });
  addButton.extraSettingsEl.addClass("rules-profile-button");
  addButton.extraSettingsEl.setText("+");
  return convertRulesEditor;
}
var StringInputModal = class extends import_obsidian2.Modal {
  constructor(app2, onSubmit) {
    super(app2);
    this.submitEnterCallback = (evt) => {
      if (evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.onSubmit = onSubmit;
  }
  submit() {
    if (this.onSubmit(this.result))
      this.close();
    else
      this.err.setText("Profile already exists!");
  }
  onOpen() {
    const { titleEl, contentEl } = this;
    titleEl.setText("Profile Name");
    const container = contentEl.createDiv();
    const textComponent = new import_obsidian2.TextComponent(container);
    this.err = container.createEl("p");
    textComponent.inputEl.style.width = "100%";
    textComponent.onChange((value) => this.result = value).inputEl.addEventListener("keydown", this.submitEnterCallback);
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => this.submit()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ConfirmationModal = class extends import_obsidian2.Modal {
  constructor(app2, prompt, confirmCb) {
    super(app2);
    this.contentEl.createEl("p", { text: prompt });
    new import_obsidian2.Setting(this.contentEl).addButton(
      (button) => button.setButtonText("Confirm").onClick(() => __async(this, null, function* () {
        yield confirmCb(true);
        this.close();
      }))
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => __async(this, null, function* () {
        yield confirmCb(false);
        this.close();
      }))
    );
  }
};

// src/global_commands.ts
var import_obsidian3 = require("obsidian");
function getAllCommands(plugin) {
  const format = {
    id: "typing-trans-toggle-format",
    name: "Toggle Auto Formatting",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleAutoFormat();
    })
  };
  const zone = {
    id: "typing-trans-toggle-zone-indicator",
    name: "Toggle Auto Formatting Zone Indicator",
    editorCallback: (_e, _v) => __async(this, null, function* () {
      return yield plugin.toggleIndicator();
    })
  };
  const ret = [format, zone];
  const useProfileX = (i) => __async(this, null, function* () {
    const profs = plugin.settings.profiles;
    if (i >= profs.length) {
      new import_obsidian3.Notice(`Profile ${i} doesn't exist`);
      return;
    }
    const { title, content: content2 } = profs[i];
    if (plugin.settings.activeProfile === title)
      return;
    const newRule = title === BaseProfileName ? content2 : profs[0].content + "\n" + content2;
    plugin.configureProfile(title, newRule);
  });
  for (let i = 0; i < 6; i++) {
    const useProfileCommand = {
      id: "typing-trans-p" + i.toString(),
      name: "apply profile " + i.toString() + (i === 0 ? " (global)" : ""),
      editorCallback: (_e, _v) => __async(this, null, function* () {
        yield useProfileX(i);
      })
    };
    ret.push(useProfileCommand);
  }
  return ret;
}

// src/main.ts
var ProgramTxn = import_state2.Annotation.define();
var deubgExt = import_state2.StateField.define({
  create: (_state) => {
    return 0;
  },
  update: (value, tr) => {
    if (tr.docChanged) {
      tr.changes.iterChanges((a, b, c, d, insert) => {
        console.log(a, b, c, d, insert.sliceString(0));
      });
    }
    return value;
  }
});
function ignoreThisTr(tr) {
  return !tr.docChanged || tr.annotation(ProgramTxn) || tr.isUserEvent("redo") || tr.isUserEvent("undo");
}
var TypingTransformer = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.configureProfile = (title, ruleString) => __async(this, null, function* () {
      this.settings.activeProfile = title;
      this.settings.convertRules = ruleString;
      yield this.configureRules(ruleString);
      this.updateProfileStatus();
      yield this.saveSettings();
    });
    this.configureRules = (ruleString) => __async(this, null, function* () {
      this.rules = new Rules();
      yield this.rules.parse(ruleString, this.app.vault.adapter, false);
    });
    this.checkRules = (ruleString) => __async(this, null, function* () {
      this.rules = new Rules();
      yield this.rules.parse(ruleString, this.app.vault.adapter, true);
      return this.rules.errors;
    });
    this.configureActiveExtsFromSettings = () => {
      const activeIds = [1 /* Conversion */, 0 /* SideInsert */];
      const { debug, zoneIndicatorOn, autoFormatOn } = this.settings;
      if (debug) {
        activeIds.push(4 /* Debug */);
      }
      if (zoneIndicatorOn) {
        activeIds.push(2 /* ZoneIndicator */);
      }
      if (autoFormatOn) {
        activeIds.push(3 /* AutoFormat */);
      }
      this.activeExts.forEach((_ext, idx) => this.activeExts[idx] = []);
      activeIds.forEach((extid) => this.activeExts[extid] = this.availablExts[extid]);
      this.activeExts.push((0, import_commands.history)({
        joinToEvent: (tr, isAdjacent) => {
          return !tr.annotation(ProgramTxn) && isAdjacent;
        }
      }));
    };
    this.toggleAutoFormat = () => __async(this, null, function* () {
      this.settings.autoFormatOn = !this.settings.autoFormatOn;
      yield this.saveAndReloadPlugin();
    });
    this.toggleDebugLog = () => __async(this, null, function* () {
      this.settings.debug = !this.settings.debug;
      yield this.saveAndReloadPlugin();
    });
    this.toggleIndicator = () => __async(this, null, function* () {
      this.settings.zoneIndicatorOn = !this.settings.zoneIndicatorOn;
      yield this.saveAndReloadPlugin();
    });
    this.saveAndReloadPlugin = () => __async(this, null, function* () {
      yield this.saveSettings();
      this.configureActiveExtsFromSettings();
      this.app.workspace.updateOptions();
    });
    // Features
    this.spotLibertyZone = ({ view, docChanged }) => {
      if (!docChanged) {
        return;
      }
      const state = view.state;
      const mainSel = state.selection.asSingle().main;
      if (mainSel.anchor != mainSel.head) {
        return;
      }
      const line = state.doc.lineAt(mainSel.anchor);
      const from = line.from;
      const to = mainSel.anchor;
      if (from == to) {
        return;
      }
      for (const pos of this.specialSections) {
        if (pos.start.line <= line.number - 1 && line.number - 1 <= pos.end.line) {
          return;
        }
      }
      const checkInBlock = (blocks2, offset) => {
        for (let i = blocks2.length - 2; i > -1; i -= 2) {
          if (blocks2[i] < offset && offset <= blocks2[i + 1]) {
            return { exist: true, from: blocks2[i], to: blocks2[i + 1] };
          }
        }
        return { exist: false, from: 0, to: 0 };
      };
      const blocks = getBlockRanges(line.text, to - from);
      const r = checkInBlock(blocks.emphasis, to - from);
      if (r.exist) {
        const txt2 = state.sliceDoc(from + r.from, from + r.to);
        let i;
        for (i = 0; txt2[i] == txt2[0] && i < r.to; i++) {
          log("format: skip emphasis head", i, txt2[i]);
        }
        return { from: from + r.from + i, to };
      }
      const spBlocks = blocks.special;
      if (checkInBlock(spBlocks, to - from).exist) {
        return;
      }
      const txt = state.sliceDoc(from, to);
      for (let i = txt.length - 2; i > 0; i--) {
        const ch = txt[i];
        if (ch != " " && PUNCTS.has(ch) && !checkInBlock(spBlocks, i).exist) {
          return { from: from + i, to };
        }
      }
      return { from, to };
    };
    this.addLiberty = (update) => {
      const range = this.spotLibertyZone(update);
      if (range === void 0 || !update.selectionSet) {
        return;
      }
      if (update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      const from = range.from, to = range.to;
      const toUpdate = update.view.state.doc.sliceString(from, to);
      if (PUNCTS.has(toUpdate.charAt(toUpdate.length - 1))) {
        const trimmed = toUpdate.trim();
        if (trimmed === "") {
          return;
        }
        const lspace = toUpdate.length - toUpdate.trimStart().length;
        const rspace = toUpdate.length - toUpdate.trimEnd().length;
        log(
          "foramt: trigger char: %s, toUpdate: %s, lspace: %d, rspace: %d",
          toUpdate.charAt(toUpdate.length - 1),
          toUpdate,
          lspace,
          rspace
        );
        const formatted = formatLine(trimmed);
        if (formatted === trimmed) {
          return;
        }
        update.view.dispatch({ changes: { from: from + lspace, to: to - rspace, insert: formatLine(trimmed) }, annotations: ProgramTxn.of(true) });
      }
    };
    this.convertFilter = (update) => __async(this, null, function* () {
      if (!update.docChanged || update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      let shouldHijack = true;
      const changePromises = [];
      const { insertTrigSet, deleteTrigSet, lmax, rmax } = this.rules;
      update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        if (!shouldHijack) {
          return;
        }
        let trigger;
        if (fromA === toA && fromB + 1 === toB) {
          trigger = inserted.sliceString(0);
          if (!insertTrigSet.has(trigger)) {
            shouldHijack = false;
          }
        } else if (fromA + 1 === toA && fromB === toB) {
          const delChar = update.startState.sliceDoc(fromA, toA);
          if (!deleteTrigSet.has(delChar)) {
            shouldHijack = false;
          }
          trigger = DEL_TRIG;
          fromA = toA;
          fromB += 1;
          toB = fromB + 1;
        } else {
          shouldHijack = false;
        }
        if (!shouldHijack) {
          return;
        }
        let leftIdx = fromB - lmax;
        let insertPosFromInputTextHead = lmax;
        if (leftIdx < 0) {
          leftIdx = 0;
          insertPosFromInputTextHead = fromB;
        }
        const input = update.startState.sliceDoc(leftIdx, fromB + rmax);
        const promsise = this.rules.match(input, trigger, insertPosFromInputTextHead).then((rule) => {
          if (rule != null) {
            log("hit covert rule: %s", rule.left.join(""));
            const change = rule.mapToChanges(fromB, trigger === DEL_TRIG);
            change.annotations = ProgramTxn.of(true);
            log("change: ", change);
            return change;
          } else {
            return null;
          }
        });
        changePromises.push(promsise);
      });
      const results = yield Promise.all(changePromises);
      const changes = results.filter((result) => result != null);
      if (results.length === changes.length && changes.length > 0) {
        update.view.dispatch(...changes);
      }
      return;
    });
    this.sidesInsertFilter = (update) => {
      if (!update.docChanged || update.transactions.some((tr) => ignoreThisTr(tr))) {
        return;
      }
      let shouldHijack = true;
      const changes = [];
      update.changes.iterChanges((fromA, toA, fromB, toB, inserted) => {
        const char = inserted.sliceString(0);
        if (!shouldHijack || fromA == toA || toB != fromB + 1 || !this.rules.sideInsertMap.has(char)) {
          shouldHijack = false;
          return;
        }
        const rule = this.rules.sideInsertMap.get(char);
        const replaced = update.startState.sliceDoc(fromA, toA);
        const insertText = rule.left + replaced + rule.right;
        const cursorPos = rule.calculateCursorPos(fromB, replaced.length);
        changes.push({
          changes: { from: fromB, to: toB, insert: insertText },
          annotations: ProgramTxn.of(true),
          selection: { anchor: cursorPos, head: cursorPos }
        });
      });
      if (shouldHijack) {
        update.view.dispatch(...changes);
      }
    };
    this.updateProfileStatus = () => {
      this.profileStatus.setText(`Active Profile: ${this.settings.activeProfile}`);
    };
  }
  // Lifetime
  onload() {
    return __async(this, null, function* () {
      if (this.app.vault.adapter instanceof import_obsidian4.FileSystemAdapter) {
        this.basePath = this.app.vault.adapter.getBasePath();
      }
      console.log("loading typing transformer plugin");
      yield this.loadSettings();
      initLog(this.settings);
      yield charliberty_default({ module_or_path: charliberty_bg_default });
      this.specialSections = [];
      this.activeExts = [];
      this.availablExts = [
        import_view3.EditorView.updateListener.of(this.sidesInsertFilter),
        import_view3.EditorView.updateListener.of(this.convertFilter),
        libertyZone(this.spotLibertyZone),
        import_view3.EditorView.updateListener.of(this.addLiberty),
        deubgExt
      ];
      this.availablExts.forEach((_, idx) => this.activeExts[idx] = []);
      yield this.configureRules(this.settings.convertRules);
      this.configureActiveExtsFromSettings();
      this.registerEditorExtension(this.activeExts);
      this.registerEvent(this.app.metadataCache.on("changed", (_f, _d, meta2) => {
        var _a;
        this.specialSections.length = 0;
        (_a = meta2.sections) == null ? void 0 : _a.forEach((sec) => {
          if (sec.type == "code" || sec.type == "match") {
            this.specialSections.push(sec.position);
          }
        });
      }));
      this.addSettingTab(new SettingTab(this.app, this));
      for (const cmd of getAllCommands(this)) {
        this.addCommand(cmd);
      }
      this.profileStatus = this.addStatusBarItem();
      this.updateProfileStatus();
    });
  }
  onunload() {
    console.log("unloading typing transformer plugin");
  }
  // Settings
  loadSettings() {
    return __async(this, null, function* () {
      const data = yield this.loadData();
      let defaultSource = DEFAULT_SETTINGS;
      if (data && !Object.prototype.hasOwnProperty.call(data, "profiles") && data.convertRules != DEFAULT_SETTINGS.convertRules) {
        const cloned = structuredClone(DEFAULT_SETTINGS);
        cloned.profiles[0].content = data.convertRules;
        defaultSource = cloned;
      }
      this.settings = Object.assign({}, defaultSource, data);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};

/* nosourcemap */