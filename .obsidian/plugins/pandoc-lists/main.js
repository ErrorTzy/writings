/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PandocListsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/decorations/pandocListsExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type) {
    super();
    this.marker = marker;
    this.type = type;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = this.marker;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.marker === this.marker;
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.number}) `;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var DefinitionBulletWidget = class extends import_view.WidgetType {
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-list-1";
    span.textContent = "\u2022 ";
    return span;
  }
  eq(other) {
    return true;
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-formatting-list-ol cm-list-1";
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `${this.number}. `;
    span.appendChild(innerSpan);
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var ExampleReferenceWidget = class extends import_view.WidgetType {
  constructor(number) {
    super();
    this.number = number;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "pandoc-example-reference";
    span.textContent = `(${this.number})`;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
};
var pandocListsPlugin = (getSettings) => import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.exampleLabels = /* @__PURE__ */ new Map();
      this.scanExampleLabels(view);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        if (update.docChanged) {
          this.scanExampleLabels(update.view);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    isListItemForValidation(line) {
      return !!(line.match(/^(\s*)(#\.)(\s+)/) || // Hash auto-numbering
      line.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/) || // Fancy lists
      line.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/) || // Example lists
      line.match(/^[~:]\s+/) || // Definition lists
      line.match(/^(\s*)[-*+]\s+/) || // Unordered lists
      line.match(/^(\s*)[0-9]+[.)]\s+/));
    }
    scanExampleLabels(view) {
      this.exampleLabels.clear();
      let counter = 1;
      const docText = view.state.doc.toString();
      const lines = docText.split("\n");
      for (const line of lines) {
        const match = line.match(/^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+/);
        if (match) {
          const label = match[2];
          if (!this.exampleLabels.has(label)) {
            this.exampleLabels.set(label, counter);
          }
          counter++;
        } else if (line.match(/^(\s*)\(@\)\s+/)) {
          counter++;
        }
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const isLivePreview = view.state.field(import_obsidian.editorLivePreviewField);
      if (!isLivePreview) {
        return builder.finish();
      }
      const settings = getSettings();
      const lines = view.state.doc.toString().split("\n");
      const selection = view.state.selection.main;
      const cursorPos = selection.head;
      const decorations = [];
      let hashCounter = 1;
      const invalidListBlocks = /* @__PURE__ */ new Set();
      if (settings.strictPandocMode) {
        let listBlockStart = -1;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const isCurrentList = this.isListItemForValidation(line);
          const prevIsListOrEmpty = i > 0 && (this.isListItemForValidation(lines[i - 1]) || lines[i - 1].trim() === "");
          const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && !lines[i - 1].match(/^[~:]\s+/) && !lines[i - 1].match(/^(    |\t)/) && line.match(/^[~:]\s+/);
          if (isCurrentList && listBlockStart === -1) {
            listBlockStart = i;
            if (i > 0 && lines[i - 1].trim() !== "" && !prevIsDefinitionTerm) {
              for (let j = i; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
                invalidListBlocks.add(j);
              }
            }
          } else if (!isCurrentList && listBlockStart !== -1) {
            if (line.trim() !== "") {
              for (let j = listBlockStart; j < i; j++) {
                invalidListBlocks.add(j);
              }
            }
            listBlockStart = -1;
          }
          if (isCurrentList) {
            const capitalLetterMatch = line.match(/^(\s*)([A-Z])(\.)(\s+)/);
            if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
              for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
                invalidListBlocks.add(j);
              }
              for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
                invalidListBlocks.add(j);
              }
            }
          }
        }
      }
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        const lineText = line.text;
        const validationContext = {
          lines,
          currentLine: lineNum - 1
          // 0-based index
        };
        const hashMatch = lineText.match(/^(\s*)(#\.)(\s+)/);
        if (hashMatch) {
          if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
            continue;
          }
          const indent = hashMatch[1];
          const marker = hashMatch[2];
          const space = hashMatch[3];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + marker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: "text-indent: -29px; padding-inline-start: 29px;"
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new HashListMarkerWidget(hashCounter)
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + marker.length + space.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          hashCounter++;
          continue;
        }
        const fancyMatch = lineText.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/);
        if (fancyMatch && !lineText.match(/^(\s*)([0-9]+[.)])/)) {
          if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
            continue;
          }
          const indent = fancyMatch[1];
          const marker = fancyMatch[2];
          const markerWithSpace = marker + fancyMatch[5];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + markerWithSpace.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: `text-indent: -${markerWithSpace.length * 7}px; padding-inline-start: ${markerWithSpace.length * 7}px;`
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new FancyListMarkerWidget(markerWithSpace, "fancy")
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + markerWithSpace.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          continue;
        }
        const exampleMatch = lineText.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/);
        if (exampleMatch) {
          if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
            continue;
          }
          const indent = exampleMatch[1];
          const fullMarker = exampleMatch[2];
          const label = exampleMatch[3];
          const space = exampleMatch[4];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + fullMarker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          let exampleNumber = 1;
          if (label && this.exampleLabels.has(label)) {
            exampleNumber = this.exampleLabels.get(label);
          } else {
            let tempCounter = 1;
            for (let i = 1; i < line.number; i++) {
              const prevLine = view.state.doc.line(i).text;
              if (prevLine.match(/^(\s*)\(@\)\s+/)) {
                tempCounter++;
              }
            }
            exampleNumber = tempCounter;
          }
          decorations.push({
            from: line.from,
            to: line.from,
            decoration: import_view.Decoration.line({
              class: "HyperMD-list-line HyperMD-list-line-1",
              attributes: {
                style: "text-indent: -29px; padding-inline-start: 29px;"
              }
            })
          });
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new ExampleListMarkerWidget(exampleNumber)
              })
            });
          }
          decorations.push({
            from: line.from + indent.length + fullMarker.length + space.length,
            to: line.to,
            decoration: import_view.Decoration.mark({
              class: "cm-list-1"
            })
          });
          continue;
        }
        const defItemMatch = lineText.match(/^([~:])(\s+)/);
        if (defItemMatch) {
          if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
            continue;
          }
          const marker = defItemMatch[1];
          const space = defItemMatch[2];
          const markerStart = line.from;
          const markerEnd = line.from + marker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new DefinitionBulletWidget()
              })
            });
          }
          continue;
        }
        const indentMatch = lineText.match(/^(    |\t)(.*)$/);
        if (indentMatch) {
          let inDefinitionContext = false;
          for (let checkLine = lineNum - 1; checkLine >= 1; checkLine--) {
            const prevLine = view.state.doc.line(checkLine);
            const prevText = prevLine.text;
            if (prevText.match(/^[~:]\s+/)) {
              inDefinitionContext = true;
              break;
            }
            if (prevText.trim() && !prevText.match(/^(    |\t)/) && !prevText.match(/^[~:]\s+/)) {
              break;
            }
          }
          if (inDefinitionContext) {
            const content = indentMatch[2];
            if (content && content.trim()) {
              decorations.push({
                from: line.from,
                to: line.from,
                decoration: import_view.Decoration.line({
                  class: "cm-pandoc-definition-paragraph",
                  attributes: {
                    "data-definition-content": "true"
                  }
                })
              });
              decorations.push({
                from: line.from,
                to: line.to,
                decoration: import_view.Decoration.mark({
                  class: "pandoc-definition-content-text"
                })
              });
            }
            continue;
          }
        }
        if (lineText.trim() && !lineText.match(/^[~:]\s*/) && !indentMatch) {
          let isDefinitionTerm = false;
          let checkOffset = 1;
          if (line.number + 1 <= view.state.doc.lines) {
            const nextLine = view.state.doc.line(line.number + 1);
            const nextText = nextLine.text;
            if (nextText.match(/^[~:]\s+/)) {
              isDefinitionTerm = true;
            } else if (nextText.trim() === "" && line.number + 2 <= view.state.doc.lines) {
              const lineAfterEmpty = view.state.doc.line(line.number + 2);
              if (lineAfterEmpty.text.match(/^[~:]\s+/)) {
                isDefinitionTerm = true;
              }
            }
          }
          if (isDefinitionTerm) {
            decorations.push({
              from: line.from,
              to: line.to,
              decoration: import_view.Decoration.mark({
                class: "cm-strong cm-pandoc-definition-term"
              })
            });
          }
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let match;
        while ((match = refRegex.exec(lineText)) !== null) {
          const label = match[1];
          if (this.exampleLabels.has(label)) {
            const refStart = line.from + match.index;
            const refEnd = line.from + match.index + match[0].length;
            const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
            if (!cursorInRef) {
              const number = this.exampleLabels.get(label);
              decorations.push({
                from: refStart,
                to: refEnd,
                decoration: import_view.Decoration.replace({
                  widget: new ExampleReferenceWidget(number)
                })
              });
            }
          }
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocListsExtension(getSettings) {
  return [
    pandocListsPlugin(getSettings),
    import_view.EditorView.baseTheme({
      ".cm-pandoc-definition-term": {
        textDecoration: "underline"
      },
      ".cm-pandoc-definition-paragraph": {
        // Don't add extra padding - indentation is already handled by spaces/tabs
        textIndent: "0 !important"
      },
      ".cm-pandoc-definition-paragraph .cm-hmd-indented-code": {
        background: "transparent !important",
        border: "none !important",
        borderRadius: "0 !important",
        padding: "0 !important",
        color: "inherit !important",
        fontFamily: "inherit !important",
        fontSize: "inherit !important"
      },
      ".pandoc-definition-content-text": {
        background: "transparent !important",
        border: "none !important",
        padding: "0 !important",
        color: "inherit !important",
        fontFamily: "inherit !important"
      },
      ".cm-pandoc-definition-paragraph .cm-indent": {
        // Keep indent visible for proper cursor positioning
        opacity: "1"
      },
      ".pandoc-example-reference": {
        color: "var(--text-accent)",
        cursor: "pointer"
      },
      ".pandoc-example-reference:hover": {
        textDecoration: "underline"
      }
    })
  ];
}

// src/parsers/fancyListParser.ts
var ROMAN_UPPER = /^[IVXLCDM]+$/;
var ROMAN_LOWER = /^[ivxlcdm]+$/;
var ALPHA_UPPER = /^[A-Z]+$/;
var ALPHA_LOWER = /^[a-z]+$/;
var DECIMAL = /^[0-9]+$/;
function parseFancyListMarker(line) {
  const match = line.match(/^(\s*)(([a-zA-Z]+|[ivxlcdmIVXLCDM]+|[0-9]+|#)([.)]))\s+/);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (value === "#") {
    type = "hash";
  } else if (DECIMAL.test(value)) {
    return null;
  } else if (ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
function parseExampleListMarker(line) {
  const match = line.match(/^(\s*)(\(@([a-zA-Z0-9_-]+)?\))\s+/);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3]
  };
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(/^([^\n:~]+)$/);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(/^\s*\d+[.)]/)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = line.match(/^(\s*)([~:])\s+(.+)/);
  if (defMatch) {
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content: defMatch[3]
    };
  }
  return null;
}

// src/pandocValidator.ts
function isStrictPandocList(context, strictMode) {
  if (!strictMode) {
    return true;
  }
  const { lines, currentLine } = context;
  const line = lines[currentLine];
  const isPartOfListBlock = currentLine > 0 && isListItem(lines[currentLine - 1]);
  if (currentLine > 0 && !isPartOfListBlock) {
    const prevLine = lines[currentLine - 1];
    if (prevLine.trim() !== "") {
      return false;
    }
  }
  const capitalLetterMatch = line.match(/^(\s*)([A-Z])([.)])\s+/);
  if (capitalLetterMatch && capitalLetterMatch[3] === ".") {
    const spacesAfterMarker = line.match(/^(\s*)([A-Z]\.)(\s+)/);
    if (spacesAfterMarker && spacesAfterMarker[3].length < 2) {
      return false;
    }
  }
  let isLastItemInList = true;
  if (currentLine < lines.length - 1) {
    const nextLine = lines[currentLine + 1];
    const nextIsListItem = isListItem(nextLine);
    if (!nextIsListItem && nextLine.trim() !== "") {
      return false;
    }
    if (nextIsListItem) {
      isLastItemInList = false;
    }
  }
  return true;
}
function isListItem(line) {
  const patterns = [
    /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|[0-9]+|#)([.)]))(\s+)/,
    // Fancy lists
    /^(\s*)[-*+]\s+/,
    // Unordered lists
    /^(\s*)\(@([a-zA-Z0-9_-]*)\)\s+/,
    // Example lists
    /^(\s*)[~:]\s+/
    // Definition lists
  ];
  return patterns.some((pattern) => pattern.test(line));
}
function formatToPandocStandard(content) {
  const lines = content.split("\n");
  const result = [];
  let inListBlock = false;
  let lastWasEmpty = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line);
    const isCurrentLineHeading = line.match(/^#{1,6}\s+/) !== null;
    const isEmpty = line.trim() === "";
    if (isCurrentLineList && !inListBlock) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      inListBlock = true;
    }
    if (!isCurrentLineList && !isEmpty && inListBlock) {
      if (!lastWasEmpty) {
        result.push("");
      }
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      let formattedLine = line;
      result.push(formattedLine);
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        result.push("");
        lastWasEmpty = true;
      } else {
        lastWasEmpty = false;
      }
      continue;
    }
    const capitalLetterMatch = line.match(/^(\s*)([A-Z])(\.)(\s+)/);
    if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
      const formattedLine = line.replace(/^(\s*)([A-Z]\.)(\s+)/, "$1$2  ");
      result.push(formattedLine);
    } else {
      result.push(line);
    }
    lastWasEmpty = isEmpty;
  }
  const cleanedResult = [];
  let prevWasEmpty = false;
  for (const line of result) {
    if (line.trim() === "") {
      if (!prevWasEmpty) {
        cleanedResult.push(line);
        prevWasEmpty = true;
      }
    } else {
      cleanedResult.push(line);
      prevWasEmpty = false;
    }
  }
  return cleanedResult.join("\n");
}
function checkPandocFormatting(content) {
  const lines = content.split("\n");
  const issues = [];
  let inListBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line);
    const isCurrentLineHeading = line.match(/^#{1,6}\s+/) !== null;
    const isEmpty = line.trim() === "";
    if (isCurrentLineList) {
      if (!inListBlock && i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "List should have an empty line before it"
        });
      }
      const capitalLetterMatch = line.match(/^(\s*)([A-Z])(\.)(\s+)/);
      if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
        issues.push({
          line: i + 1,
          message: "Capital letter list with period requires at least 2 spaces after marker"
        });
      }
      inListBlock = true;
    } else if (!isEmpty && inListBlock) {
      if (i > 0 && isListItem(lines[i - 1])) {
        issues.push({
          line: i,
          message: "List should have an empty line after it"
        });
      }
      inListBlock = false;
    } else if (isEmpty) {
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line before it"
        });
      }
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line after it"
        });
      }
    }
  }
  return issues;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context, settings) {
  var _a;
  const elementsToProcess = element.querySelectorAll("p, li");
  const section = element.closest(".markdown-preview-section");
  const sectionInfo = section ? (_a = section.getSection) == null ? void 0 : _a.call(section) : null;
  const fullText = (sectionInfo == null ? void 0 : sectionInfo.text) || "";
  const lines = fullText.split("\n");
  const exampleMap = /* @__PURE__ */ new Map();
  let exampleCounter = 1;
  elementsToProcess.forEach((elem) => {
    const text = elem.textContent || "";
    const lines2 = text.split("\n");
    lines2.forEach((line) => {
      const exampleInfo = parseExampleListMarker(line);
      if (exampleInfo) {
        if (exampleInfo.label && !exampleMap.has(exampleInfo.label)) {
          exampleMap.set(exampleInfo.label, exampleCounter);
          exampleCounter++;
        } else if (!exampleInfo.label) {
          exampleCounter++;
        }
      }
    });
  });
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    const walker = document.createTreeWalker(
      elem,
      NodeFilter.SHOW_TEXT,
      null
    );
    const nodesToProcess = [];
    while (walker.nextNode()) {
      nodesToProcess.push(walker.currentNode);
    }
    nodesToProcess.forEach((node) => {
      const parent = node.parentNode;
      if (!parent) return;
      if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
        return;
      }
      const text = node.textContent || "";
      const hasCustomSyntax = text.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|#)([.)]))(\s+)/) || text.match(/^(\s*)\(@[a-zA-Z0-9_-]*\)\s+/) || text.match(/^(\s*)[~:]\s+/) || text.match(/\(@[a-zA-Z0-9_-]+\)/);
      if (!hasCustomSyntax) {
        return;
      }
      const lines2 = text.split("\n");
      const newElements = [];
      lines2.forEach((line, lineIndex) => {
        if (lineIndex > 0) {
          newElements.push(document.createTextNode("\n"));
        }
        let isDefinitionTerm = false;
        if (lineIndex < lines2.length - 1) {
          const nextLine = lines2[lineIndex + 1];
          if (nextLine && nextLine.match(/^(\s*)[~:]\s+/)) {
            isDefinitionTerm = true;
          }
        }
        const fancyMarker = parseFancyListMarker(line);
        if (fancyMarker) {
          if (settings.strictPandocMode && lines2.length > 0) {
            let lineNum = -1;
            for (let i = 0; i < lines2.length; i++) {
              if (lines2[i].includes(line.trim())) {
                lineNum = i;
                break;
              }
            }
            if (lineNum >= 0) {
              const validationContext = {
                lines: lines2,
                currentLine: lineNum
              };
              if (!isStrictPandocList(validationContext, settings.strictPandocMode)) {
                newElements.push(document.createTextNode(line));
                return;
              }
            }
          }
          const span = document.createElement("span");
          span.className = `pandoc-list-${fancyMarker.type}`;
          span.textContent = fancyMarker.marker + " ";
          newElements.push(span);
          const rest = line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const exampleMarker = parseExampleListMarker(line);
        if (exampleMarker) {
          let number = 1;
          if (exampleMarker.label && exampleMap.has(exampleMarker.label)) {
            number = exampleMap.get(exampleMarker.label);
          }
          const span = document.createElement("span");
          span.className = "pandoc-example-list";
          span.textContent = `(${number}) `;
          newElements.push(span);
          const rest = line.substring(exampleMarker.indent.length + exampleMarker.originalMarker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const defMarker = parseDefinitionListMarker(line);
        if (defMarker && defMarker.type === "definition") {
          const span = document.createElement("span");
          span.textContent = "\u2022 ";
          newElements.push(span);
          newElements.push(document.createTextNode(defMarker.content));
          return;
        } else if (isDefinitionTerm && line.trim() && !line.match(/^(\s*)[~:]\s+/)) {
          const strong = document.createElement("strong");
          const u = document.createElement("u");
          u.textContent = line;
          strong.appendChild(u);
          newElements.push(strong);
          return;
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let lastIndex = 0;
        let match;
        let hasReferences = false;
        while ((match = refRegex.exec(line)) !== null) {
          hasReferences = true;
          if (match.index > lastIndex) {
            newElements.push(document.createTextNode(line.substring(lastIndex, match.index)));
          }
          const label = match[1];
          if (exampleMap.has(label)) {
            const span = document.createElement("span");
            span.className = "pandoc-example-reference";
            span.textContent = `(${exampleMap.get(label)})`;
            newElements.push(span);
          } else {
            newElements.push(document.createTextNode(match[0]));
          }
          lastIndex = match.index + match[0].length;
        }
        if (hasReferences && lastIndex < line.length) {
          newElements.push(document.createTextNode(line.substring(lastIndex)));
        } else if (!hasReferences) {
          newElements.push(document.createTextNode(line));
        }
      });
      if (newElements.length > 0) {
        newElements.forEach((elem2) => {
          parent.insertBefore(elem2, node);
        });
        parent.removeChild(node);
      }
    });
  });
}

// src/ExampleReferenceSuggestFixed.ts
var import_obsidian2 = require("obsidian");
var ExampleReferenceSuggestFixed = class extends import_obsidian2.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = [...line.matchAll(/\(@/g)];
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = line.match(/^\s*\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/);
      if (match) {
        const label = match[1];
        const text = match[2].trim();
        if (!exampleData.has(label)) {
          exampleData.set(label, { number: counter, text });
        }
        counter++;
      } else if (line.match(/^\s*\(@\)\s+/)) {
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: "pandoc-suggestion-content" });
    const title = container.createDiv({ cls: "pandoc-suggestion-title" });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: "pandoc-suggestion-preview" });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  strictPandocMode: false
};
var PandocListsSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Pandoc lists settings" });
    new import_obsidian3.Setting(containerEl).setName("Strict pandoc mode").setDesc("Enable strict pandoc formatting requirements. When enabled, lists must have empty lines before and after them, and capital letter lists require double spacing after markers.").addToggle((toggle) => toggle.setValue(this.plugin.settings.strictPandocMode).onChange(async (value) => {
      this.plugin.settings.strictPandocMode = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/main.ts
var PandocListsPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PandocListsSettingTab(this.app, this));
    this.registerEditorExtension(pandocListsExtension(() => this.settings));
    this.registerMarkdownPostProcessor((element, context) => {
      processReadingMode(element, context, this.settings);
    });
    this.suggester = new ExampleReferenceSuggestFixed(this);
    this.registerEditorSuggest(this.suggester);
    this.addCommand({
      id: "check-pandoc-formatting",
      name: "Check pandoc formatting",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const issues = checkPandocFormatting(content);
        if (issues.length === 0) {
          new import_obsidian4.Notice("Document follows pandoc formatting standards");
        } else {
          const issueList = issues.map(
            (issue) => `Line ${issue.line}: ${issue.message}`
          ).join("\n");
          new import_obsidian4.Notice(`Found ${issues.length} formatting issues:
${issueList}`, 1e4);
        }
      }
    });
    this.addCommand({
      id: "format-to-pandoc",
      name: "Format document to pandoc standard",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const formatted = formatToPandocStandard(content);
        if (content !== formatted) {
          editor.setValue(formatted);
          new import_obsidian4.Notice("Document formatted to pandoc standard");
        } else {
          new import_obsidian4.Notice("Document already follows pandoc standard");
        }
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
