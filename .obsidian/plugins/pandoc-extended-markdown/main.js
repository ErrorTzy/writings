/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/main.ts
var main_exports = {};
__export(main_exports, {
  PandocExtendedMarkdownPlugin: () => PandocExtendedMarkdownPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian15 = require("obsidian");
var import_state8 = require("@codemirror/state");
var import_view14 = require("@codemirror/view");

// src/core/settings.ts
var import_obsidian7 = require("obsidian");

// src/shared/types/settingsTypes.ts
var DEFAULT_SETTINGS = {
  strictPandocMode: false,
  autoRenumberLists: false,
  moreExtendedSyntax: false,
  panelOrder: ["custom-labels", "example-lists", "definition-lists", "footnotes"]
};

// src/core/constants/listConstants.ts
var LIST_MARKERS = {
  DEFINITION_COLON: ":",
  DEFINITION_TILDE: "~",
  EXAMPLE_START: "(@",
  EXAMPLE_END: ")",
  EXAMPLE_FULL: "(@)",
  HASH_NUMBERED: "#.",
  CUSTOM_LABEL_FULL: "{::}",
  UNORDERED_DASH: "-",
  UNORDERED_STAR: "*",
  UNORDERED_PLUS: "+"
};
var LIST_TYPES = {
  HASH: "hash",
  CUSTOM_LABEL: "custom-label",
  EXAMPLE: "example",
  DEFINITION: "definition",
  UNKNOWN: "unknown",
  ROMAN: "roman",
  LETTER: "letter"
};
var INDENTATION = {
  TAB_SIZE: 4,
  MIN_INDENT: 0,
  MAX_INDENT: 40,
  SINGLE_SPACE: 1,
  DOUBLE_SPACE: 2,
  TAB: "	",
  FOUR_SPACES: "    ",
  CONTINUATION_MIN_VISUAL: 3
};

// src/core/constants/cssConstants.ts
var CSS_CLASSES = {
  // Fancy List Classes
  FANCY_LIST: "pandoc-list-fancy",
  FANCY_LIST_UPPER_ALPHA: "pandoc-list-upper-alpha",
  FANCY_LIST_LOWER_ALPHA: "pandoc-list-lower-alpha",
  FANCY_LIST_UPPER_ROMAN: "pandoc-list-upper-roman",
  FANCY_LIST_LOWER_ROMAN: "pandoc-list-lower-roman",
  FANCY_LIST_PAREN: "pandoc-list-paren",
  // Definition List Classes
  DEFINITION_LIST: "pandoc-definition-list",
  DEFINITION_TERM: "pandoc-definition-term",
  DEFINITION_DESC: "pandoc-list-definition-desc",
  DEFINITION_ITEMS: "pandoc-definition-items",
  DEFINITION_CONTENT_TEXT: "pandoc-definition-content-text",
  // Example List Classes
  EXAMPLE_REF: "pandoc-example-reference",
  EXAMPLE_LIST: "pandoc-example-list",
  EXAMPLE_ITEM: "pandoc-example-item",
  DUPLICATE_MARKERS: "pandoc-duplicate-markers",
  // Superscript and Subscript Classes
  SUPERSCRIPT: "pandoc-superscript",
  SUBSCRIPT: "pandoc-subscript",
  // Suggestion Classes
  SUGGESTION_CONTENT: "pandoc-suggestion-content",
  SUGGESTION_TITLE: "pandoc-suggestion-title",
  SUGGESTION_PREVIEW: "pandoc-suggestion-preview",
  SUGGESTION_NUMBER: "pandoc-suggestion-number",
  SUGGESTION_PLACEHOLDER: "pandoc-suggestion-placeholder",
  // CodeMirror Classes
  LIST_LINE: "HyperMD-list-line",
  LIST_LINE_1: "HyperMD-list-line-1",
  LIST_LINE_2: "HyperMD-list-line-2",
  LIST_LINE_3: "HyperMD-list-line-3",
  LIST_LINE_4: "HyperMD-list-line-4",
  LIST_LINE_NOBULLET: "HyperMD-list-line-nobullet",
  CM_LIST_1: "cm-list-1",
  CM_LIST_2: "cm-list-2",
  CM_LIST_3: "cm-list-3",
  CM_FORMATTING: "cm-formatting",
  CM_FORMATTING_LIST: "cm-formatting-list",
  CM_FORMATTING_LIST_OL: "cm-formatting-list-ol",
  CM_FORMATTING_LIST_UL: "cm-formatting-list-ul",
  LIST_NUMBER: "list-number",
  DEFINITION_TERM_DECORATION: "cm-pandoc-definition-term",
  DEFINITION_PARAGRAPH: "cm-pandoc-definition-paragraph",
  // Generic Classes
  PANDOC_LIST_MARKER: "pandoc-list-marker",
  PANDOC_LIST_LINE_INDENT: "pandoc-list-line-indent",
  PANDOC_LIST_LINE: "pandoc-list-line",
  DEFINITION_MARKER_CURSOR: "cm-pandoc-definition-marker-cursor",
  LIST_CONTINUATION_WIDGET: "pandoc-list-continuation-widget",
  // Custom Label Classes
  CUSTOM_LABEL_PROCESSED: "pandoc-custom-label-processed",
  CUSTOM_LABEL_ITEM: "pandoc-custom-label-item",
  CUSTOM_LABEL_REFERENCE_PROCESSED: "pandoc-custom-label-reference-processed",
  CUSTOM_LABEL_REF_CLICKABLE: "pandoc-custom-label-ref-clickable",
  CUSTOM_LABEL_PLACEHOLDER: "pandoc-custom-label-placeholder",
  INLINE_PLACEHOLDER_NUMBER: "pandoc-inline-placeholder-number",
  CUSTOM_LABEL_MARKER: "pandoc-custom-label-marker",
  CUSTOM_LABEL_BRACKET: "pandoc-custom-label-bracket",
  CUSTOM_LABEL_TEXT: "pandoc-custom-label-text",
  // Custom Label View Classes
  CUSTOM_LABEL_VIEW_CONTAINER: "custom-label-view-container",
  CUSTOM_LABEL_VIEW_HEADER: "custom-label-view-header",
  CUSTOM_LABEL_VIEW_HEADER_LABEL: "custom-label-view-header-label",
  CUSTOM_LABEL_VIEW_HEADER_CONTENT: "custom-label-view-header-content",
  CUSTOM_LABEL_VIEW_ROW: "custom-label-view-row",
  CUSTOM_LABEL_VIEW_LABEL: "custom-label-view-label",
  CUSTOM_LABEL_VIEW_CONTENT: "custom-label-view-content",
  CUSTOM_LABEL_VIEW_EMPTY: "custom-label-view-empty",
  CUSTOM_LABEL_HOVER_PREVIEW: "custom-label-hover-preview",
  CUSTOM_LABEL_HIGHLIGHT: "custom-label-highlight",
  // Hover popover styles
  HOVER_POPOVER: "pandoc-hover-popover",
  HOVER_POPOVER_LABEL: "pandoc-hover-popover-label",
  HOVER_POPOVER_CONTENT: "pandoc-hover-popover-content",
  HOVER_POPOVER_POSITIONED: "pandoc-hover-popover-positioned",
  // List Panel View Classes
  LIST_PANEL_VIEW_CONTAINER: "pandoc-list-panel-view-container",
  LIST_PANEL_ICON_ROW: "pandoc-list-panel-icon-row",
  LIST_PANEL_ICON_BUTTON: "pandoc-list-panel-icon-button",
  LIST_PANEL_ICON_CONTAINER: "pandoc-panel-icon-container",
  LIST_PANEL_ICON_CUSTOM_LABEL: "pandoc-icon-custom-label",
  LIST_PANEL_ICON_EXAMPLE_LIST: "pandoc-icon-example-list",
  LIST_PANEL_ICON_FOOTNOTE: "pandoc-icon-footnote",
  LIST_PANEL_SEPARATOR: "pandoc-list-panel-separator",
  LIST_PANEL_CONTENT_CONTAINER: "pandoc-list-panel-content-container",
  LIST_PANEL_ICON_ACTIVE: "is-active",
  // Example List View Classes
  EXAMPLE_LIST_VIEW_CONTAINER: "pandoc-example-list-view-container",
  EXAMPLE_LIST_VIEW_ROW: "pandoc-example-list-view-row",
  EXAMPLE_LIST_VIEW_NUMBER: "pandoc-example-list-view-number",
  EXAMPLE_LIST_VIEW_LABEL: "pandoc-example-list-view-label",
  EXAMPLE_LIST_VIEW_CONTENT: "pandoc-example-list-view-content",
  EXAMPLE_LIST_VIEW_EMPTY: "pandoc-example-list-view-empty",
  // Definition List View Classes
  DEFINITION_LIST_VIEW_CONTAINER: "pandoc-definition-list-view-container",
  DEFINITION_LIST_VIEW_ROW: "pandoc-definition-list-view-row",
  DEFINITION_LIST_VIEW_TERM: "pandoc-definition-list-view-term",
  DEFINITION_LIST_VIEW_DEFINITIONS: "pandoc-definition-list-view-definitions",
  DEFINITION_LIST_VIEW_EMPTY: "pandoc-definition-list-view-empty",
  // Footnote Panel View Classes
  FOOTNOTE_PANEL_CONTAINER: "pandoc-footnote-panel-container",
  FOOTNOTE_PANEL_ROW: "pandoc-footnote-panel-row",
  FOOTNOTE_PANEL_INDEX: "pandoc-footnote-panel-index",
  FOOTNOTE_PANEL_CONTENT: "pandoc-footnote-panel-content",
  FOOTNOTE_PANEL_EMPTY: "pandoc-footnote-panel-empty"
};
var COMPOSITE_CSS = {
  // Standard formatting for list markers in widgets
  STANDARD_LIST_MARKER_CLASSES: `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`
};
var DECORATION_STYLES = {
  HASH_LIST_INDENT: 29,
  EXAMPLE_LIST_INDENT: 35,
  FANCY_LIST_INDENT_MULTIPLIER: 7,
  CONTINUATION_INDENT_UNIT_PX: 6,
  LINE_TRUNCATION_LIMIT: 100,
  TOOLTIP_DELAY_MS: 300,
  CUSTOM_LABEL_PREFIX_LENGTH: 3
  // Length of "{::" prefix
};

// src/core/constants.ts
var MESSAGES = {
  // Success messages
  FORMAT_SUCCESS: "Document formatted to pandoc standard",
  FORMAT_ALREADY_COMPLIANT: "Document already follows pandoc standard",
  PANDOC_COMPLIANT: "Document follows pandoc formatting standards",
  TOGGLE_BOLD_SUCCESS: "Definition terms bold style toggled",
  TOGGLE_UNDERLINE_SUCCESS: "Definition terms underline style toggled",
  LABEL_COPIED: "Label copied to clipboard",
  // Error messages
  NO_DEFINITION_TERMS: "No definition terms found to toggle",
  // View messages
  NO_ACTIVE_FILE: "No active file",
  NO_CUSTOM_LABELS: "No custom labels found",
  NO_EXAMPLE_LISTS: "No example lists found",
  NO_DEFINITION_LISTS: "No definition lists found",
  NO_FOOTNOTES: "No footnotes found",
  FOOTNOTE_REFERENCE_NOT_FOUND: "No matching footnote reference found",
  CUSTOM_LABELS_VIEW_TITLE: "Custom Labels",
  EXAMPLE_LISTS_VIEW_TITLE: "Example Lists",
  DEFINITION_LISTS_VIEW_TITLE: "Definition Lists",
  FOOTNOTE_VIEW_TITLE: "Footnotes",
  // Formatting issue messages
  FORMATTING_ISSUES: (count) => `Found ${count} formatting issues`
};
var COMMANDS = {
  CHECK_PANDOC: "check-pandoc-formatting",
  FORMAT_PANDOC: "format-to-pandoc-standard",
  TOGGLE_DEFINITION_BOLD: "toggle-definition-bold-style",
  TOGGLE_DEFINITION_UNDERLINE: "toggle-definition-underline-style",
  OPEN_LIST_PANEL: "open-list-panel"
};
var UI_CONSTANTS = {
  NOTICE_DURATION_MS: 1e4,
  STATE_TRANSITION_DELAY_MS: 100,
  HIGHLIGHT_ANIMATION_DURATION_MS: 2e3,
  // Custom Label View
  LABEL_MAX_LENGTH: 6,
  LABEL_TRUNCATION_LENGTH: 5,
  // Length before adding ellipsis
  // Definition List View
  TERM_MAX_LENGTH: 100,
  TERM_TRUNCATION_LENGTH: 99,
  // Length before adding ellipsis
  DEFINITION_MAX_LENGTH: 300,
  DEFINITION_TRUNCATION_LENGTH: 299,
  // Length before adding ellipsis
  // Indentation
  MARKDOWN_INDENT_SIZE: 4,
  // Standard markdown indent for continuations
  // Icon dimensions
  PANEL_ICON_SIZE: 20,
  CONTENT_MAX_LENGTH: 51,
  CONTENT_TRUNCATION_LENGTH: 50,
  // Length before adding ellipsis
  CONTENT_TRUNCATE_LINES: 3,
  UPDATE_DEBOUNCE_MS: 300,
  SELECTION_CLEAR_DELAY_MS: 300,
  SELECTION_FADE_DELAY_MS: 100,
  HIGHLIGHT_DURATION_MS: 2e3,
  MAX_HOVER_WIDTH: "400px",
  MAX_HOVER_HEIGHT: "300px",
  HOVER_PADDING: "8px 12px",
  HOVER_Z_INDEX: "1000",
  // Hover positioning
  HOVER_OFFSET_BOTTOM: 5,
  HOVER_OFFSET_TOP: 5,
  HOVER_OFFSET_HORIZONTAL: 10,
  HOVER_CLEANUP_DELAY_MS: 100
};
var DOM_ATTRIBUTES = {
  CONTENT_EDITABLE_FALSE: "false",
  ELEMENT_DIV: "div",
  OVERFLOW_AUTO: "auto"
};
var MATH_SYMBOLS = {
  // LaTeX to Unicode mappings for math rendering
  LATEX_TO_UNICODE: {
    "\\therefore": "\u2234",
    "\\because": "\u2235",
    "\\alpha": "\u03B1",
    "\\beta": "\u03B2",
    "\\gamma": "\u03B3",
    "\\delta": "\u03B4",
    "\\epsilon": "\u03B5",
    "\\theta": "\u03B8",
    "\\lambda": "\u03BB",
    "\\mu": "\u03BC",
    "\\pi": "\u03C0",
    "\\sigma": "\u03C3",
    "\\phi": "\u03C6",
    "\\psi": "\u03C8",
    "\\omega": "\u03C9",
    "\\infty": "\u221E",
    "\\pm": "\xB1",
    "\\times": "\xD7",
    "\\div": "\xF7",
    "\\neq": "\u2260",
    "\\leq": "\u2264",
    "\\geq": "\u2265",
    "\\approx": "\u2248",
    "\\subset": "\u2282",
    "\\supset": "\u2283",
    "\\cup": "\u222A",
    "\\cap": "\u2229",
    "\\in": "\u2208",
    "\\notin": "\u2209",
    "\\exists": "\u2203",
    "\\forall": "\u2200",
    "\\land": "\u2227",
    "\\lor": "\u2228",
    "\\neg": "\xAC",
    "\\rightarrow": "\u2192",
    "\\leftarrow": "\u2190",
    "\\leftrightarrow": "\u2194",
    "\\Rightarrow": "\u21D2",
    "\\Leftarrow": "\u21D0",
    "\\Leftrightarrow": "\u21D4"
  }
};
var ICONS = {
  CUSTOM_LABEL_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <text x="50" y="50"
              text-anchor="middle"
              dominant-baseline="central"
              font-family="monospace"
              font-size="48"
              font-weight="bold"
              fill="currentColor">
            {::}
        </text>
    </svg>`,
  EXAMPLE_LIST_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <text x="50" y="50"
              text-anchor="middle"
              dominant-baseline="central"
              font-family="monospace"
              font-size="58"
              font-weight="bold"
              fill="currentColor">
            (@)
        </text>
    </svg>`,
  DEFINITION_LIST_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <g fill="currentColor" font-family="monospace" font-weight="bold">
            <text x="30" y="45" font-size="40" text-anchor="middle">DL</text>
            <text x="70" y="65" font-size="48" text-anchor="middle">:</text>
        </g>
    </svg>`,
  FOOTNOTE_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <text x="50" y="55"
              text-anchor="middle"
              dominant-baseline="central"
              font-family="monospace"
              font-size="56"
              font-weight="bold"
              fill="currentColor">
            [^]
        </text>
    </svg>`,
  LIST_PANEL_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <g fill="currentColor" font-family="monospace" font-weight="bold">
            <!-- 2x2 grid of Pandoc list markers for better visibility -->
            <!-- Top left: Roman numeral -->
            <text x="25" y="35" font-size="48" text-anchor="middle">i.</text>

            <!-- Top right: Letter with parenthesis -->
            <text x="75" y="35" font-size="48" text-anchor="middle">a)</text>

            <!-- Bottom left: Hash number -->
            <text x="25" y="75" font-size="48" text-anchor="middle">#.</text>

            <!-- Bottom right: Definition marker -->
            <text x="75" y="75" font-size="48" text-anchor="middle">~</text>
        </g>
    </svg>`,
  CUSTOM_LABEL_ID: "custom-label-list",
  LIST_PANEL_ID: "list-panel-view"
};
var PANEL_SETTINGS = {
  AVAILABLE_PANELS: [
    {
      id: "custom-labels",
      displayName: "Custom Label List Panel",
      icon: ICONS.CUSTOM_LABEL_SVG
    },
    {
      id: "example-lists",
      displayName: "Example List Panel",
      icon: ICONS.EXAMPLE_LIST_SVG
    },
    {
      id: "definition-lists",
      displayName: "Definition Lists",
      icon: ICONS.DEFINITION_LIST_SVG
    },
    {
      id: "footnotes",
      displayName: "Footnotes",
      icon: ICONS.FOOTNOTE_SVG
    }
  ],
  UI_TEXT: {
    PANEL_ORDER_HEADING: "Panel Order",
    PANEL_ORDER_DESC: "Select a panel and use the buttons to change its order in the sidebar",
    BTN_MOVE_UP: "Move up",
    BTN_MOVE_DOWN: "Move down",
    BTN_MOVE_TOP: "Move to top",
    BTN_MOVE_BOTTOM: "Move to bottom",
    BTN_RESTORE_DEFAULT: "Restore to Default"
  }
};
var ERROR_MESSAGES = {
  PLUGIN_PREFIX: "Pandoc Extended Markdown",
  UNEXPECTED_ERROR: "An unexpected error occurred",
  PARSE_FAILED: "failed",
  COPY_FAILED: "Failed to copy label",
  HIGHLIGHT_ERROR: "Error highlighting line",
  SCROLL_ERROR: "Error scrolling to label",
  WIDGET_CREATION_ERROR: "Failed to create definition widget",
  DECORATION_ERROR: "Failed to add decoration",
  INVALID_POSITION: "Invalid decoration position",
  INVALID_MARKER_POSITION: "Invalid marker positions for definition"
};
var NUMERIC_CONSTANTS = {
  // Document validation
  MIN_DOC_POSITION: 0,
  // Position validation
  POSITION_TOLERANCE: 0,
  // Line processing
  LINE_PROCESSING_BATCH_SIZE: 100,
  // Content limits
  MAX_CONTENT_LENGTH: 1e3,
  MAX_LABEL_LENGTH: 100,
  // Timer intervals
  DEBOUNCE_INTERVAL_MS: 100,
  SELECTION_TIMEOUT_MS: 50,
  // Character limits
  SINGLE_CHARACTER: 1,
  EMPTY_LENGTH: 0,
  // Array indices
  FIRST_INDEX: 0,
  SECOND_INDEX: 1,
  THIRD_INDEX: 2,
  // List processing
  LIST_NESTING_LEVEL: 1,
  MAX_NESTING_DEPTH: 10
};
var TEXT_PROCESSING = {
  // Preview truncation
  PREVIEW_TRUNCATE_LENGTH: 30,
  PREVIEW_ELLIPSIS: "...",
  // Tab/space conversion
  TAB_EQUIVALENT_SPACES: 4,
  // Content extraction
  MIN_CONTENT_LENGTH: 1,
  // Text formatting
  LINE_SEPARATOR: "\n",
  SPACE_CHARACTER: " "
};
var FILE_CONSTANTS = {
  EXTENSION_TS: ".ts",
  EXTENSION_MD: ".md",
  PATH_SEPARATOR: "/",
  EMPTY_STRING: "",
  SPACE: " ",
  NEWLINE: "\n",
  TAB_CHARACTER: "	"
};
var ROMAN_NUMERALS = {
  VALUES: {
    "i": 1,
    "iv": 4,
    "v": 5,
    "ix": 9,
    "x": 10,
    "xl": 40,
    "l": 50,
    "xc": 90,
    "c": 100,
    "cd": 400,
    "d": 500,
    "cm": 900,
    "m": 1e3,
    "I": 1,
    "IV": 4,
    "V": 5,
    "IX": 9,
    "X": 10,
    "XL": 40,
    "L": 50,
    "XC": 90,
    "C": 100,
    "CD": 400,
    "D": 500,
    "CM": 900,
    "M": 1e3
  },
  TO_ROMAN_UPPER: [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ],
  TO_ROMAN_LOWER: [
    [1e3, "m"],
    [900, "cm"],
    [500, "d"],
    [400, "cd"],
    [100, "c"],
    [90, "xc"],
    [50, "l"],
    [40, "xl"],
    [10, "x"],
    [9, "ix"],
    [5, "v"],
    [4, "iv"],
    [1, "i"]
  ]
};

// src/views/panels/ListPanelView.ts
var import_obsidian6 = require("obsidian");

// src/shared/utils/errorHandler.ts
var import_obsidian = require("obsidian");
var PluginError = class extends Error {
  constructor(message, code, recoverable = true) {
    super(message);
    this.code = code;
    this.recoverable = recoverable;
    this.name = "PandocExtendedMarkdownPluginError";
  }
};
function withErrorBoundary(fn, fallback, context) {
  try {
    return fn();
  } catch (error) {
    handleError(error, context);
    return fallback;
  }
}
async function withAsyncErrorBoundary(fn, fallback, context) {
  try {
    return await fn();
  } catch (error) {
    handleError(error, context);
    return fallback;
  }
}
function handleError(error, context) {
  let message = ERROR_MESSAGES.UNEXPECTED_ERROR;
  let showNotice = true;
  if (error instanceof PluginError) {
    message = error.message;
    showNotice = error.recoverable;
    if (!error.recoverable) {
      throw error;
    }
  } else if (error instanceof Error) {
    message = error.message;
  } else if (typeof error === "string") {
    message = error;
  }
  if (showNotice) {
    new import_obsidian.Notice(`${ERROR_MESSAGES.PLUGIN_PREFIX}: ${context} ${ERROR_MESSAGES.PARSE_FAILED}. ${message}`);
  }
}

// src/shared/patterns.ts
var ListPatterns = class {
  // Note: Patterns are already compiled as static readonly RegExp objects,
  // providing optimal performance without needing additional caching.
  /**
   * Test if a line matches a hash list pattern.
   */
  static isHashList(line) {
    return line.match(this.HASH_LIST);
  }
  /**
   * Test if a line matches a fancy list pattern.
   */
  static isFancyList(line) {
    const match = line.match(this.FANCY_LIST);
    if (match && !line.match(this.NUMBERED_LIST)) {
      return match;
    }
    return null;
  }
  /**
   * Test if a line matches an example list pattern.
   */
  static isExampleList(line) {
    return line.match(this.EXAMPLE_LIST);
  }
  /**
   * Test if a line matches a definition marker pattern.
   */
  static isDefinitionMarker(line) {
    return line.match(this.DEFINITION_MARKER);
  }
  /**
   * Test if a line is indented (for definition list content).
   */
  static isIndentedContent(line) {
    return this.DEFINITION_INDENTED.test(line);
  }
  /**
   * Find all example references in a text.
   */
  static findExampleReferences(text) {
    const matches = [];
    const regex = new RegExp(this.EXAMPLE_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Check if a string is a roman numeral.
   */
  static isRomanNumeral(str) {
    return this.ROMAN_NUMERALS.test(str) || this.LOWER_ROMAN_NUMERALS.test(str);
  }
  /**
   * Check if a line is any type of list item.
   */
  static isListItem(line) {
    return !!(this.isHashList(line) || this.isFancyList(line) || this.isExampleList(line) || this.isDefinitionMarker(line) || line.match(this.UNORDERED_LIST) || line.match(this.NUMBERED_LIST));
  }
  /**
   * Find all superscripts in a text.
   */
  static findSuperscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUPERSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Find all subscripts in a text.
   */
  static findSubscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUBSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line matches a custom label list pattern.
   */
  static isCustomLabelList(line) {
    return line.match(this.CUSTOM_LABEL_LIST);
  }
  /**
   * Test if a label is valid for custom label lists.
   */
  static isValidCustomLabel(label) {
    return this.VALID_CUSTOM_LABEL.test(label);
  }
  /**
   * Find all custom label references in a text.
   */
  static findCustomLabelReferences(text) {
    const matches = [];
    const regex = new RegExp(this.CUSTOM_LABEL_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line is a heading.
   */
  static isHeading(line) {
    return this.HEADING.test(line);
  }
  /**
   * Test if text might be a definition term (not a marker or indented).
   */
  static isDefinitionTerm(line) {
    const trimmed = line.trim();
    return trimmed !== "" && !this.isDefinitionMarker(trimmed) && !this.isIndentedContent(line);
  }
  /**
   * Extract letter and delimiter from a fancy list marker.
   */
  static extractLetterMarker(marker) {
    return marker.match(this.LETTER_MARKER_PATTERN);
  }
  /**
   * Extract roman numeral and delimiter from a fancy list marker.
   */
  static extractRomanMarker(marker) {
    return marker.match(this.ROMAN_MARKER_PATTERN);
  }
  /**
   * Check if text starts with a formatting marker.
   */
  static startsWithFormatting(text) {
    return this.FORMATTING_MARKER_START.test(text);
  }
  /**
   * Remove trailing quotes from text.
   */
  static removeTrailingQuotes(text) {
    return text.replace(this.TRAILING_QUOTES, "");
  }
  /**
   * Clean up whitespace and formatting in mathematical expressions.
   */
  static cleanMathExpression(text) {
    return text.replace(this.BACKSLASH_ESCAPE, "").replace(this.WHITESPACE_CLEANUP, " ").trim();
  }
  /**
   * Clean up whitespace before dollar signs in LaTeX.
   */
  static cleanWhitespaceBeforeDollar(content) {
    return content.replace(this.WHITESPACE_DOLLAR_CLEANUP, "$");
  }
  /**
   * Replace placeholder letters with values.
   */
  static replacePlaceholderLetters(label, replaceFn) {
    return label.replace(this.PLACEHOLDER_LETTER_PATTERN, replaceFn);
  }
  /**
   * Get indent from a line.
   */
  static getIndent(line) {
    const match = line.match(this.INDENT_ONLY);
    return match ? match[1] : "";
  }
  /**
   * Replace escaped spaces with regular spaces.
   */
  static unescapeSpaces(text) {
    return text.replace(this.ESCAPED_SPACE, " ");
  }
  /**
   * Find all example reference starts in text.
   */
  static findExampleRefStarts(text) {
    return [...text.matchAll(this.EXAMPLE_REF_START)];
  }
  /**
   * Find all custom label reference starts in text.
   */
  static findCustomLabelRefStarts(text) {
    return [...text.matchAll(this.CUSTOM_LABEL_REF_START)];
  }
  /**
   * Split text by inline formatting markers.
   */
  static splitByInlineFormatting(text) {
    return text.split(this.INLINE_FORMATTING_SPLIT);
  }
};
// Base patterns as static readonly properties
ListPatterns.HASH_LIST = /^(\s*)(#\.)(\s+)/;
ListPatterns.FANCY_LIST = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/;
ListPatterns.EXAMPLE_LIST = /^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/;
ListPatterns.EXAMPLE_LIST_WITH_CONTENT = /^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/;
ListPatterns.EXAMPLE_REFERENCE = /\(@([a-zA-Z0-9_-]+)\)/g;
ListPatterns.DEFINITION_MARKER = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_MARKER_WITH_INDENT = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_INDENTED = /^(    |\t)/;
ListPatterns.DEFINITION_INDENTED_WITH_CONTENT = /^(    |\t)(.*)$/;
ListPatterns.DEFINITION_TERM_PATTERN = /^([^\n:~]+)$/;
ListPatterns.FOOTNOTE_DEFINITION = /^\[\^([^\]]+)\]:\s*(.*)$/;
ListPatterns.FOOTNOTE_CONTINUATION = /^( {4,}|\t+)(.*)$/;
ListPatterns.FOOTNOTE_REFERENCE = /\[\^([^\]]+)\]/g;
ListPatterns.NUMBERED_LIST = /^(\s*)([0-9]+[.)])/;
ListPatterns.UNORDERED_LIST = /^(\s*)[-*+]\s+/;
ListPatterns.CAPITAL_LETTER_LIST = /^(\s*)([A-Z])(\.)(\s+)/;
// Additional list patterns for validation
ListPatterns.STANDARD_ORDERED_LIST = /^(\s*)\d+\.\s+/;
ListPatterns.CAPITAL_LETTER_REPLACE = /^(\s*)([A-Z]\.)(\s+)/;
ListPatterns.UNLABELED_EXAMPLE_LIST = /^(\s*)\(@\)\s+/;
// Combined fancy list pattern for validation (includes numbers)
ListPatterns.FANCY_LIST_WITH_NUMBERS = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|[0-9]+|#)([.)]))(\s+)/;
ListPatterns.ROMAN_NUMERALS = /^[IVXLCDM]+$/;
ListPatterns.LOWER_ROMAN_NUMERALS = /^[ivxlcdm]+$/;
// Character type patterns for fancy list parsing
ListPatterns.ROMAN_UPPER = /^[IVXLCDM]+$/;
ListPatterns.ROMAN_LOWER = /^[ivxlcdm]+$/;
ListPatterns.ALPHA_UPPER = /^[A-Z]+$/;
ListPatterns.ALPHA_LOWER = /^[a-z]+$/;
ListPatterns.DECIMAL = /^[0-9]+$/;
// Code block detection patterns
ListPatterns.CODE_BLOCK_FENCE = /^(```|~~~).*$/gm;
// Autocompletion patterns
ListPatterns.LETTER_OR_ROMAN_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)(.*)$/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)(.*)$/;
ListPatterns.VALID_ROMAN_NUMERAL = /^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i;
ListPatterns.SINGLE_I = /^[Ii]$/;
ListPatterns.SINGLE_H = /^[Hh]$/;
ListPatterns.SINGLE_AB = /^[ABab]$/;
ListPatterns.SINGLE_ROMAN_CHAR = /^[IVXLCDM]$/i;
ListPatterns.ANY_ROMAN_CHARS = /^[ivxlcdmIVXLCDM]+$/i;
ListPatterns.ALPHABETIC_CHARS = /^[A-Za-z]+$/;
ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)/;
ListPatterns.NUMBERED_LIST_WITH_SPACE = /^\s*\d+[.)]\s/;
ListPatterns.DEFINITION_MARKER_ONLY = /^[~:]$/;
// Empty list item patterns
ListPatterns.EMPTY_HASH_LIST = /^(\s*)(#\.)(\s*)$/;
ListPatterns.EMPTY_FANCY_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL = /^(\s*)\(@\)(\s*)$/;
ListPatterns.EMPTY_DEFINITION_LIST = /^(\s*)([~:])(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST = /^(\s*)(\{::([a-zA-Z][a-zA-Z0-9_']*)*\})(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL = /^(\s*)(\{::\})(\s*)$/;
// Complex list patterns for autocompletion
ListPatterns.ANY_LIST_MARKER = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})/;
ListPatterns.ANY_LIST_MARKER_WITH_SPACE = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE = /^(\s+)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
// Indentation patterns
ListPatterns.INDENT_ONLY = /^(\s*)/;
// Text formatting patterns
ListPatterns.BOLD_TEXT = /^\*\*(.+)\*\*$/;
ListPatterns.UNDERLINE_SPAN = /^<span class="underline">(.+)<\/span>$/;
// Inline formatting patterns for parsing
ListPatterns.INLINE_FORMATTING_SPLIT = /(__(.+?)__|\*\*(.+?)\*\*|_(.+?)_|\*(.+?)\*|`(.+?)`)/g;
// Escaped space pattern
ListPatterns.ESCAPED_SPACE = /\\[ ]/g;
// Example reference start pattern (for autocomplete)
ListPatterns.EXAMPLE_REF_START = /\(@/g;
// Custom label reference start pattern (for autocomplete)
ListPatterns.CUSTOM_LABEL_REF_START = /\{::/g;
// Heading patterns
ListPatterns.HEADING = /^#{1,6}\s+/;
ListPatterns.HEADING_WITH_CONTENT = /^(#{1,6})\s+(.*)$/;
// Superscript and subscript patterns
// Matches ^text^ for superscript and ~text~ for subscript
// Text can contain escaped spaces (\ ) but not unescaped spaces
ListPatterns.SUPERSCRIPT = /\^([^\^\s]|\\[ ])+?\^/g;
ListPatterns.SUBSCRIPT = /~([^~\s]|\\[ ])+?~/g;
/**
 * Inline superscript pattern for inline processors.
 * Excludes $ character to prevent matching across LaTeX math boundaries,
 * ensuring math expressions like $R^{+}_{xy}$ remain intact.
 * Excludes [ and ] to prevent matching footnote syntax like [^1].
 */
ListPatterns.SUPERSCRIPT_INLINE = /\^([^^~\s$\[\]]+(?:\s+[^^~\s$\[\]]+)*)\^/g;
/**
 * Inline subscript pattern for inline processors.
 * Excludes $ character to prevent matching across LaTeX math boundaries,
 * ensuring math expressions remain properly formatted.
 * Excludes [ and ] to prevent matching patterns that might conflict with brackets.
 */
ListPatterns.SUBSCRIPT_INLINE = /~([^~^\s$\[\]]+(?:\s+[^~^\s$\[\]]+)*)~/g;
// Custom label list patterns for More Extended Syntax
// Matches {::LABEL} at start of line with required space after
// Now supports placeholders like {::P(#first)} or pure placeholders like {::(#name)}
ListPatterns.CUSTOM_LABEL_LIST = /^(\s*)(\{::([^}]+)\})(\s+)/;
ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT = /^(\s*)(\{::([^}]+)\})(\s+)(.*)$/;
// Reference to custom label anywhere in text
ListPatterns.CUSTOM_LABEL_REFERENCE = /\{::([^}]+)\}/g;
// Valid label pattern (for validation) - now accepts any non-empty content
ListPatterns.VALID_CUSTOM_LABEL = /^[^}]+$/;
// Simple valid label pattern for validation
ListPatterns.VALID_CUSTOM_LABEL_SIMPLE = /^[a-zA-Z][a-zA-Z0-9_']*$/;
// Placeholder pattern for auto-numbering
ListPatterns.PLACEHOLDER_PATTERN = /\(#([^)]+)\)/g;
// Pure expression pattern for validation
ListPatterns.PURE_EXPRESSION_PATTERN = /^[A-Za-z]?[\s+\-*/,()'\d]*$/;
// Trailing digits pattern for custom label processing
ListPatterns.TRAILING_DIGITS = /\d+$/;
// Custom label placeholder pattern for inline matching
ListPatterns.CUSTOM_LABEL_PLACEHOLDER = /\(#([^)]+)\)/g;
// Additional inline patterns
ListPatterns.TRAILING_QUOTES = /'+$/;
ListPatterns.BACKSLASH_ESCAPE = /\\/g;
ListPatterns.WHITESPACE_CLEANUP = /\s+/g;
ListPatterns.LETTER_MARKER_PATTERN = /^([A-Za-z]+)([.)])$/;
ListPatterns.ROMAN_MARKER_PATTERN = /^([ivxlcdmIVXLCDM]+)([.)])$/;
ListPatterns.PLACEHOLDER_LETTER_PATTERN = /\(#([a-z])\)/g;
ListPatterns.WHITESPACE_DOLLAR_CLEANUP = /\s+\$/g;
ListPatterns.FORMATTING_MARKER_START = /^(\*\*|__|\*|_|`)/;

// src/shared/utils/placeholderProcessor.ts
var PlaceholderContext = class {
  constructor() {
    this.placeholderMap = /* @__PURE__ */ new Map();
    this.nextNumber = 1;
    this.processedLabels = /* @__PURE__ */ new Map();
    this.definedLabels = /* @__PURE__ */ new Set();
  }
  // Track which labels are actually defined
  /**
   * Process a label with placeholders, maintaining consistent numbering.
   * 
   * @param rawLabel - The raw label with placeholders
   * @returns The processed label with numbers
   */
  processLabel(rawLabel) {
    if (this.processedLabels.has(rawLabel)) {
      return this.processedLabels.get(rawLabel);
    }
    const processedLabel = rawLabel.replace(ListPatterns.PLACEHOLDER_PATTERN, (match, name) => {
      if (!this.placeholderMap.has(name)) {
        this.placeholderMap.set(name, this.nextNumber++);
      }
      return this.placeholderMap.get(name).toString();
    });
    this.processedLabels.set(rawLabel, processedLabel);
    this.definedLabels.add(processedLabel);
    return processedLabel;
  }
  /**
   * Get the number assigned to a placeholder name.
   * 
   * @param name - The placeholder name
   * @returns The assigned number, or null if not found
   */
  getPlaceholderNumber(name) {
    return this.placeholderMap.get(name) || null;
  }
  /**
   * Get the processed version of a label without modifying state.
   * Used for references to existing labels.
   * 
   * A label reference is valid if:
   * 1. It doesn't contain placeholders and has been defined before, OR
   * 2. It contains placeholders that have all appeared in previous list labels
   * 
   * @param rawLabel - The raw label to look up
   * @returns The processed label if valid, null if invalid
   */
  getProcessedLabel(rawLabel) {
    if (this.processedLabels.has(rawLabel)) {
      return this.processedLabels.get(rawLabel);
    }
    let allPlaceholdersKnown = true;
    const matches = [...rawLabel.matchAll(ListPatterns.PLACEHOLDER_PATTERN)];
    for (const match of matches) {
      if (!this.placeholderMap.has(match[1])) {
        allPlaceholdersKnown = false;
        break;
      }
    }
    if (!allPlaceholdersKnown && matches.length > 0) {
      return null;
    }
    const processedLabel = rawLabel.replace(ListPatterns.PLACEHOLDER_PATTERN, (match, name) => {
      var _a;
      return ((_a = this.placeholderMap.get(name)) == null ? void 0 : _a.toString()) || match;
    });
    if (this.isPureExpression(rawLabel) && allPlaceholdersKnown && matches.length > 0) {
      return processedLabel;
    }
    const baseProcessedLabel = this.getBaseLabel(processedLabel);
    for (const definedLabel of this.definedLabels) {
      if (definedLabel.startsWith(baseProcessedLabel)) {
        return processedLabel;
      }
    }
    if (!this.definedLabels.has(processedLabel)) {
      return null;
    }
    return processedLabel;
  }
  /**
   * Check if a label is a pure expression (contains only placeholders and operators).
   * Pure expressions like "(#a)+(#b)" or "P(#a),(#b)" are valid references without needing to be defined.
   * After removing placeholders, checks if remaining characters are only operators, spaces, and simple prefixes.
   * 
   * @param label - The label to check for pure expression pattern
   * @returns true if the label is a pure expression that doesn't need prior definition
   * @throws Does not throw exceptions - handles malformed input gracefully
   * @example
   * isPureExpression("P(#a),(#b)"); // returns true
   * isPureExpression("theorem1");   // returns false (needs definition)
   */
  isPureExpression(label) {
    const withoutPlaceholders = label.replace(ListPatterns.PLACEHOLDER_PATTERN, "");
    return ListPatterns.PURE_EXPRESSION_PATTERN.test(withoutPlaceholders);
  }
  /**
   * Get the base label without trailing primes or other modifiers.
   * Used to match variations like "P1'" against defined labels like "P1'''".
   * Enables partial matching of label references against their defined counterparts.
   * 
   * @param label - The label to extract base form from
   * @returns The base label with trailing primes/quotes removed
   * @throws Does not throw exceptions - handles all string input safely
   * @example
   * getBaseLabel("theorem1'''"); // returns "theorem1"
   * getBaseLabel("P1'");        // returns "P1"
   */
  getBaseLabel(label) {
    return ListPatterns.removeTrailingQuotes(label);
  }
  /**
   * Reset the context for a new document.
   */
  reset() {
    this.placeholderMap.clear();
    this.processedLabels.clear();
    this.definedLabels.clear();
    this.nextNumber = 1;
  }
  /**
   * Get the current placeholder mappings for debugging.
   */
  getPlaceholderMappings() {
    return new Map(this.placeholderMap);
  }
  /**
   * Check if a label is defined.
   */
  isLabelDefined(processedLabel) {
    return this.definedLabels.has(processedLabel);
  }
};

// src/shared/extractors/customLabelExtractor.ts
function extractCustomLabels(content, moreExtendedSyntax) {
  return withErrorBoundary(() => {
    const lines = content.split("\n");
    const labels = [];
    if (!moreExtendedSyntax) {
      return labels;
    }
    const { processedLabels, rawToProcessed } = processLabels(lines);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = ListPatterns.isCustomLabelList(line);
      if (match) {
        const fullMarker = match[2];
        const rawLabel = match[3];
        const restOfLine = line.substring(match[0].length);
        const processedLabel = rawToProcessed.get(rawLabel) || rawLabel;
        const renderedLabel = processedLabel;
        let renderedContent = restOfLine.trim();
        renderedContent = renderedContent.replace(ListPatterns.CUSTOM_LABEL_REFERENCE, (match2, ref) => {
          const processedRef = rawToProcessed.get(ref) || ref;
          return processedRef;
        });
        labels.push({
          label: renderedLabel,
          rawLabel: fullMarker,
          content: restOfLine.trim(),
          renderedContent,
          lineNumber: i,
          position: { line: i, ch: 0 }
        });
      }
    }
    return labels;
  }, [], "CustomLabelExtractor.extractCustomLabels");
}
function processLabels(lines) {
  const placeholderContext = new PlaceholderContext();
  const processedLabels = /* @__PURE__ */ new Map();
  const rawToProcessed = /* @__PURE__ */ new Map();
  for (const line of lines) {
    const match = ListPatterns.isCustomLabelList(line);
    if (match) {
      const rawLabel = match[3];
      const fullMatch = match[0];
      const restOfLine = line.substring(fullMatch.length);
      const processedLabel = placeholderContext.processLabel(rawLabel);
      processedLabels.set(processedLabel, restOfLine.trim());
      rawToProcessed.set(rawLabel, processedLabel);
    }
  }
  return { processedLabels, rawToProcessed };
}

// src/shared/utils/mathRenderer.ts
function renderMathToText(mathContent) {
  let rendered = mathContent;
  for (const [latex, unicode] of Object.entries(MATH_SYMBOLS.LATEX_TO_UNICODE)) {
    rendered = rendered.replace(new RegExp(latex.replace(ListPatterns.BACKSLASH_ESCAPE, "\\\\"), "g"), unicode);
  }
  rendered = ListPatterns.cleanMathExpression(rendered);
  return rendered;
}
function tokenizeMath(mathContent) {
  const tokens = [];
  let current = "";
  let i = 0;
  while (i < mathContent.length) {
    if (mathContent[i] === "\\") {
      if (current) {
        tokens.push(current);
        current = "";
      }
      let command = "\\";
      i++;
      while (i < mathContent.length && /[a-zA-Z]/.test(mathContent[i])) {
        command += mathContent[i];
        i++;
      }
      if (i < mathContent.length && mathContent[i] === " ") {
        if (command.length > 1) {
          command += " ";
          i++;
        }
      }
      tokens.push(command);
    } else {
      current += mathContent[i];
      i++;
    }
  }
  if (current) {
    tokens.push(current);
  }
  return tokens;
}
function truncateMathContent(mathContent, maxRenderedLength) {
  const tokens = tokenizeMath(mathContent);
  let result = "$";
  let tokenCount = 0;
  let accumulatedTokens = [];
  for (const token of tokens) {
    const testTokens = [...accumulatedTokens, token];
    const testLatex = testTokens.join("");
    const testRendered = renderMathToText(testLatex);
    if (testRendered.length <= maxRenderedLength) {
      accumulatedTokens.push(token);
      tokenCount++;
    } else {
      break;
    }
  }
  let latexContent = accumulatedTokens.join("");
  latexContent = latexContent.trimEnd();
  result += latexContent;
  if (!result.endsWith("$")) {
    result += "$";
  }
  return result;
}
function truncateMathAtLimit(mathBuffer, currentResult, remainingSpace) {
  if (remainingSpace > 1) {
    const truncatedMath = truncateMathContent(mathBuffer, remainingSpace - 1);
    return currentResult + truncatedMath.slice(1) + "\u2026";
  } else if (currentResult.endsWith("$")) {
    return currentResult.slice(0, -1) + "\u2026";
  } else {
    return currentResult + "\u2026";
  }
}

// src/views/panels/utils/contentTruncator.ts
function truncateLabel(label) {
  if (label.length > UI_CONSTANTS.LABEL_MAX_LENGTH) {
    return label.slice(0, UI_CONSTANTS.LABEL_TRUNCATION_LENGTH) + "\u2026";
  }
  return label;
}
function truncateContentWithRendering(content, maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  if (!content.includes("$")) {
    if (content.length > maxLength) {
      return content.slice(0, maxLength - 1) + "\u2026";
    }
    return content;
  }
  const parseResult = parseContentWithMath(content, maxLength);
  return parseResult.result;
}
function parseContentWithMath(content, maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  const normalizedContent = normalizeMathSpaces(content);
  const state = initializeParsingState(maxLength);
  for (let i = 0; i < normalizedContent.length; i++) {
    const char = normalizedContent[i];
    const parseResult = processCharacter(char, state);
    if (parseResult.shouldBreak) {
      return { result: parseResult.result, truncated: true };
    }
  }
  if (state.inMath) {
    return handleUnclosedMathWrapper(state);
  }
  return { result: state.result, truncated: false };
}
function normalizeMathSpaces(content) {
  if (content.includes("$")) {
    return ListPatterns.cleanWhitespaceBeforeDollar(content);
  }
  return content;
}
function initializeParsingState(maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  return {
    renderedLength: 0,
    result: "",
    inMath: false,
    mathBuffer: "",
    maxLength
  };
}
function processCharacter(char, state) {
  if (char === "$") {
    const mathResult = processMathDelimiter(
      state.inMath,
      state.mathBuffer,
      state.result,
      state.renderedLength,
      state.maxLength
    );
    state.result = mathResult.result;
    state.renderedLength = mathResult.renderedLength;
    state.mathBuffer = mathResult.mathBuffer;
    state.inMath = mathResult.inMath;
    return { result: mathResult.result, shouldBreak: mathResult.shouldBreak };
  } else if (state.inMath) {
    state.mathBuffer += char;
    return { result: state.result, shouldBreak: false };
  } else {
    const textResult = processRegularCharacter(char, state.result, state.renderedLength, state.maxLength);
    state.result = textResult.result;
    state.renderedLength = textResult.renderedLength;
    return { result: textResult.result, shouldBreak: textResult.shouldBreak };
  }
}
function handleUnclosedMathWrapper(state) {
  const finalResult = handleUnclosedMath(state.mathBuffer, state.result, state.renderedLength, state.maxLength);
  return { result: finalResult.result, truncated: finalResult.truncated };
}
function processMathDelimiter(inMath, mathBuffer, currentResult, currentLength, maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  if (inMath) {
    const trimmedBuffer = mathBuffer.trimEnd();
    const renderedMath = renderMathToText(trimmedBuffer);
    const remainingSpace = maxLength - currentLength;
    if (renderedMath.length <= remainingSpace) {
      return {
        result: currentResult + trimmedBuffer + "$",
        renderedLength: currentLength + renderedMath.length,
        mathBuffer: "",
        inMath: false,
        shouldBreak: false
      };
    } else {
      const truncatedResult = truncateMathAtLimit(
        mathBuffer,
        currentResult,
        remainingSpace
      );
      return {
        result: truncatedResult,
        renderedLength: maxLength,
        mathBuffer: "",
        inMath: false,
        shouldBreak: true
      };
    }
  } else {
    return {
      result: currentResult + "$",
      renderedLength: currentLength,
      mathBuffer: "",
      inMath: true,
      shouldBreak: false
    };
  }
}
function processRegularCharacter(char, currentResult, currentLength, maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  if (currentLength < maxLength) {
    return {
      result: currentResult + char,
      renderedLength: currentLength + 1,
      shouldBreak: false
    };
  } else {
    const truncated = currentResult.length > 0 && !currentResult.endsWith("\u2026") ? currentResult.slice(0, -1) + "\u2026" : currentResult + "\u2026";
    return {
      result: truncated,
      renderedLength: maxLength,
      shouldBreak: true
    };
  }
}
function handleUnclosedMath(mathBuffer, currentResult, currentLength, maxLength = UI_CONSTANTS.CONTENT_MAX_LENGTH) {
  const renderedMath = renderMathToText(mathBuffer);
  const remainingSpace = maxLength - currentLength;
  if (renderedMath.length <= remainingSpace) {
    return {
      result: currentResult + mathBuffer.trimEnd() + "$",
      truncated: false
    };
  } else {
    const truncatedResult = truncateMathAtLimit(
      mathBuffer,
      currentResult,
      remainingSpace
    );
    return {
      result: truncatedResult,
      truncated: true
    };
  }
}

// src/views/panels/utils/viewInteractions.ts
var import_obsidian2 = require("obsidian");

// src/shared/rendering/ContentProcessorRegistry.ts
var ContentProcessorRegistry = class _ContentProcessorRegistry {
  constructor() {
    this.processors = /* @__PURE__ */ new Map();
    this.registerDefaultProcessors();
  }
  /**
   * Get the singleton instance
   */
  static getInstance() {
    if (!_ContentProcessorRegistry.instance) {
      _ContentProcessorRegistry.instance = new _ContentProcessorRegistry();
    }
    return _ContentProcessorRegistry.instance;
  }
  /**
   * Register a content processor with the registry
   * @param processor The processor to register
   */
  registerProcessor(processor) {
    this.processors.set(processor.id, processor);
  }
  /**
   * Unregister a content processor from the registry
   * @param id The unique identifier of the processor to remove
   */
  unregisterProcessor(id) {
    this.processors.delete(id);
  }
  /**
   * Process content through all registered processors in sequence
   * @param content The content to process
   * @param context The processing context containing data for processors
   * @returns The processed content with all transformations applied
   */
  processContent(content, context) {
    let processedContent = content;
    for (const processor of this.processors.values()) {
      processedContent = processor.process(processedContent, context);
    }
    return processedContent;
  }
  /**
   * Register the default built-in processors
   */
  registerDefaultProcessors() {
    this.registerProcessor({
      id: "example-references",
      process: (content, context) => {
        if (!context.exampleLabels) return content;
        return content.replace(
          ListPatterns.EXAMPLE_REFERENCE,
          (match, label) => {
            const number = context.exampleLabels.get(label);
            return number !== void 0 ? `(${number})` : match;
          }
        );
      }
    });
    this.registerProcessor({
      id: "custom-label-references",
      process: (content, context) => {
        if (!context.rawToProcessed) return content;
        return content.replace(
          ListPatterns.CUSTOM_LABEL_REFERENCE,
          (match, label) => {
            const processed = context.rawToProcessed.get(label);
            return processed !== void 0 ? processed : match;
          }
        );
      }
    });
  }
  /**
   * Clear all processors (useful for testing)
   */
  clearProcessors() {
    this.processors.clear();
  }
  /**
   * Reset to default processors
   */
  reset() {
    this.clearProcessors();
    this.registerDefaultProcessors();
  }
};
function processContent(content, context) {
  return ContentProcessorRegistry.getInstance().processContent(content, context);
}

// src/views/panels/utils/viewInteractions.ts
function highlightLine(view, lineNumber) {
  withErrorBoundary(() => {
    const editor = view.editor;
    setCursorAndScroll(editor, lineNumber);
    applyLineHighlight(editor, lineNumber);
  }, void 0, "highlight line");
}
function setCursorAndScroll(editor, lineNumber) {
  const lineStart = { line: lineNumber, ch: 0 };
  editor.setCursor(lineStart);
  editor.scrollIntoView({ from: lineStart, to: lineStart }, true);
}
function applyLineHighlight(editor, lineNumber) {
  const cm = editor.cm;
  if (!cm) return;
  const editorDom = cm.dom || cm.contentDOM;
  if (!editorDom) return;
  setTimeout(() => {
    findAndHighlightLine(editorDom, editor);
  }, 50);
}
function findAndHighlightLine(editorDom, editor) {
  const activeLine = editorDom.querySelector(".cm-line.cm-active");
  if (activeLine) {
    applyHighlight(activeLine);
    return;
  }
  const allLines = editorDom.querySelectorAll(".cm-line");
  const coords = editor.cursorCoords(true, "local");
  if (!coords || allLines.length === 0) return;
  let targetLine = null;
  let minDistance = Infinity;
  allLines.forEach((line) => {
    const rect = line.getBoundingClientRect();
    const editorRect = editorDom.getBoundingClientRect();
    const relativeTop = rect.top - editorRect.top;
    const distance = Math.abs(relativeTop - coords.top);
    if (distance < minDistance) {
      minDistance = distance;
      targetLine = line;
    }
  });
  if (targetLine) {
    applyHighlight(targetLine);
  }
}
function applyHighlight(lineElement) {
  lineElement.classList.remove(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  void lineElement.offsetWidth;
  lineElement.classList.add(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  setTimeout(() => {
    lineElement.classList.remove(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  }, UI_CONSTANTS.HIGHLIGHT_ANIMATION_DURATION_MS);
}
function setupLabelClickHandler(element, rawLabel, abortSignal) {
  const clickHandler = async () => {
    await withAsyncErrorBoundary(async () => {
      await navigator.clipboard.writeText(rawLabel);
      new import_obsidian2.Notice(MESSAGES.LABEL_COPIED);
    }, void 0, "copy label to clipboard");
  };
  element.addEventListener("click", clickHandler, { signal: abortSignal });
}
function setupContentClickHandler(element, label, lastActiveMarkdownView, app, abortSignal) {
  const clickHandler = () => {
    withErrorBoundary(() => {
      const targetView = lastActiveMarkdownView;
      if (targetView && targetView.editor) {
        const editor = targetView.editor;
        const leaves = app.workspace.getLeavesOfType("markdown");
        const targetLeaf = leaves.find((leaf) => leaf.view === targetView);
        if (targetLeaf) {
          app.workspace.setActiveLeaf(targetLeaf, { focus: true });
        }
        editor.setCursor(label.position);
        editor.scrollIntoView({ from: label.position, to: label.position }, true);
        highlightLine(targetView, label.lineNumber);
      }
    }, void 0, "navigate to custom label");
  };
  element.addEventListener("click", clickHandler, { signal: abortSignal });
}
function setupLabelHoverPreview(element, fullLabel, abortSignal) {
  let hoverPopover = null;
  const removePopover2 = () => {
    if (hoverPopover) {
      hoverPopover.remove();
      hoverPopover = null;
    }
  };
  const mouseEnterHandler = () => {
    const hoverEl = document.createElement("div");
    hoverEl.classList.add(CSS_CLASSES.HOVER_POPOVER, CSS_CLASSES.HOVER_POPOVER_LABEL);
    hoverEl.textContent = fullLabel;
    document.body.appendChild(hoverEl);
    const rect = element.getBoundingClientRect();
    hoverEl.style.left = `${rect.left}px`;
    hoverEl.style.top = `${rect.bottom + UI_CONSTANTS.HOVER_OFFSET_BOTTOM}px`;
    const hoverRect = hoverEl.getBoundingClientRect();
    if (hoverRect.right > window.innerWidth) {
      hoverEl.style.left = `${window.innerWidth - hoverRect.width - UI_CONSTANTS.HOVER_OFFSET_HORIZONTAL}px`;
    }
    if (hoverRect.bottom > window.innerHeight) {
      hoverEl.style.top = `${rect.top - hoverRect.height - UI_CONSTANTS.HOVER_OFFSET_TOP}px`;
    }
    hoverPopover = hoverEl;
  };
  element.addEventListener("mouseenter", mouseEnterHandler, { signal: abortSignal });
  element.addEventListener("mouseleave", removePopover2, { signal: abortSignal });
  element.addEventListener("click", removePopover2, { signal: abortSignal });
}
function renderContentWithMath(element, truncatedContent, app, component, context) {
  let contentToRender = truncatedContent;
  if (context) {
    contentToRender = processContent(truncatedContent, context);
  }
  import_obsidian2.MarkdownRenderer.render(
    app,
    contentToRender,
    element,
    "",
    component
  );
}

// src/shared/utils/hoverPopovers.ts
var import_obsidian3 = require("obsidian");
function processPopoverContent(content, context) {
  if (!context) return content;
  return processContent(content, context);
}
function createHoverState() {
  return {
    hoverPopover: null,
    isMouseOverElement: false,
    isMouseOverPopover: false,
    cleanupTimeout: null,
    popoverController: null
  };
}
function clearCleanupTimeout(state) {
  if (state.cleanupTimeout) {
    clearTimeout(state.cleanupTimeout);
    state.cleanupTimeout = null;
  }
}
function removePopover(state) {
  clearCleanupTimeout(state);
  if (state.popoverController) {
    state.popoverController.abort();
    state.popoverController = null;
  }
  if (state.hoverPopover) {
    state.hoverPopover.remove();
    state.hoverPopover = null;
  }
}
function scheduleRemoval(state) {
  clearCleanupTimeout(state);
  state.cleanupTimeout = setTimeout(() => {
    if (!state.isMouseOverElement && !state.isMouseOverPopover) {
      removePopover(state);
    }
  }, UI_CONSTANTS.HOVER_CLEANUP_DELAY_MS);
}
function scheduleAsyncRemoval(state) {
  clearCleanupTimeout(state);
  state.cleanupTimeout = setTimeout(() => {
    if (!state.isMouseOverElement && !state.isMouseOverPopover) {
      removeAsyncPopover(state);
    }
  }, UI_CONSTANTS.HOVER_CLEANUP_DELAY_MS);
}
function positionPopover(popoverElement, referenceElement) {
  const elementRect = referenceElement.getBoundingClientRect();
  popoverElement.style.left = `${elementRect.left}px`;
  popoverElement.style.top = `${elementRect.bottom + UI_CONSTANTS.HOVER_OFFSET_BOTTOM}px`;
  const popoverRect = popoverElement.getBoundingClientRect();
  if (popoverRect.right > window.innerWidth) {
    popoverElement.style.left = `${window.innerWidth - popoverRect.width - UI_CONSTANTS.HOVER_OFFSET_HORIZONTAL}px`;
  }
  if (popoverRect.bottom > window.innerHeight) {
    popoverElement.style.top = `${elementRect.top - popoverRect.height - UI_CONSTANTS.HOVER_OFFSET_TOP}px`;
  }
}
function attachPopoverListeners(popoverElement, state) {
  state.popoverController = new AbortController();
  popoverElement.addEventListener("mouseenter", () => {
    clearCleanupTimeout(state);
    state.isMouseOverPopover = true;
  }, { signal: state.popoverController.signal });
  popoverElement.addEventListener("mouseleave", () => {
    state.isMouseOverPopover = false;
    scheduleRemoval(state);
  }, { signal: state.popoverController.signal });
}
function attachAsyncPopoverListeners(popoverElement, state) {
  state.popoverController = new AbortController();
  popoverElement.addEventListener("mouseenter", () => {
    clearCleanupTimeout(state);
    state.isMouseOverPopover = true;
  }, { signal: state.popoverController.signal });
  popoverElement.addEventListener("mouseleave", () => {
    state.isMouseOverPopover = false;
    scheduleAsyncRemoval(state);
  }, { signal: state.popoverController.signal });
}
function setupSimpleHoverPreview(element, fullText, popoverClass = CSS_CLASSES.HOVER_POPOVER_LABEL, abortSignal) {
  const state = createHoverState();
  const mouseEnterHandler = () => {
    clearCleanupTimeout(state);
    state.isMouseOverElement = true;
    removePopover(state);
    const hoverElement = document.createElement(DOM_ATTRIBUTES.ELEMENT_DIV);
    hoverElement.classList.add(CSS_CLASSES.HOVER_POPOVER, popoverClass);
    hoverElement.textContent = fullText;
    document.body.appendChild(hoverElement);
    positionPopover(hoverElement, element);
    state.hoverPopover = hoverElement;
    attachPopoverListeners(hoverElement, state);
    if (abortSignal) {
      abortSignal.addEventListener("abort", () => removePopover(state), { once: true });
    }
  };
  const mouseLeaveHandler = () => {
    state.isMouseOverElement = false;
    scheduleRemoval(state);
  };
  const clickHandler = () => {
    state.isMouseOverElement = false;
    state.isMouseOverPopover = false;
    removePopover(state);
  };
  if (abortSignal) {
    abortSignal.addEventListener("abort", () => removePopover(state), { once: true });
  }
  element.addEventListener("mouseenter", mouseEnterHandler, { signal: abortSignal });
  element.addEventListener("mouseleave", mouseLeaveHandler, { signal: abortSignal });
  element.addEventListener("click", clickHandler, { signal: abortSignal });
}
function createAsyncHoverState() {
  return {
    ...createHoverState(),
    renderAbortController: null,
    renderingGeneration: 0
  };
}
function removeAsyncPopover(state) {
  clearCleanupTimeout(state);
  if (state.renderAbortController) {
    state.renderAbortController.abort();
    state.renderAbortController = null;
  }
  if (state.popoverController) {
    state.popoverController.abort();
    state.popoverController = null;
  }
  if (state.hoverPopover) {
    state.hoverPopover.remove();
    state.hoverPopover = null;
  }
}
async function renderPopoverContent(popoverElement, content, app, component, context) {
  const processedContent = processPopoverContent(content, context);
  try {
    await import_obsidian3.MarkdownRenderer.render(
      app,
      processedContent,
      popoverElement,
      FILE_CONSTANTS.EMPTY_STRING,
      component
    );
  } catch (error) {
    handleError(error, ERROR_MESSAGES.PLUGIN_PREFIX + ": Hover preview rendering");
    throw error;
  }
}
function setupRenderedHoverPreview(element, content, app, component, context, popoverClass = CSS_CLASSES.HOVER_POPOVER_CONTENT, abortSignal) {
  const state = createAsyncHoverState();
  const mouseEnterHandler = async () => {
    var _a;
    clearCleanupTimeout(state);
    state.isMouseOverElement = true;
    const currentGeneration = ++state.renderingGeneration;
    removeAsyncPopover(state);
    state.renderAbortController = new AbortController();
    const hoverElement = document.createElement(DOM_ATTRIBUTES.ELEMENT_DIV);
    hoverElement.classList.add(CSS_CLASSES.HOVER_POPOVER, popoverClass);
    try {
      await renderPopoverContent(hoverElement, content, app, component, context);
    } catch (error) {
      if ((_a = state.renderAbortController) == null ? void 0 : _a.signal.aborted) {
        return;
      }
      return;
    }
    if (currentGeneration !== state.renderingGeneration || !state.isMouseOverElement) {
      return;
    }
    document.body.appendChild(hoverElement);
    positionPopover(hoverElement, element);
    if (currentGeneration === state.renderingGeneration && state.isMouseOverElement) {
      state.hoverPopover = hoverElement;
      attachAsyncPopoverListeners(hoverElement, state);
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => removeAsyncPopover(state), { once: true });
      }
    } else {
      hoverElement.remove();
    }
  };
  const mouseLeaveHandler = () => {
    state.isMouseOverElement = false;
    scheduleAsyncRemoval(state);
  };
  const clickHandler = () => {
    state.isMouseOverElement = false;
    state.isMouseOverPopover = false;
    removeAsyncPopover(state);
  };
  if (abortSignal) {
    abortSignal.addEventListener("abort", () => removeAsyncPopover(state), { once: true });
  }
  element.addEventListener("mouseenter", mouseEnterHandler, { signal: abortSignal });
  element.addEventListener("mouseleave", mouseLeaveHandler, { signal: abortSignal });
  element.addEventListener("click", clickHandler, { signal: abortSignal });
}

// src/shared/extractors/exampleListExtractor.ts
function extractExampleLists(content) {
  return withErrorBoundary(() => {
    const items = [];
    const lines = content.split("\n");
    let exampleCounter = 1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = line.match(ListPatterns.EXAMPLE_LIST_WITH_CONTENT);
      if (match) {
        const rawLabel = `@${match[2]}`;
        const listContent = match[3].trim();
        items.push({
          renderedNumber: exampleCounter,
          rawLabel,
          content: listContent,
          lineNumber: i,
          position: { line: i, ch: 0 }
        });
        exampleCounter++;
      } else {
        const unlabeledMatch = line.match(ListPatterns.UNLABELED_EXAMPLE_LIST);
        if (unlabeledMatch) {
          const contentStart = line.indexOf("(@)") + 3;
          const listContent = line.substring(contentStart).trim();
          items.push({
            renderedNumber: exampleCounter,
            rawLabel: "@",
            content: listContent,
            lineNumber: i,
            position: { line: i, ch: 0 }
          });
          exampleCounter++;
        }
      }
    }
    return items;
  }, "Extract example lists", []);
}

// src/views/panels/modules/BasePanelModule.ts
var BasePanelModule = class {
  constructor(plugin) {
    this.isActive = false;
    this.containerEl = null;
    this.lastActiveMarkdownView = null;
    this.abortController = null;
    this.currentContext = {};
    this.plugin = plugin;
  }
  onActivate(containerEl, activeView) {
    this.isActive = true;
    this.containerEl = containerEl;
    this.lastActiveMarkdownView = activeView;
    this.abortController = new AbortController();
    this.updateContent(activeView);
  }
  onDeactivate() {
    this.isActive = false;
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    if (this.containerEl) {
      this.containerEl.empty();
      this.containerEl = null;
    }
    this.cleanupModuleData();
  }
  onUpdate(activeView) {
    if (!this.isActive || !this.containerEl) return;
    if (activeView && activeView.file) {
      this.lastActiveMarkdownView = activeView;
    } else if (!activeView) {
      activeView = this.lastActiveMarkdownView;
    }
    this.updateContent(activeView);
  }
  shouldUpdate() {
    return this.isActive;
  }
  destroy() {
    this.onDeactivate();
    this.lastActiveMarkdownView = null;
  }
  /**
   * Main update method that orchestrates content extraction and rendering.
   */
  updateContent(activeView) {
    if (!this.containerEl) return;
    this.containerEl.empty();
    if (!activeView || !activeView.file) {
      this.showNoFileMessage();
      return;
    }
    const content = activeView.editor.getValue();
    this.extractData(content);
    this.buildRenderingContext(content);
    this.renderContent(activeView);
  }
  /**
   * Shows a message when no file is open.
   */
  showNoFileMessage() {
    if (!this.containerEl) return;
    this.containerEl.createEl("div", {
      text: MESSAGES.NO_FILE,
      cls: CSS_CLASSES.NO_FILE_MESSAGE
    });
  }
  /**
   * Builds the rendering context for processing references.
   * Common implementation that can be overridden if needed.
   */
  buildRenderingContext(content) {
    const exampleItems = extractExampleLists(content);
    const exampleLabels = /* @__PURE__ */ new Map();
    const exampleContent = /* @__PURE__ */ new Map();
    exampleItems.forEach((item) => {
      if (item.label) {
        exampleLabels.set(item.label, item.number);
        exampleContent.set(item.label, item.content.trim());
      }
    });
    const customLabels = extractCustomLabels(content);
    const customLabelMap = /* @__PURE__ */ new Map();
    const rawToProcessed = /* @__PURE__ */ new Map();
    customLabels.forEach((label) => {
      customLabelMap.set(label.rawLabel, label.content);
      if (label.processedLabel !== label.rawLabel) {
        rawToProcessed.set(label.rawLabel, label.processedLabel);
      }
    });
    this.currentContext = {
      exampleLabels,
      exampleContent,
      customLabels: customLabelMap,
      rawToProcessed
    };
  }
  /**
   * Clean up module-specific data.
   * Should be implemented by subclasses if they have data to clean up.
   */
  cleanupModuleData() {
  }
};

// src/views/panels/modules/CustomLabelPanelModule.ts
var CustomLabelPanelModule = class extends BasePanelModule {
  constructor() {
    super(...arguments);
    this.id = "custom-labels";
    this.displayName = "Custom Labels";
    this.icon = ICONS.CUSTOM_LABEL_SVG;
    this.labels = [];
  }
  cleanupModuleData() {
    this.labels = [];
  }
  extractData(content) {
    var _a;
    this.labels = extractCustomLabels(content, ((_a = this.plugin.settings) == null ? void 0 : _a.moreExtendedSyntax) || false);
  }
  renderContent(activeView) {
    this.renderLabels(activeView);
  }
  showNoFileMessage() {
    if (!this.containerEl) return;
    this.containerEl.createEl("div", {
      text: MESSAGES.NO_ACTIVE_FILE,
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_EMPTY
    });
    this.labels = [];
  }
  /**
   * Build the rendering context for processing content references
   * @param content The document content to extract context from
   */
  buildRenderingContext(content) {
    super.buildRenderingContext(content);
    const rawToProcessed = /* @__PURE__ */ new Map();
    this.labels.forEach((label) => {
      const match = label.rawLabel.match(/\{::([^}]+)\}/);
      if (match) {
        rawToProcessed.set(match[1], label.label);
      }
    });
    this.currentContext = {
      ...this.currentContext,
      rawToProcessed
    };
  }
  renderLabels(activeView) {
    if (!this.containerEl) return;
    if (this.labels.length === 0) {
      this.containerEl.createEl("div", {
        text: MESSAGES.NO_CUSTOM_LABELS,
        cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_EMPTY
      });
      return;
    }
    const container = this.containerEl.createEl("table", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_CONTAINER
    });
    const tbody = container.createEl("tbody");
    for (const label of this.labels) {
      this.renderLabelRow(tbody, label, activeView);
    }
  }
  renderLabelRow(tbody, label, activeView) {
    var _a, _b, _c, _d;
    const row = tbody.createEl("tr", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_ROW
    });
    const labelEl = row.createEl("td", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_LABEL
    });
    const displayLabel = truncateLabel(label.label);
    labelEl.textContent = displayLabel;
    if (displayLabel !== label.label) {
      setupLabelHoverPreview(labelEl, label.label, (_a = this.abortController) == null ? void 0 : _a.signal);
    }
    setupLabelClickHandler(labelEl, label.rawLabel, (_b = this.abortController) == null ? void 0 : _b.signal);
    const contentEl = row.createEl("td", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_CONTENT
    });
    const contentToShow = label.renderedContent || label.content;
    const truncatedContent = truncateContentWithRendering(contentToShow);
    renderContentWithMath(contentEl, truncatedContent, this.plugin.app, this.plugin, this.currentContext);
    setupContentClickHandler(contentEl, label, this.lastActiveMarkdownView, this.plugin.app, (_c = this.abortController) == null ? void 0 : _c.signal);
    if (truncatedContent !== contentToShow) {
      setupRenderedHoverPreview(
        contentEl,
        contentToShow,
        this.plugin.app,
        this.plugin,
        this.currentContext,
        CSS_CLASSES.HOVER_POPOVER_CONTENT,
        (_d = this.abortController) == null ? void 0 : _d.signal
      );
    }
  }
  getCustomLabels() {
    return this.labels;
  }
};

// src/views/panels/modules/ExampleListPanelModule.ts
var import_obsidian4 = require("obsidian");

// src/views/editor/highlightUtils.ts
function highlightLine2(view, lineNumber, cursorPosition) {
  try {
    const editor = view.editor;
    if (cursorPosition) {
      editor.setCursor(cursorPosition);
      editor.scrollIntoView({ from: cursorPosition, to: cursorPosition }, true);
    } else {
      moveCursorToLine(editor, lineNumber);
    }
    const cm = editor.cm;
    if (cm) {
      const editorDom = cm.dom || cm.contentDOM;
      if (editorDom) {
        setTimeout(() => {
          highlightTargetLine(editorDom, editor);
        }, 50);
      }
    }
  } catch (error) {
    handleError(error, "Highlight line");
  }
}
function moveCursorToLine(editor, lineNumber) {
  const lineStart = { line: lineNumber, ch: 0 };
  editor.setCursor(lineStart);
  editor.scrollIntoView({ from: lineStart, to: lineStart }, true);
}
function highlightTargetLine(editorDom, editor) {
  const activeLine = editorDom.querySelector(".cm-line.cm-active");
  if (activeLine) {
    applyHighlight2(activeLine);
  } else {
    const targetLine = findClosestLine(editorDom, editor);
    if (targetLine) {
      applyHighlight2(targetLine);
    }
  }
}
function findClosestLine(editorDom, editor) {
  const allLines = editorDom.querySelectorAll(".cm-line");
  const coords = editor.cursorCoords(true, "local");
  if (!coords || allLines.length === 0) return null;
  let targetLine = null;
  let minDistance = Infinity;
  allLines.forEach((line) => {
    const rect = line.getBoundingClientRect();
    const editorRect = editorDom.getBoundingClientRect();
    const relativeTop = rect.top - editorRect.top;
    const distance = Math.abs(relativeTop - coords.top);
    if (distance < minDistance) {
      minDistance = distance;
      targetLine = line;
    }
  });
  return targetLine;
}
function applyHighlight2(lineElement) {
  lineElement.classList.remove(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  void lineElement.offsetWidth;
  lineElement.classList.add(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  setTimeout(() => {
    lineElement.classList.remove(CSS_CLASSES.CUSTOM_LABEL_HIGHLIGHT);
  }, UI_CONSTANTS.HIGHLIGHT_DURATION_MS);
}

// src/views/panels/modules/ExampleListPanelModule.ts
var ExampleListPanelModule = class extends BasePanelModule {
  constructor() {
    super(...arguments);
    this.id = "example-lists";
    this.displayName = "Example Lists";
    this.icon = ICONS.EXAMPLE_LIST_SVG;
    this.exampleItems = [];
  }
  cleanupModuleData() {
    this.exampleItems = [];
  }
  extractData(content) {
    this.exampleItems = extractExampleLists(content);
  }
  renderContent(activeView) {
    this.renderExampleItems(activeView);
  }
  showNoFileMessage() {
    if (!this.containerEl) return;
    this.containerEl.createEl("div", {
      text: MESSAGES.NO_ACTIVE_FILE,
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_EMPTY
    });
    this.exampleItems = [];
  }
  /**
   * Build the rendering context for processing content references
   * @param content The document content to extract context from
   */
  buildRenderingContext(content) {
    var _a;
    super.buildRenderingContext(content);
    const exampleLabels = /* @__PURE__ */ new Map();
    this.exampleItems.forEach((item) => {
      const label = item.rawLabel.substring(1);
      if (label) {
        exampleLabels.set(label, item.renderedNumber);
      }
    });
    const rawToProcessed = /* @__PURE__ */ new Map();
    if ((_a = this.plugin.settings) == null ? void 0 : _a.moreExtendedSyntax) {
      const customLabels = extractCustomLabels(content, true);
      customLabels.forEach((label) => {
        const match = label.rawLabel.match(/\{::([^}]+)\}/);
        if (match) {
          rawToProcessed.set(match[1], label.label);
        }
      });
    }
    this.currentContext = {
      ...this.currentContext,
      exampleLabels,
      rawToProcessed
    };
  }
  renderExampleItems(activeView) {
    if (!this.containerEl) return;
    if (this.exampleItems.length === 0) {
      this.containerEl.createEl("div", {
        text: MESSAGES.NO_EXAMPLE_LISTS,
        cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_EMPTY
      });
      return;
    }
    const container = this.containerEl.createEl("table", {
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_CONTAINER
    });
    const tbody = container.createEl("tbody");
    for (const item of this.exampleItems) {
      this.renderExampleRow(tbody, item, activeView);
    }
  }
  renderExampleRow(tbody, item, activeView) {
    const row = tbody.createEl("tr", {
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_ROW
    });
    const numberEl = row.createEl("td", {
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_NUMBER
    });
    const displayNumber = this.truncateNumber(item.renderedNumber);
    numberEl.textContent = displayNumber;
    if (displayNumber !== String(item.renderedNumber)) {
      this.setupNumberHoverPreview(numberEl, String(item.renderedNumber));
    }
    const labelEl = row.createEl("td", {
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_LABEL
    });
    const displayLabel = this.truncateRawLabel(item.rawLabel);
    labelEl.textContent = displayLabel;
    if (displayLabel !== item.rawLabel) {
      this.setupLabelHoverPreview(labelEl, item.rawLabel);
    }
    this.setupLabelClickHandler(labelEl, `(@${item.rawLabel.substring(1)})`);
    const contentEl = row.createEl("td", {
      cls: CSS_CLASSES.EXAMPLE_LIST_VIEW_CONTENT
    });
    const truncatedContent = truncateContentWithRendering(item.content);
    renderContentWithMath(contentEl, truncatedContent, this.plugin.app, this.plugin, this.currentContext);
    this.setupContentClickHandler(contentEl, item, activeView);
    if (truncatedContent !== item.content) {
      this.setupContentHoverPreview(contentEl, item);
    }
  }
  truncateNumber(number) {
    const str = String(number);
    if (str.length > 2) {
      return str.substring(0, 2) + "\u2026";
    }
    return str;
  }
  truncateRawLabel(label) {
    if (label.length > UI_CONSTANTS.LABEL_MAX_LENGTH) {
      return label.slice(0, UI_CONSTANTS.LABEL_TRUNCATION_LENGTH) + "\u2026";
    }
    return label;
  }
  setupNumberHoverPreview(element, fullNumber) {
    setupSimpleHoverPreview(element, fullNumber, CSS_CLASSES.HOVER_POPOVER_LABEL);
  }
  setupLabelHoverPreview(element, fullLabel) {
    var _a;
    setupSimpleHoverPreview(element, fullLabel, CSS_CLASSES.HOVER_POPOVER_LABEL, (_a = this.abortController) == null ? void 0 : _a.signal);
  }
  setupLabelClickHandler(element, rawLabelSyntax) {
    var _a;
    const clickHandler = () => {
      try {
        navigator.clipboard.writeText(rawLabelSyntax).then(() => {
          new import_obsidian4.Notice(MESSAGES.LABEL_COPIED);
        }).catch((error) => {
          handleError(error, "Copy label to clipboard");
        });
      } catch (error) {
        handleError(error, "Label click handler");
      }
    };
    element.addEventListener("click", clickHandler, { signal: (_a = this.abortController) == null ? void 0 : _a.signal });
  }
  setupContentClickHandler(element, item, activeView) {
    var _a;
    const clickHandler = () => {
      try {
        if (activeView && activeView.editor) {
          const editor = activeView.editor;
          const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
          const targetLeaf = leaves.find((leaf) => leaf.view === activeView);
          if (targetLeaf) {
            this.plugin.app.workspace.setActiveLeaf(targetLeaf, { focus: true });
          }
          editor.setCursor(item.position);
          editor.scrollIntoView({ from: item.position, to: item.position }, true);
          highlightLine2(activeView, item.lineNumber);
        }
      } catch (error) {
        handleError(error, "Scroll to example list");
      }
    };
    element.addEventListener("click", clickHandler, { signal: (_a = this.abortController) == null ? void 0 : _a.signal });
  }
  setupContentHoverPreview(element, item) {
    var _a;
    setupRenderedHoverPreview(
      element,
      item.content,
      this.plugin.app,
      this.plugin,
      this.currentContext,
      CSS_CLASSES.HOVER_POPOVER_CONTENT,
      (_a = this.abortController) == null ? void 0 : _a.signal
    );
  }
};

// src/shared/extractors/definitionListExtractor.ts
function isNotListItem(line) {
  return !line.match(ListPatterns.UNORDERED_LIST) && !line.match(ListPatterns.NUMBERED_LIST) && !line.match(ListPatterns.HASH_LIST) && !line.match(ListPatterns.FANCY_LIST) && !line.match(ListPatterns.CUSTOM_LABEL_LIST) && !line.match(ListPatterns.EXAMPLE_LIST) && !ListPatterns.isDefinitionMarker(line);
}
function processDefinitionLine(line, defMatch, state) {
  if (!state.currentTerm) return;
  state.inDefinitionBlock = true;
  const content = line.substring(defMatch[0].length);
  if (content) {
    state.currentDefinitions.push(content);
  }
}
function processContinuationLine(line, state) {
  var _a;
  if (!state.inDefinitionBlock || !line.trim()) return false;
  const leadingSpaces = ((_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1].length) || 0;
  if (leadingSpaces >= UI_CONSTANTS.MARKDOWN_INDENT_SIZE && !ListPatterns.isDefinitionMarker(line) && state.currentDefinitions.length > 0) {
    const lastIndex = state.currentDefinitions.length - 1;
    state.currentDefinitions[lastIndex] += " " + line.trim();
    return true;
  }
  return false;
}
function saveCurrentTerm(state, items) {
  if (state.currentTerm && state.currentDefinitions.length > 0 && state.termPosition) {
    items.push({
      term: state.currentTerm,
      definitions: [...state.currentDefinitions],
      lineNumber: state.termLineNumber,
      position: state.termPosition
    });
  }
}
function extractDefinitionLists(content) {
  var _a;
  const lines = content.split("\n");
  const items = [];
  const state = {
    currentTerm: null,
    currentDefinitions: [],
    termLineNumber: -1,
    termPosition: null,
    inDefinitionBlock: false
  };
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const defMatch = ListPatterns.isDefinitionMarker(line);
    if (defMatch) {
      processDefinitionLine(line, defMatch, state);
      continue;
    }
    if (processContinuationLine(line, state)) {
      continue;
    }
    const leadingSpaces = ((_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1].length) || 0;
    const isPotentialTerm = line.trim() && leadingSpaces < UI_CONSTANTS.MARKDOWN_INDENT_SIZE && isNotListItem(line);
    if (isPotentialTerm) {
      saveCurrentTerm(state, items);
      state.currentTerm = line.trim();
      state.currentDefinitions = [];
      state.termLineNumber = i;
      state.termPosition = { line: i, ch: leadingSpaces };
      state.inDefinitionBlock = false;
    }
  }
  saveCurrentTerm(state, items);
  return items;
}

// src/views/panels/modules/DefinitionListPanelModule.ts
var DefinitionListPanelModule = class extends BasePanelModule {
  constructor() {
    super(...arguments);
    this.id = "definition-lists";
    this.displayName = "Definition Lists";
    this.icon = ICONS.DEFINITION_LIST_SVG;
    this.definitionItems = [];
  }
  cleanupModuleData() {
    this.definitionItems = [];
  }
  extractData(content) {
    this.definitionItems = extractDefinitionLists(content);
  }
  renderContent(activeView) {
    this.renderDefinitionItems(activeView);
  }
  showNoFileMessage() {
    if (!this.containerEl) return;
    this.containerEl.createEl("div", {
      text: MESSAGES.NO_ACTIVE_FILE,
      cls: CSS_CLASSES.DEFINITION_LIST_VIEW_EMPTY
    });
    this.definitionItems = [];
  }
  renderDefinitionItems(activeView) {
    if (!this.containerEl) return;
    if (this.definitionItems.length === 0) {
      this.containerEl.createEl("div", {
        text: MESSAGES.NO_DEFINITION_LISTS,
        cls: CSS_CLASSES.DEFINITION_LIST_VIEW_EMPTY
      });
      return;
    }
    const container = this.containerEl.createEl("table", {
      cls: CSS_CLASSES.DEFINITION_LIST_VIEW_CONTAINER
    });
    const tbody = container.createEl("tbody");
    for (const item of this.definitionItems) {
      this.renderDefinitionRow(tbody, item, activeView);
    }
  }
  renderDefinitionRow(tbody, item, activeView) {
    const row = tbody.createEl("tr", {
      cls: CSS_CLASSES.DEFINITION_LIST_VIEW_ROW
    });
    const termEl = row.createEl("td", {
      cls: CSS_CLASSES.DEFINITION_LIST_VIEW_TERM
    });
    const truncatedTerm = this.truncateTermWithRendering(item.term);
    renderContentWithMath(termEl, truncatedTerm, this.plugin.app, this.plugin, this.currentContext);
    if (truncatedTerm !== item.term) {
      this.setupTermHoverPreview(termEl, item.term);
    }
    const definitionsEl = row.createEl("td", {
      cls: CSS_CLASSES.DEFINITION_LIST_VIEW_DEFINITIONS
    });
    if (item.definitions.length === 1) {
      const truncatedContent = truncateContentWithRendering(item.definitions[0], UI_CONSTANTS.DEFINITION_MAX_LENGTH);
      renderContentWithMath(definitionsEl, truncatedContent, this.plugin.app, this.plugin, this.currentContext);
      if (truncatedContent !== item.definitions[0]) {
        this.setupContentHoverPreview(definitionsEl, item.definitions[0]);
      }
    } else {
      const ul = definitionsEl.createEl("ul");
      for (const def of item.definitions) {
        const li = ul.createEl("li");
        const truncatedContent = truncateContentWithRendering(def, UI_CONSTANTS.DEFINITION_MAX_LENGTH);
        renderContentWithMath(li, truncatedContent, this.plugin.app, this.plugin, this.currentContext);
        if (truncatedContent !== def) {
          this.setupContentHoverPreview(li, def);
        }
      }
    }
    this.setupDefinitionClickHandler(definitionsEl, item, activeView);
  }
  truncateTermWithRendering(term) {
    return truncateContentWithRendering(term, UI_CONSTANTS.TERM_MAX_LENGTH);
  }
  setupTermHoverPreview(element, fullTerm) {
    var _a;
    setupRenderedHoverPreview(
      element,
      fullTerm,
      this.plugin.app,
      this.plugin,
      this.currentContext,
      CSS_CLASSES.HOVER_POPOVER_CONTENT,
      (_a = this.abortController) == null ? void 0 : _a.signal
    );
  }
  setupDefinitionClickHandler(element, item, activeView) {
    var _a;
    const clickHandler = () => {
      try {
        if (activeView && activeView.editor) {
          const editor = activeView.editor;
          const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
          const targetLeaf = leaves.find((leaf) => leaf.view === activeView);
          if (targetLeaf) {
            this.plugin.app.workspace.setActiveLeaf(targetLeaf, { focus: true });
          }
          editor.setCursor(item.position);
          editor.scrollIntoView({ from: item.position, to: item.position }, true);
          highlightLine2(activeView, item.lineNumber);
        }
      } catch (error) {
        handleError(error, "Scroll to definition term");
      }
    };
    element.addEventListener("click", clickHandler, { signal: (_a = this.abortController) == null ? void 0 : _a.signal });
  }
  setupContentHoverPreview(element, content) {
    var _a;
    setupRenderedHoverPreview(
      element,
      content,
      this.plugin.app,
      this.plugin,
      this.currentContext,
      CSS_CLASSES.HOVER_POPOVER_CONTENT,
      (_a = this.abortController) == null ? void 0 : _a.signal
    );
  }
};

// src/views/panels/modules/FootnotePanelModule.ts
var import_obsidian5 = require("obsidian");

// src/shared/extractors/footnoteExtractor.ts
function extractFootnotes(content) {
  return withErrorBoundary(() => {
    const lines = content.split("\n");
    const referencePositions = collectReferencePositions(lines);
    const items = [];
    let index = 0;
    while (index < lines.length) {
      const parseResult = parseFootnoteDefinition(lines, index);
      if (!parseResult) {
        index += 1;
        continue;
      }
      const { item, nextIndex } = parseResult;
      const referenceInfo = referencePositions.get(item.label);
      if (referenceInfo) {
        item.referenceLine = referenceInfo.position.line;
        item.referencePosition = referenceInfo.position;
        item.referenceLength = referenceInfo.length;
      }
      items.push(item);
      index = nextIndex;
    }
    return items;
  }, [], "Extract footnotes");
}
function collectReferencePositions(lines) {
  var _a, _b, _c;
  const positions = /* @__PURE__ */ new Map();
  for (let lineIndex = 0; lineIndex < lines.length; lineIndex += 1) {
    const line = lines[lineIndex];
    if (ListPatterns.FOOTNOTE_DEFINITION.test(line)) {
      continue;
    }
    const referencePattern = new RegExp(ListPatterns.FOOTNOTE_REFERENCE.source, "g");
    let match;
    while ((match = referencePattern.exec(line)) !== null) {
      const label = (_a = match[1]) == null ? void 0 : _a.trim();
      if (!label || positions.has(label)) {
        continue;
      }
      positions.set(label, {
        position: {
          line: lineIndex,
          ch: match.index
        },
        length: (_c = (_b = match[0]) == null ? void 0 : _b.length) != null ? _c : 0
      });
    }
  }
  return positions;
}
function parseFootnoteDefinition(lines, startIndex) {
  var _a, _b, _c, _d;
  const line = lines[startIndex];
  const match = line.match(ListPatterns.FOOTNOTE_DEFINITION);
  if (!match) {
    return null;
  }
  const rawLabel = (_a = match[1]) == null ? void 0 : _a.trim();
  if (!rawLabel) {
    return null;
  }
  const initialContent = (_b = match[2]) != null ? _b : "";
  const builder = new FootnoteContentBuilder();
  if (initialContent.trim()) {
    builder.addText(initialContent.trim());
  }
  let nextIndex = startIndex + 1;
  while (nextIndex < lines.length) {
    const nextLine = lines[nextIndex];
    const continuationMatch = nextLine.match(ListPatterns.FOOTNOTE_CONTINUATION);
    if (continuationMatch) {
      const continuationText = (_d = (_c = continuationMatch[2]) == null ? void 0 : _c.trim()) != null ? _d : "";
      if (continuationText) {
        builder.addText(continuationText);
      } else {
        builder.addParagraphBreak();
      }
      nextIndex += 1;
      continue;
    }
    if (!nextLine.trim()) {
      const lookahead = nextIndex + 1 < lines.length ? lines[nextIndex + 1] : "";
      if (lookahead && ListPatterns.FOOTNOTE_CONTINUATION.test(lookahead)) {
        builder.addParagraphBreak();
        nextIndex += 1;
        continue;
      }
    }
    break;
  }
  const content = builder.build();
  const definitionPosition = {
    line: startIndex,
    ch: Math.max(0, line.indexOf(match[0]))
  };
  const item = {
    label: rawLabel,
    content,
    definitionLine: startIndex,
    definitionPosition,
    referenceLine: null,
    referencePosition: null,
    referenceLength: null
  };
  return { item, nextIndex };
}
var FootnoteContentBuilder = class {
  constructor() {
    this.paragraphs = [];
    this.current = [];
  }
  addText(text) {
    if (!text) {
      return;
    }
    this.current.push(text);
  }
  addParagraphBreak() {
    this.commitCurrentParagraph();
    const last = this.paragraphs[this.paragraphs.length - 1];
    if (last === null) {
      return;
    }
    this.paragraphs.push(null);
  }
  build() {
    this.commitCurrentParagraph();
    while (this.paragraphs.length > 0 && this.paragraphs[this.paragraphs.length - 1] === null) {
      this.paragraphs.pop();
    }
    if (this.paragraphs.length === 0) {
      return "";
    }
    let result = "";
    let appendedParagraphs = 0;
    let pendingBlank = false;
    for (const paragraph of this.paragraphs) {
      if (paragraph === null) {
        if (appendedParagraphs > 0) {
          pendingBlank = true;
        }
        continue;
      }
      if (pendingBlank || appendedParagraphs > 0) {
        result += "\n\n";
        pendingBlank = false;
      }
      if (paragraph.length > 0) {
        result += paragraph;
        appendedParagraphs += 1;
      }
    }
    return result;
  }
  commitCurrentParagraph() {
    if (this.current.length === 0) {
      return;
    }
    this.paragraphs.push(this.current.join(" "));
    this.current = [];
  }
};

// src/views/panels/modules/FootnotePanelModule.ts
var FootnotePanelModule = class extends BasePanelModule {
  constructor(plugin) {
    super(plugin);
    this.id = "footnotes";
    this.displayName = MESSAGES.FOOTNOTE_VIEW_TITLE;
    this.icon = ICONS.FOOTNOTE_SVG;
    this.footnotes = [];
  }
  cleanupModuleData() {
    this.footnotes = [];
  }
  extractData(content) {
    this.footnotes = extractFootnotes(content);
  }
  renderContent(activeView) {
    if (!this.containerEl) return;
    if (this.footnotes.length === 0) {
      this.containerEl.createEl("div", {
        text: MESSAGES.NO_FOOTNOTES,
        cls: CSS_CLASSES.FOOTNOTE_PANEL_EMPTY
      });
      return;
    }
    this.renderFootnoteTable(activeView);
  }
  renderFootnoteTable(activeView) {
    if (!this.containerEl) return;
    const table = this.containerEl.createEl("table", {
      cls: CSS_CLASSES.FOOTNOTE_PANEL_CONTAINER
    });
    const tbody = table.createEl("tbody");
    for (const footnote of this.footnotes) {
      this.renderFootnoteRow(tbody, footnote, activeView);
    }
  }
  renderFootnoteRow(tbody, footnote, activeView) {
    const row = tbody.createEl("tr", {
      cls: CSS_CLASSES.FOOTNOTE_PANEL_ROW
    });
    const indexCell = row.createEl("td", {
      cls: CSS_CLASSES.FOOTNOTE_PANEL_INDEX,
      text: footnote.label
    });
    const contentCell = row.createEl("td", {
      cls: CSS_CLASSES.FOOTNOTE_PANEL_CONTENT
    });
    renderContentWithMath(
      contentCell,
      footnote.content,
      this.plugin.app,
      this.plugin,
      this.currentContext
    );
    this.setupReferenceClick(indexCell, footnote, activeView);
    this.setupDefinitionClick(contentCell, footnote, activeView);
  }
  setupReferenceClick(element, footnote, activeView) {
    var _a;
    element.addEventListener("click", () => {
      var _a2;
      try {
        if (!footnote.referencePosition) {
          new import_obsidian5.Notice(MESSAGES.FOOTNOTE_REFERENCE_NOT_FOUND);
          return;
        }
        this.focusEditor(activeView);
        const offset = (_a2 = footnote.referenceLength) != null ? _a2 : 0;
        const targetPosition = {
          line: footnote.referencePosition.line,
          ch: footnote.referencePosition.ch + offset
        };
        this.scrollToPosition(activeView, targetPosition, footnote.referencePosition.line);
      } catch (error) {
        handleError(error, "Scroll to footnote reference");
      }
    }, { signal: (_a = this.abortController) == null ? void 0 : _a.signal });
  }
  setupDefinitionClick(element, footnote, activeView) {
    var _a;
    element.addEventListener("click", () => {
      try {
        this.focusEditor(activeView);
        this.scrollToPosition(activeView, footnote.definitionPosition, footnote.definitionLine);
      } catch (error) {
        handleError(error, "Scroll to footnote definition");
      }
    }, { signal: (_a = this.abortController) == null ? void 0 : _a.signal });
  }
  focusEditor(activeView) {
    if (!activeView) return;
    const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
    const targetLeaf = leaves.find((leaf) => leaf.view === activeView);
    if (targetLeaf) {
      this.plugin.app.workspace.setActiveLeaf(targetLeaf, { focus: true });
    }
  }
  scrollToPosition(view, position, fallbackLine) {
    if (!view || !view.editor) {
      return;
    }
    const editor = view.editor;
    if (!position) {
      if (typeof fallbackLine === "number") {
        highlightLine2(view, fallbackLine);
      }
      return;
    }
    editor.setCursor(position);
    editor.scrollIntoView({ from: position, to: position }, true);
    highlightLine2(view, position.line, position);
  }
};

// src/views/panels/ListPanelView.ts
var VIEW_TYPE_LIST_PANEL = "list-panel-view";
var ListPanelView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.panels = [];
    this.activePanel = null;
    this.updateTimer = null;
    this.lastActiveMarkdownView = null;
    this.iconRowEl = null;
    this.contentContainerEl = null;
    this.plugin = plugin;
    this.hoverLinkSource = {
      display: "List Panel",
      defaultMod: true
    };
    this.initializePanels();
  }
  initializePanels() {
    const availablePanels = [];
    if (this.plugin.settings.moreExtendedSyntax) {
      const customLabelModule = new CustomLabelPanelModule(this.plugin);
      availablePanels.push({
        id: customLabelModule.id,
        displayName: customLabelModule.displayName,
        icon: customLabelModule.icon,
        module: customLabelModule
      });
    }
    const exampleListModule = new ExampleListPanelModule(this.plugin);
    availablePanels.push({
      id: exampleListModule.id,
      displayName: exampleListModule.displayName,
      icon: exampleListModule.icon,
      module: exampleListModule
    });
    const definitionListModule = new DefinitionListPanelModule(this.plugin);
    availablePanels.push({
      id: definitionListModule.id,
      displayName: definitionListModule.displayName,
      icon: definitionListModule.icon,
      module: definitionListModule
    });
    const footnoteModule = new FootnotePanelModule(this.plugin);
    availablePanels.push({
      id: footnoteModule.id,
      displayName: footnoteModule.displayName,
      icon: footnoteModule.icon,
      module: footnoteModule
    });
    const panelOrder = this.plugin.settings.panelOrder || ["custom-labels", "example-lists", "definition-lists", "footnotes"];
    this.panels = [];
    for (const panelId of panelOrder) {
      const panel = availablePanels.find((p) => p.id === panelId);
      if (panel) {
        this.panels.push(panel);
      }
    }
    for (const panel of availablePanels) {
      if (!this.panels.some((p) => p.id === panel.id)) {
        this.panels.push(panel);
      }
    }
  }
  getViewType() {
    return VIEW_TYPE_LIST_PANEL;
  }
  getDisplayText() {
    return "List Panel";
  }
  getIcon() {
    return ICONS.LIST_PANEL_ID;
  }
  async onOpen() {
    this.renderView();
    await this.updateView();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.scheduleUpdate();
      })
    );
    this.plugin.registerHoverLinkSource(VIEW_TYPE_LIST_PANEL, this.hoverLinkSource);
  }
  async onClose() {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    for (const panel of this.panels) {
      panel.module.destroy();
    }
    this.contentEl.empty();
  }
  renderView() {
    this.contentEl.empty();
    const viewContainer = this.contentEl.createDiv({
      cls: CSS_CLASSES.LIST_PANEL_VIEW_CONTAINER
    });
    this.iconRowEl = viewContainer.createDiv({
      cls: CSS_CLASSES.LIST_PANEL_ICON_ROW
    });
    for (const panel of this.panels) {
      const iconButton = this.iconRowEl.createDiv({
        cls: CSS_CLASSES.LIST_PANEL_ICON_BUTTON,
        attr: {
          "aria-label": panel.displayName,
          "data-panel-id": panel.id
        }
      });
      const iconContainer = iconButton.createDiv({
        cls: CSS_CLASSES.LIST_PANEL_ICON_CONTAINER
      });
      if (panel.id === "custom-labels") {
        const iconText = iconContainer.createSpan({
          cls: CSS_CLASSES.LIST_PANEL_ICON_CUSTOM_LABEL,
          text: "{::}"
        });
      } else if (panel.id === "example-lists") {
        const iconText = iconContainer.createSpan({
          cls: CSS_CLASSES.LIST_PANEL_ICON_EXAMPLE_LIST,
          text: "(@)"
        });
      } else if (panel.id === "definition-lists") {
        const iconText = iconContainer.createSpan({
          cls: "pandoc-icon-definition-list",
          text: "DL:"
        });
      } else if (panel.id === "footnotes") {
        iconContainer.createSpan({
          cls: CSS_CLASSES.LIST_PANEL_ICON_FOOTNOTE,
          text: "[^]"
        });
      } else {
        iconContainer.addClass(`pandoc-icon-${panel.id}`);
      }
      iconButton.addEventListener("click", () => {
        this.switchToPanel(panel);
      });
    }
    const separator = viewContainer.createEl("hr", {
      cls: CSS_CLASSES.LIST_PANEL_SEPARATOR
    });
    this.contentContainerEl = viewContainer.createDiv({
      cls: CSS_CLASSES.LIST_PANEL_CONTENT_CONTAINER
    });
    if (this.panels.length > 0) {
      this.switchToPanel(this.panels[0]);
    }
  }
  switchToPanel(panelInfo) {
    var _a, _b;
    if (this.activePanel === panelInfo.module) {
      return;
    }
    if (this.activePanel) {
      this.activePanel.onDeactivate();
    }
    const allButtons = (_a = this.iconRowEl) == null ? void 0 : _a.querySelectorAll(`.${CSS_CLASSES.LIST_PANEL_ICON_BUTTON}`);
    allButtons == null ? void 0 : allButtons.forEach((btn) => btn.removeClass(CSS_CLASSES.LIST_PANEL_ICON_ACTIVE));
    const activeButton = (_b = this.iconRowEl) == null ? void 0 : _b.querySelector(`[data-panel-id="${panelInfo.id}"]`);
    activeButton == null ? void 0 : activeButton.addClass(CSS_CLASSES.LIST_PANEL_ICON_ACTIVE);
    this.activePanel = panelInfo.module;
    if (this.contentContainerEl) {
      this.contentContainerEl.empty();
      this.activePanel.onActivate(this.contentContainerEl, this.lastActiveMarkdownView);
    }
  }
  scheduleUpdate() {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => {
      this.updateView();
    }, UI_CONSTANTS.UPDATE_DEBOUNCE_MS);
  }
  async updateView() {
    try {
      let markdownView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (markdownView && markdownView.file) {
        this.lastActiveMarkdownView = markdownView;
      }
      if (!markdownView || !markdownView.file) {
        markdownView = this.lastActiveMarkdownView;
      }
      if (this.activePanel && this.activePanel.shouldUpdate()) {
        this.activePanel.onUpdate(markdownView);
      }
    } catch (error) {
      handleError(error, "Update list panel view");
    }
  }
  getCustomLabels() {
    const customLabelPanel = this.panels.find((p) => p.id === "custom-labels");
    if (customLabelPanel && customLabelPanel.module instanceof CustomLabelPanelModule) {
      return customLabelPanel.module.getCustomLabels();
    }
    return [];
  }
  refreshPanels() {
    var _a;
    const activePanelId = (_a = this.activePanel) == null ? void 0 : _a.id;
    for (const panel of this.panels) {
      if (panel.module === this.activePanel) {
        panel.module.onDeactivate();
      }
      panel.module.destroy();
    }
    this.panels = [];
    this.activePanel = null;
    this.initializePanels();
    this.renderView();
    if (activePanelId) {
      const panelToRestore = this.panels.find((p) => p.id === activePanelId);
      if (panelToRestore) {
        this.switchToPanel(panelToRestore);
      }
    }
  }
};

// src/core/settings.ts
var PandocExtendedMarkdownSettingTab = class extends import_obsidian7.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderGeneralSettings(containerEl);
    this.renderPanelOrderSettings(containerEl);
  }
  renderGeneralSettings(containerEl) {
    new import_obsidian7.Setting(containerEl).setName("Strict Pandoc mode").setDesc("Enable strict pandoc formatting requirements. When enabled, lists must have empty lines before and after them, and capital letter lists require double spacing after markers.").addToggle((toggle) => toggle.setValue(this.plugin.settings.strictPandocMode).onChange(async (value) => {
      this.plugin.settings.strictPandocMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Auto-renumber lists").setDesc("Automatically renumber all list items when inserting a new item. This ensures proper sequential ordering of fancy lists (A, B, C... or i, ii, iii...) when you add items in the middle of a list.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRenumberLists).onChange(async (value) => {
      this.plugin.settings.autoRenumberLists = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian7.Setting(containerEl).setName("Custom Label List").setDesc("Should use it together with CustomLabelList.lua to enhance pandoc output. Enables custom label lists using {::LABEL} syntax. When strict pandoc mode is enabled, custom label lists must be preceded and followed by blank lines.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moreExtendedSyntax).onChange(async (value) => {
      this.plugin.settings.moreExtendedSyntax = value;
      await this.plugin.saveSettings();
      this.refreshListPanels();
    }));
  }
  renderPanelOrderSettings(containerEl) {
    containerEl.createEl("h2", { text: PANEL_SETTINGS.UI_TEXT.PANEL_ORDER_HEADING });
    const panelOrderSetting = new import_obsidian7.Setting(containerEl).setName("").setDesc(PANEL_SETTINGS.UI_TEXT.PANEL_ORDER_DESC);
    const infoEl = panelOrderSetting.infoEl;
    if (infoEl) {
      infoEl.addClass("pandoc-panel-order-info");
    }
    const flexContainer = panelOrderSetting.controlEl.createDiv({
      cls: "pandoc-panel-order-container"
    });
    const listEl = flexContainer.createDiv({
      cls: "pandoc-panel-order-list"
    });
    listEl.setAttribute("role", "listbox");
    listEl.tabIndex = 0;
    this.syncPanelOrder();
    this.renderPanelList(listEl);
    const buttons = this.createPanelOrderButtons(flexContainer);
    this.updateButtonStates(buttons);
    this.setupPanelOrderEventHandlers(listEl, buttons);
  }
  syncPanelOrder() {
    const currentOrder = [...this.plugin.settings.panelOrder];
    for (const panel of PANEL_SETTINGS.AVAILABLE_PANELS) {
      if (!currentOrder.includes(panel.id)) {
        currentOrder.push(panel.id);
      }
    }
    this.plugin.settings.panelOrder = currentOrder.filter(
      (id) => PANEL_SETTINGS.AVAILABLE_PANELS.some((panel) => panel.id === id)
    );
  }
  renderPanelList(listEl) {
    for (const panelId of this.plugin.settings.panelOrder) {
      const panelInfo = PANEL_SETTINGS.AVAILABLE_PANELS.find((p) => p.id === panelId);
      if (!panelInfo) continue;
      if (panelId === "custom-labels" && !this.plugin.settings.moreExtendedSyntax) {
        continue;
      }
      const itemEl = listEl.createDiv({
        cls: "pandoc-panel-order-item"
      });
      itemEl.setAttribute("role", "option");
      itemEl.dataset.id = panelId;
      itemEl.tabIndex = 0;
      const iconContainer = itemEl.createDiv({
        cls: "pandoc-panel-order-icon"
      });
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(panelInfo.icon, "image/svg+xml");
      const svgElement = svgDoc.documentElement;
      if (svgElement && svgElement.nodeName === "svg") {
        const clonedSvg = svgElement.cloneNode(true);
        clonedSvg.setAttribute("width", "20");
        clonedSvg.setAttribute("height", "20");
        iconContainer.appendChild(clonedSvg);
      }
      itemEl.createSpan({ text: panelInfo.displayName });
      if (panelId === this.selectedPanelId) {
        itemEl.classList.add("is-selected");
        itemEl.setAttribute("aria-selected", "true");
      } else {
        itemEl.setAttribute("aria-selected", "false");
      }
      itemEl.addEventListener("click", () => {
        this.selectedPanelId = panelId;
        this.display();
      });
      itemEl.addEventListener("keydown", (evt) => {
        if (evt.key === "Enter" || evt.key === " ") {
          evt.preventDefault();
          this.selectedPanelId = panelId;
          this.display();
        }
      });
    }
  }
  createPanelOrderButtons(container) {
    const btnWrap = container.createDiv({
      cls: "pandoc-panel-order-buttons"
    });
    const btnMoveUp = btnWrap.createEl("button", {
      text: PANEL_SETTINGS.UI_TEXT.BTN_MOVE_UP,
      cls: "pandoc-panel-order-button"
    });
    const btnMoveDown = btnWrap.createEl("button", {
      text: PANEL_SETTINGS.UI_TEXT.BTN_MOVE_DOWN,
      cls: "pandoc-panel-order-button"
    });
    const btnTop = btnWrap.createEl("button", {
      text: PANEL_SETTINGS.UI_TEXT.BTN_MOVE_TOP,
      cls: "pandoc-panel-order-button"
    });
    const btnBottom = btnWrap.createEl("button", {
      text: PANEL_SETTINGS.UI_TEXT.BTN_MOVE_BOTTOM,
      cls: "pandoc-panel-order-button"
    });
    const btnReset = btnWrap.createEl("button", {
      text: PANEL_SETTINGS.UI_TEXT.BTN_RESTORE_DEFAULT,
      cls: "pandoc-panel-order-button"
    });
    return {
      moveUp: btnMoveUp,
      moveDown: btnMoveDown,
      moveTop: btnTop,
      moveBottom: btnBottom,
      reset: btnReset
    };
  }
  updateButtonStates(buttons) {
    const visiblePanels = this.getVisiblePanels();
    const idx = this.getCurrentPanelIndex();
    buttons.moveUp.disabled = idx <= 0;
    buttons.moveDown.disabled = idx < 0 || idx >= visiblePanels.length - 1;
    buttons.moveTop.disabled = idx <= 0;
    buttons.moveBottom.disabled = idx < 0 || idx >= visiblePanels.length - 1;
  }
  setupPanelOrderEventHandlers(listEl, buttons) {
    buttons.moveUp.addEventListener("click", async () => {
      await this.movePanelUp();
    });
    buttons.moveDown.addEventListener("click", async () => {
      await this.movePanelDown();
    });
    buttons.moveTop.addEventListener("click", async () => {
      await this.movePanelToTop();
    });
    buttons.moveBottom.addEventListener("click", async () => {
      await this.movePanelToBottom();
    });
    buttons.reset.addEventListener("click", async () => {
      await this.resetPanelOrder();
    });
    listEl.addEventListener("keydown", (evt) => {
      if (!this.selectedPanelId) return;
      if (evt.key === "ArrowUp") {
        evt.preventDefault();
        buttons.moveUp.click();
      } else if (evt.key === "ArrowDown") {
        evt.preventDefault();
        buttons.moveDown.click();
      }
    });
  }
  async movePanelUp() {
    const i = this.plugin.settings.panelOrder.indexOf(this.selectedPanelId);
    if (i > 0) {
      const arr = this.plugin.settings.panelOrder;
      [arr[i - 1], arr[i]] = [arr[i], arr[i - 1]];
      await this.plugin.saveSettings();
      this.refreshListPanels();
      this.display();
    }
  }
  async movePanelDown() {
    const i = this.plugin.settings.panelOrder.indexOf(this.selectedPanelId);
    const arr = this.plugin.settings.panelOrder;
    if (i >= 0 && i < arr.length - 1) {
      [arr[i + 1], arr[i]] = [arr[i], arr[i + 1]];
      await this.plugin.saveSettings();
      this.refreshListPanels();
      this.display();
    }
  }
  async movePanelToTop() {
    const i = this.plugin.settings.panelOrder.indexOf(this.selectedPanelId);
    if (i > 0) {
      const arr = this.plugin.settings.panelOrder;
      const [item] = arr.splice(i, 1);
      arr.unshift(item);
      await this.plugin.saveSettings();
      this.refreshListPanels();
      this.display();
    }
  }
  async movePanelToBottom() {
    const i = this.plugin.settings.panelOrder.indexOf(this.selectedPanelId);
    const arr = this.plugin.settings.panelOrder;
    if (i >= 0 && i < arr.length - 1) {
      const [item] = arr.splice(i, 1);
      arr.push(item);
      await this.plugin.saveSettings();
      this.refreshListPanels();
      this.display();
    }
  }
  async resetPanelOrder() {
    this.plugin.settings.panelOrder = [...DEFAULT_SETTINGS.panelOrder];
    await this.plugin.saveSettings();
    this.selectedPanelId = void 0;
    this.refreshListPanels();
    this.display();
  }
  getVisiblePanels() {
    return this.plugin.settings.panelOrder.filter((id) => {
      if (id === "custom-labels" && !this.plugin.settings.moreExtendedSyntax) {
        return false;
      }
      return PANEL_SETTINGS.AVAILABLE_PANELS.some((panel) => panel.id === id);
    });
  }
  getCurrentPanelIndex() {
    if (!this.selectedPanelId) return -1;
    const visiblePanels = this.getVisiblePanels();
    return visiblePanels.indexOf(this.selectedPanelId);
  }
  refreshListPanels() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_LIST_PANEL);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (view && view.refreshPanels) {
        view.refreshPanels();
      }
    }
  }
};

// src/shared/types/processorConfig.ts
function createProcessorConfig(vaultConfig, pluginSettings) {
  var _a, _b, _c;
  const moreExtendedSyntax = (_a = pluginSettings.moreExtendedSyntax) != null ? _a : false;
  return {
    strictLineBreaks: (_b = vaultConfig.strictLineBreaks) != null ? _b : false,
    strictPandocMode: (_c = pluginSettings.strictPandocMode) != null ? _c : false,
    moreExtendedSyntax,
    enableHashLists: true,
    enableFancyLists: true,
    enableExampleLists: true,
    enableDefinitionLists: true,
    enableSuperSubscripts: true,
    enableCustomLabelLists: moreExtendedSyntax
  };
}

// src/live-preview/extension.ts
var import_state2 = require("@codemirror/state");
var import_view13 = require("@codemirror/view");
var import_obsidian9 = require("obsidian");

// src/core/state/pluginStateManager.ts
var PluginStateManager = class {
  constructor() {
    // Document-specific counters
    this.documentCounters = /* @__PURE__ */ new Map();
    // View state tracking per leaf
    this.viewStates = /* @__PURE__ */ new Map();
    // Mode change listeners
    this.modeChangeListeners = /* @__PURE__ */ new Set();
    // Track processed elements to prevent duplicate counter increments
    this.processedElements = /* @__PURE__ */ new WeakMap();
    // Track which documents need element reprocessing
    this.documentsNeedingReprocess = /* @__PURE__ */ new Set();
  }
  /**
   * Get or create counters for a document
   */
  getDocumentCounters(docPath) {
    if (!this.documentCounters.has(docPath)) {
      this.documentCounters.set(docPath, this.createEmptyCounters());
    }
    return this.documentCounters.get(docPath);
  }
  /**
   * Reset counters for a specific document
   */
  resetDocumentCounters(docPath) {
    if (this.documentCounters.has(docPath)) {
      const counters = this.documentCounters.get(docPath);
      counters.exampleCounter = 0;
      counters.exampleMap.clear();
      counters.exampleContent.clear();
      counters.hashCounter = 0;
      counters.placeholderContext.reset();
    }
    this.documentsNeedingReprocess.add(docPath);
  }
  /**
   * Clear counters for a document (remove from memory)
   */
  clearDocumentCounters(docPath) {
    this.documentCounters.delete(docPath);
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Update view state and detect mode/document changes
   */
  updateViewState(leaf) {
    var _a;
    const leafId = this.getLeafId(leaf);
    const view = leaf.view;
    const currentMode = this.detectViewMode(view);
    const currentPath = ((_a = view.file) == null ? void 0 : _a.path) || null;
    const previous = this.viewStates.get(leafId);
    const previousMode = (previous == null ? void 0 : previous.mode) || null;
    const previousPath = (previous == null ? void 0 : previous.filePath) || null;
    this.viewStates.set(leafId, {
      mode: currentMode,
      filePath: currentPath
    });
    const modeChanged = previousMode !== currentMode;
    const pathChanged = previousPath !== currentPath;
    if (modeChanged || pathChanged) {
      const event = {
        leafId,
        previousMode,
        currentMode,
        previousPath,
        currentPath
      };
      this.handleStateTransition(event);
      this.notifyModeChange(event);
      return event;
    }
    return null;
  }
  /**
   * Handle state transitions (e.g., reset counters)
   */
  handleStateTransition(event) {
    if (event.previousMode === "reading" && event.currentMode !== "reading") {
      if (event.previousPath) {
        if (this.documentCounters.has(event.previousPath)) {
          const counters = this.documentCounters.get(event.previousPath);
          counters.exampleCounter = 0;
          counters.exampleMap.clear();
          counters.exampleContent.clear();
          counters.hashCounter = 0;
        }
        this.documentsNeedingReprocess.add(event.previousPath);
      }
    }
    if (event.previousPath && event.currentPath && event.previousPath !== event.currentPath) {
      this.resetDocumentCounters(event.currentPath);
    }
    if (event.currentMode === "reading" && event.currentPath) {
      setTimeout(() => {
        this.clearReprocessFlag(event.currentPath);
      }, UI_CONSTANTS.STATE_TRANSITION_DELAY_MS);
    }
  }
  /**
   * Register a mode change listener
   */
  onModeChange(callback) {
    this.modeChangeListeners.add(callback);
    return () => {
      this.modeChangeListeners.delete(callback);
    };
  }
  /**
   * Notify all mode change listeners
   */
  notifyModeChange(event) {
    this.modeChangeListeners.forEach((callback) => callback(event));
  }
  /**
   * Increment example counter for a document
   */
  incrementExampleCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleCounter++;
    return counters.exampleCounter;
  }
  /**
   * Increment hash counter for a document
   */
  incrementHashCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.hashCounter++;
    return counters.hashCounter;
  }
  /**
   * Store labeled example data
   */
  setLabeledExample(docPath, label, number, content) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleMap.set(label, number);
    if (content) {
      counters.exampleContent.set(label, content);
    }
  }
  /**
   * Get labeled example number
   */
  getLabeledExampleNumber(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleMap.get(label);
  }
  /**
   * Get labeled example content
   */
  getLabeledExampleContent(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleContent.get(label);
  }
  /**
   * Mark an element as processed to prevent duplicate processing
   */
  markElementProcessed(element, key, value) {
    if (!this.processedElements.has(element)) {
      this.processedElements.set(element, /* @__PURE__ */ new Map());
    }
    this.processedElements.get(element).set(key, value);
  }
  /**
   * Check if an element has been processed
   */
  isElementProcessed(element, key, docPath) {
    if (docPath && this.documentsNeedingReprocess.has(docPath)) {
      return false;
    }
    return this.processedElements.has(element) && this.processedElements.get(element).has(key);
  }
  /**
   * Clear reprocess flag for a document after processing
   */
  clearReprocessFlag(docPath) {
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Get processed element data
   */
  getProcessedElementData(element, key) {
    if (this.processedElements.has(element)) {
      return this.processedElements.get(element).get(key);
    }
    return void 0;
  }
  /**
   * Scan all leaves and update states
   * Returns true if any mode changes were detected
   */
  scanAllLeaves(leaves) {
    var _a;
    let anyChanges = false;
    for (const leaf of leaves) {
      if (((_a = leaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
        const event = this.updateViewState(leaf);
        if (event) {
          anyChanges = true;
        }
      }
    }
    return anyChanges;
  }
  /**
   * Get placeholder context for a document (for testing compatibility)
   */
  getPlaceholderContext(docPath) {
    return this.getDocumentCounters(docPath).placeholderContext;
  }
  /**
   * Set custom labels for a document (for testing compatibility)
   */
  setCustomLabels(docPath, customLabels, rawToProcessed) {
    const counters = this.getDocumentCounters(docPath);
    counters.customLabels = customLabels;
    counters.rawToProcessed = rawToProcessed;
  }
  /**
   * Clear all states (for plugin unload)
   */
  clearAllStates() {
    this.documentCounters.clear();
    this.viewStates.clear();
    this.modeChangeListeners.clear();
  }
  /**
   * Create empty counters object
   */
  createEmptyCounters() {
    return {
      exampleCounter: 0,
      exampleMap: /* @__PURE__ */ new Map(),
      exampleContent: /* @__PURE__ */ new Map(),
      hashCounter: 0,
      placeholderContext: new PlaceholderContext(),
      customLabels: /* @__PURE__ */ new Map(),
      rawToProcessed: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Detect the current view mode from a MarkdownView
   */
  detectViewMode(view) {
    const state = view.getState();
    if ((state == null ? void 0 : state.mode) === "preview") return "reading";
    if ((state == null ? void 0 : state.mode) === "source") {
      return state.source ? "source" : "live";
    }
    return view.getMode() === "preview" ? "reading" : "live";
  }
  /**
   * Get a stable ID for a leaf
   */
  getLeafId(leaf) {
    var _a, _b;
    if ("id" in leaf && leaf.id) {
      return leaf.id;
    }
    const view = leaf.view;
    return `${(_b = (_a = view == null ? void 0 : view.file) == null ? void 0 : _a.path) != null ? _b : "unknown"}::${Math.random()}`;
  }
};
var pluginStateManager = new PluginStateManager();

// src/live-preview/pipeline/ProcessingPipeline.ts
var import_state = require("@codemirror/state");

// src/live-preview/pipeline/utils/codeDetection.ts
function detectCodeRegions(doc) {
  const regions = [];
  const text = doc.toString();
  detectCodeBlocks(text, regions);
  detectInlineCode(text, regions);
  detectMathRegions(text, regions);
  return regions;
}
function detectCodeBlocks(text, regions) {
  const codeBlockRegex = ListPatterns.CODE_BLOCK_FENCE;
  let match;
  let inCodeBlock = false;
  let codeBlockStart = -1;
  while ((match = codeBlockRegex.exec(text)) !== null) {
    if (!inCodeBlock) {
      inCodeBlock = true;
      codeBlockStart = match.index;
    } else {
      regions.push({
        from: codeBlockStart,
        to: match.index + match[0].length,
        type: "codeblock"
      });
      inCodeBlock = false;
      codeBlockStart = -1;
    }
  }
  if (inCodeBlock && codeBlockStart !== -1) {
    regions.push({
      from: codeBlockStart,
      to: text.length,
      type: "codeblock"
    });
  }
}
function detectInlineCode(text, regions) {
  let i = 0;
  while (i < text.length) {
    if (isInCodeBlock(i, regions)) {
      i++;
      continue;
    }
    if (text[i] === "`") {
      if (i > 0 && text[i - 1] === "\\") {
        i++;
        continue;
      }
      let j = i + 1;
      while (j < text.length) {
        if (text[j] === "`") {
          if (j > 0 && text[j - 1] === "\\") {
            j++;
            continue;
          }
          regions.push({
            from: i,
            to: j + 1,
            type: "inline-code"
          });
          i = j + 1;
          break;
        }
        j++;
      }
      if (j >= text.length) {
        i++;
      }
    } else {
      i++;
    }
  }
}
function isInCodeBlock(pos, regions) {
  for (const region of regions) {
    if (region.type === "codeblock" && pos >= region.from && pos < region.to) {
      return true;
    }
  }
  return false;
}
function isLineInCodeBlock(lineNumber, doc, codeRegions) {
  const line = doc.line(lineNumber);
  for (const region of codeRegions) {
    if (region.type === "codeblock") {
      if (line.from >= region.from && line.to <= region.to) {
        return true;
      }
    }
  }
  return false;
}
function isLineInCodeRegion(lineNumber, doc, codeRegions) {
  return isLineInCodeBlock(lineNumber, doc, codeRegions);
}
function isRangeCompletelyInCodeRegion(from, to, codeRegions) {
  for (const region of codeRegions) {
    if (from >= region.from && to <= region.to) {
      return true;
    }
  }
  return false;
}
function isRangeInCodeRegion(from, to, codeRegions) {
  return isRangeCompletelyInCodeRegion(from, to, codeRegions);
}
function detectMathRegions(text, regions) {
  let i = 0;
  while (i < text.length) {
    if (isInExistingRegion(i, regions)) {
      i++;
      continue;
    }
    if (text[i] === "$") {
      if (i > 0 && text[i - 1] === "\\") {
        i++;
        continue;
      }
      if (i + 1 < text.length && text[i + 1] === "$") {
        let j = i + 2;
        while (j < text.length - 1) {
          if (text[j] === "$" && text[j + 1] === "$") {
            if (j > 0 && text[j - 1] === "\\") {
              j++;
              continue;
            }
            regions.push({
              from: i,
              to: j + 2,
              type: "math"
            });
            i = j + 2;
            break;
          }
          j++;
        }
        if (j >= text.length - 1) {
          i += 2;
        }
      } else {
        let j = i + 1;
        while (j < text.length) {
          if (text[j] === "$") {
            if (j > 0 && text[j - 1] === "\\") {
              j++;
              continue;
            }
            regions.push({
              from: i,
              to: j + 1,
              type: "math"
            });
            i = j + 1;
            break;
          }
          j++;
        }
        if (j >= text.length) {
          i++;
        }
      }
    } else {
      i++;
    }
  }
}
function isInExistingRegion(pos, regions) {
  for (const region of regions) {
    if (pos >= region.from && pos < region.to) {
      return true;
    }
  }
  return false;
}

// src/live-preview/scanners/customLabelScanner.ts
function collectPlaceholders(doc, codeRegions) {
  const placeholdersInOrder = [];
  const seenPlaceholders = /* @__PURE__ */ new Set();
  for (let i = 1; i <= doc.lines; i++) {
    if (codeRegions && isLineInCodeRegion(i, doc, codeRegions)) {
      continue;
    }
    const line = doc.line(i);
    const lineText = line.text;
    const match = ListPatterns.isCustomLabelList(lineText);
    if (match) {
      const rawLabel = match[3];
      const matches = [...rawLabel.matchAll(ListPatterns.PLACEHOLDER_PATTERN)];
      for (const m of matches) {
        const placeholder = m[1];
        if (!seenPlaceholders.has(placeholder)) {
          placeholdersInOrder.push(placeholder);
          seenPlaceholders.add(placeholder);
        }
      }
    }
  }
  return placeholdersInOrder;
}
function shouldResetContext(placeholdersInOrder, existingMappings) {
  if (placeholdersInOrder.length !== existingMappings.size) {
    return true;
  }
  for (let i = 0; i < placeholdersInOrder.length; i++) {
    const placeholder = placeholdersInOrder[i];
    const expectedNumber = i + 1;
    const actualNumber = existingMappings.get(placeholder);
    if (actualNumber !== expectedNumber) {
      return true;
    }
  }
  return false;
}
function scanCustomLabels(doc, settings, placeholderContext, codeRegions) {
  const customLabels = /* @__PURE__ */ new Map();
  const rawToProcessed = /* @__PURE__ */ new Map();
  const duplicateLabels = /* @__PURE__ */ new Set();
  const duplicateLineInfo = /* @__PURE__ */ new Map();
  const seenLabels = /* @__PURE__ */ new Map();
  const context = placeholderContext || new PlaceholderContext();
  if (!settings.moreExtendedSyntax) {
    return { customLabels, rawToProcessed, duplicateLabels, duplicateLineInfo, placeholderContext: context };
  }
  const placeholdersInOrder = collectPlaceholders(doc, codeRegions);
  const existingMappings = context.getPlaceholderMappings();
  if (shouldResetContext(placeholdersInOrder, existingMappings)) {
    context.reset();
  }
  for (let i = 1; i <= doc.lines; i++) {
    if (codeRegions && isLineInCodeRegion(i, doc, codeRegions)) {
      continue;
    }
    const line = doc.line(i);
    const lineText = line.text;
    const match = ListPatterns.isCustomLabelList(lineText);
    if (match) {
      const rawLabel = match[3];
      const processedLabel = context.processLabel(rawLabel);
      rawToProcessed.set(rawLabel, processedLabel);
      const contentStart = match[0].length;
      const content = lineText.substring(contentStart).trim();
      if (seenLabels.has(processedLabel)) {
        duplicateLabels.add(processedLabel);
        if (!duplicateLineInfo.has(processedLabel)) {
          const firstOccurrence = seenLabels.get(processedLabel);
          duplicateLineInfo.set(processedLabel, {
            firstLine: firstOccurrence.line,
            firstContent: firstOccurrence.content
          });
        }
      } else {
        seenLabels.set(processedLabel, {
          line: i,
          // line number (1-based)
          content
        });
        if (content) {
          customLabels.set(processedLabel, content);
        }
      }
    }
  }
  return { customLabels, rawToProcessed, duplicateLabels, duplicateLineInfo, placeholderContext: context };
}

// src/live-preview/validators/listBlockValidator.ts
var ListBlockValidator = class {
  static isListItemForValidation(line) {
    return !!(ListPatterns.isHashList(line) || // Hash auto-numbering
    ListPatterns.isFancyList(line) || // Fancy lists
    ListPatterns.isExampleList(line) || // Example lists
    ListPatterns.isCustomLabelList(line) || // Custom label lists
    ListPatterns.isDefinitionMarker(line) || // Definition lists
    line.match(ListPatterns.UNORDERED_LIST) || // Unordered lists
    line.match(ListPatterns.NUMBERED_LIST));
  }
  static isListContinuation(line, prevWasListItem) {
    if (!prevWasListItem) return false;
    if (this.isListItemForValidation(line)) return false;
    const indentMatch = line.match(/^(\s+)/);
    if (indentMatch) {
      const indent = indentMatch[1];
      return indent.length >= 2 || indent.includes("	");
    }
    return false;
  }
  static validateListBlocks(lines, settings) {
    const invalidListBlocks = /* @__PURE__ */ new Set();
    if (!settings.strictPandocMode) {
      return invalidListBlocks;
    }
    let listBlockStart = -1;
    let inListBlock = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isCurrentList = this.isListItemForValidation(line);
      const prevWasListOrContinuation = i > 0 && (this.isListItemForValidation(lines[i - 1]) || this.isListContinuation(lines[i - 1], inListBlock) || lines[i - 1].trim() === "");
      const isContinuation = this.isListContinuation(line, inListBlock);
      const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && !ListPatterns.isDefinitionMarker(lines[i - 1]) && !ListPatterns.isIndentedContent(lines[i - 1]) && ListPatterns.isDefinitionMarker(line);
      if (isCurrentList && listBlockStart === -1) {
        listBlockStart = i;
        inListBlock = true;
        if (i > 0 && lines[i - 1].trim() !== "" && !prevIsDefinitionTerm) {
          for (let j = i; j < lines.length && (this.isListItemForValidation(lines[j]) || this.isListContinuation(lines[j], true)); j++) {
            invalidListBlocks.add(j);
          }
        }
      } else if (!isCurrentList && !isContinuation && listBlockStart !== -1) {
        if (line.trim() !== "") {
          for (let j = listBlockStart; j < i; j++) {
            invalidListBlocks.add(j);
          }
        }
        listBlockStart = -1;
        inListBlock = false;
      }
      if (isCurrentList) {
        const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
        if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
          for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
            invalidListBlocks.add(j);
          }
          for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
            invalidListBlocks.add(j);
          }
        }
      }
    }
    return invalidListBlocks;
  }
};
function validateListBlocks(doc) {
  const lines = doc.toString().split("\n");
  const zeroBasedIndices = ListBlockValidator.validateListBlocks(lines, { strictPandocMode: true });
  const oneBasedLineNumbers = /* @__PURE__ */ new Set();
  for (const index of zeroBasedIndices) {
    oneBasedLineNumbers.add(index + 1);
  }
  return oneBasedLineNumbers;
}

// src/live-preview/pipeline/ProcessingPipeline.ts
function processExampleLine(line, lineNum, counter, result, duplicateLineNumbers) {
  var _a;
  const exampleMatch = ListPatterns.isExampleList(line);
  if (exampleMatch && exampleMatch.length >= 5) {
    const indent = exampleMatch[1] || "";
    const fullMarker = exampleMatch[2] || "";
    const label = exampleMatch[3] || "";
    const space = exampleMatch[4] || "";
    const content = line.substring(
      indent.length + fullMarker.length + space.length
    );
    if (label && result.exampleLabels.has(label)) {
      duplicateLineNumbers.add(lineNum);
      if (!result.duplicateLabels.has(label)) {
        const firstOccurrenceNumber = result.exampleLabels.get(label);
        const firstLine = ((_a = Array.from(result.exampleLineNumbers.entries()).find(([, num]) => num === firstOccurrenceNumber)) == null ? void 0 : _a[0]) || 0;
        result.duplicateLabels.set(label, firstLine);
        result.duplicateLabelContent.set(label, result.exampleContent.get(label) || "");
      }
    } else if (label) {
      result.exampleLabels.set(label, counter.value);
      result.exampleContent.set(label, content);
    }
    result.exampleLineNumbers.set(lineNum, counter.value);
    counter.value++;
  }
}
function createExampleScanResult() {
  return {
    exampleLabels: /* @__PURE__ */ new Map(),
    exampleContent: /* @__PURE__ */ new Map(),
    exampleLineNumbers: /* @__PURE__ */ new Map(),
    duplicateLabels: /* @__PURE__ */ new Map(),
    duplicateLabelContent: /* @__PURE__ */ new Map()
  };
}
function scanExampleLabelsFromDoc(doc, settings, codeRegions) {
  const result = createExampleScanResult();
  const counter = { value: 1 };
  const lines = doc.toString().split("\n");
  const invalidLines = settings.strictPandocMode ? validateListBlocks(doc) : /* @__PURE__ */ new Set();
  const duplicateLineNumbers = /* @__PURE__ */ new Set();
  for (let i = 0; i < lines.length; i++) {
    if (codeRegions && isLineInCodeRegion(i + 1, doc, codeRegions)) {
      continue;
    }
    if (!invalidLines.has(i + 1)) {
      processExampleLine(lines[i], i + 1, counter, result, duplicateLineNumbers);
    }
  }
  return { ...result, duplicateLineNumbers };
}
var ProcessingPipeline = class {
  // Component for lifecycle management
  constructor(stateManager, app, component) {
    this.structuralProcessors = [];
    this.inlineProcessors = [];
    this.stateManager = stateManager;
    this.app = app;
    this.component = component;
  }
  /**
   * Register a structural processor
   */
  registerStructuralProcessor(processor) {
    this.structuralProcessors.push(processor);
    this.structuralProcessors.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Register an inline processor
   */
  registerInlineProcessor(processor) {
    this.inlineProcessors.push(processor);
    this.inlineProcessors.sort((a, b) => a.priority - b.priority);
  }
  /**
   * Process the document through both phases
   */
  process(view, settings) {
    const context = this.createContext(view, settings);
    this.processStructural(context);
    this.processInline(context);
    return this.buildDecorationSet(context);
  }
  /**
   * Create the processing context with pre-scanned data
   */
  // Helper: Get document path from workspace
  getDocumentPath() {
    var _a;
    const workspace = (_a = this.app) == null ? void 0 : _a.workspace;
    const activeFile = workspace == null ? void 0 : workspace.getActiveFile();
    return (activeFile == null ? void 0 : activeFile.path) || null;
  }
  // Helper: Get or create placeholder context
  getPlaceholderContext(docPath) {
    return docPath ? this.stateManager.getDocumentCounters(docPath).placeholderContext : new PlaceholderContext();
  }
  // Helper: Get custom scan result
  getCustomScanResult(doc, settings, placeholderContext, codeRegions) {
    return settings.moreExtendedSyntax ? scanCustomLabels(doc, settings, placeholderContext, codeRegions) : {
      customLabels: /* @__PURE__ */ new Map(),
      rawToProcessed: /* @__PURE__ */ new Map(),
      duplicateLabels: /* @__PURE__ */ new Set(),
      placeholderContext
    };
  }
  // Helper: Build final context object
  buildContext(view, settings, exampleScanResult, customScanResult, invalidLines) {
    return {
      document: view.state.doc,
      view,
      settings,
      app: this.app,
      component: this.component,
      // Scanned data
      exampleLabels: exampleScanResult.exampleLabels,
      exampleContent: exampleScanResult.exampleContent,
      exampleLineNumbers: exampleScanResult.exampleLineNumbers,
      duplicateExampleLabels: exampleScanResult.duplicateLabels,
      duplicateExampleContent: exampleScanResult.duplicateLabelContent,
      duplicateExampleLineNumbers: exampleScanResult.duplicateLineNumbers,
      customLabels: customScanResult.customLabels,
      rawToProcessed: customScanResult.rawToProcessed,
      duplicateCustomLabels: customScanResult.duplicateLabels,
      duplicateCustomLineInfo: customScanResult.duplicateLineInfo,
      placeholderContext: customScanResult.placeholderContext,
      invalidLines,
      // Processing metadata
      contentRegions: [],
      structuralDecorations: [],
      inlineDecorations: [],
      // State tracking
      hashCounter: { value: 1 },
      definitionState: {
        lastWasItem: false,
        pendingBlankLine: false
      }
    };
  }
  createContext(view, settings) {
    const doc = view.state.doc;
    const docPath = this.getDocumentPath();
    const codeRegions = detectCodeRegions(doc);
    const exampleScanResult = scanExampleLabelsFromDoc(doc, settings, codeRegions);
    const placeholderContext = this.getPlaceholderContext(docPath);
    const customScanResult = this.getCustomScanResult(doc, settings, placeholderContext, codeRegions);
    const invalidLines = settings.strictPandocMode ? validateListBlocks(doc) : /* @__PURE__ */ new Set();
    if (docPath && customScanResult.placeholderContext) {
      const counters = this.stateManager.getDocumentCounters(docPath);
      counters.placeholderContext = customScanResult.placeholderContext;
    }
    const context = this.buildContext(view, settings, exampleScanResult, customScanResult, invalidLines);
    context.codeRegions = codeRegions;
    return context;
  }
  /**
   * Phase 1: Process structural elements
   */
  processStructural(context) {
    const doc = context.document;
    const numLines = doc.lines;
    const codeRegions = context.codeRegions || [];
    for (let lineNum = 1; lineNum <= numLines; lineNum++) {
      const line = doc.line(lineNum);
      if (context.invalidLines.has(lineNum)) {
        continue;
      }
      if (isLineInCodeRegion(lineNum, doc, codeRegions)) {
        continue;
      }
      if (line.text.trim() === "" && context.listContext) {
        context.listContext = void 0;
      }
      let processed = false;
      for (const processor of this.structuralProcessors) {
        if (processor.canProcess(line, context)) {
          const result = processor.process(line, context);
          context.structuralDecorations.push(...result.decorations);
          if (result.contentRegion) {
            context.contentRegions.push(result.contentRegion);
          }
          if (result.skipFurtherProcessing) {
            processed = true;
            break;
          }
        }
      }
      if (!processed) {
        context.contentRegions.push({
          from: line.from,
          to: line.to,
          type: "normal"
        });
      }
    }
  }
  /**
   * Phase 2: Process inline content within marked regions
   */
  processInline(context) {
    const docLength = context.document.length;
    const codeRegions = context.codeRegions || [];
    for (const region of context.contentRegions) {
      if (!this.isValidRegion(region, docLength)) {
        continue;
      }
      this.processRegion(region, context, docLength, codeRegions);
    }
  }
  /**
   * Check if a content region is valid for processing
   */
  isValidRegion(region, docLength) {
    return region.from < region.to && region.from >= 0 && region.to <= docLength;
  }
  /**
   * Process a single content region for inline matches
   */
  processRegion(region, context, docLength, codeRegions) {
    const text = context.document.sliceString(region.from, region.to);
    const allMatches = this.collectMatches(region, text, context, codeRegions);
    allMatches.sort((a, b) => a.match.from - b.match.from);
    this.processMatches(allMatches, region, context, docLength);
  }
  /**
   * Collect all inline matches from all processors for a region
   */
  collectMatches(region, text, context, codeRegions) {
    const allMatches = [];
    for (const processor of this.inlineProcessors) {
      if (!processor.supportedRegions.has(region.type)) continue;
      const matches = processor.findMatches(text, region, context);
      for (const match of matches) {
        if (this.isValidMatch(match, text, region, codeRegions)) {
          allMatches.push({ match, processor });
        }
      }
    }
    return allMatches;
  }
  /**
   * Check if a match is valid and not in a code region
   */
  isValidMatch(match, text, region, codeRegions) {
    if (match.from < 0 || match.to > text.length || match.from > match.to) {
      return false;
    }
    const absoluteFrom = region.from + match.from;
    const absoluteTo = region.from + match.to;
    return !isRangeInCodeRegion(absoluteFrom, absoluteTo, codeRegions);
  }
  /**
   * Process matched inline patterns and create decorations
   */
  processMatches(allMatches, region, context, docLength) {
    let lastEnd = 0;
    for (const { match, processor } of allMatches) {
      if (match.from < lastEnd) continue;
      const decoration = processor.createDecoration(match, context);
      const absoluteFrom = region.from + match.from;
      const absoluteTo = region.from + match.to;
      if (absoluteFrom >= 0 && absoluteTo <= docLength && absoluteFrom <= absoluteTo) {
        context.inlineDecorations.push({
          from: absoluteFrom,
          to: absoluteTo,
          decoration
        });
      }
      lastEnd = match.to;
    }
  }
  /**
   * Build the final decoration set from both phases
   */
  buildDecorationSet(context) {
    const builder = new import_state.RangeSetBuilder();
    const docLength = context.document.length;
    const allDecorations = [
      ...context.structuralDecorations,
      ...context.inlineDecorations
    ].sort((a, b) => a.from - b.from || a.to - b.to);
    for (const { from, to, decoration } of allDecorations) {
      if (from < 0 || to > docLength || from > to) {
        handleError(new Error(`Invalid decoration position: from=${from}, to=${to}, docLength=${docLength}`), "ProcessingPipeline.buildDecorationSet");
        continue;
      }
      const safeFrom = Math.floor(from);
      const safeTo = Math.floor(to);
      try {
        builder.add(safeFrom, safeTo, decoration);
      } catch (e) {
        handleError(e, "ProcessingPipeline.buildDecorationSet");
      }
    }
    return builder.finish();
  }
  /**
   * Clear all registered processors
   */
  clear() {
    this.structuralProcessors = [];
    this.inlineProcessors = [];
  }
  /**
   * Get registered processor counts for debugging
   */
  getProcessorCounts() {
    return {
      structural: this.structuralProcessors.length,
      inline: this.inlineProcessors.length
    };
  }
};

// src/live-preview/widgets/BaseWidget.ts
var import_view = require("@codemirror/view");
var import_obsidian8 = require("obsidian");
var BaseWidget = class extends import_view.WidgetType {
  constructor(view, pos) {
    super();
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  /**
   * Creates the root DOM element with common setup.
   * Subclasses should override this to create their specific DOM structure.
   */
  toDOM() {
    const element = this.createRootElement();
    this.applyStyles(element);
    this.setContent(element);
    this.setupTooltip(element);
    this.setupClickHandler(element);
    this.setupAdditionalHandlers(element);
    return element;
  }
  /**
   * Creates the root element for the widget.
   * Override to use different element types (e.g., 'sup', 'sub').
   */
  createRootElement() {
    return document.createElement("span");
  }
  /**
   * Sets up tooltip for the element if needed.
   * Override to add tooltips.
   */
  setupTooltip(element) {
  }
  /**
   * Sets up the standard click handler for cursor positioning.
   * Can be overridden for custom click behavior.
   */
  setupClickHandler(element) {
    if (this.view && this.pos !== void 0) {
      element.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
  }
  /**
   * Hook for additional event handlers.
   * Override to add custom event handling.
   */
  setupAdditionalHandlers(element) {
  }
  /**
   * Helper method to create inner elements with classes.
   */
  createElement(tag, className, textContent) {
    const element = document.createElement(tag);
    if (className) element.className = className;
    if (textContent) element.textContent = textContent;
    return element;
  }
  /**
   * Helper method to add a simple tooltip.
   */
  addSimpleTooltip(element, text) {
    (0, import_obsidian8.setTooltip)(element, text, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
  }
  /**
   * Helper method to add a rendered hover preview.
   */
  addRenderedHoverPreview(element, content, app, component, context, cssClass) {
    setupRenderedHoverPreview(
      element,
      content,
      app,
      component,
      context,
      cssClass || "hover-popover-content",
      this.controller.signal
    );
  }
  /**
   * Cleanup method called when the widget is destroyed.
   */
  destroy() {
    this.controller.abort();
  }
  /**
   * Determines whether to ignore events.
   * Default: allow all events to pass through.
   */
  ignoreEvent() {
    return false;
  }
};

// src/live-preview/widgets/listWidgets.ts
var FancyListMarkerWidget = class extends BaseWidget {
  constructor(marker, delimiter, view, pos) {
    super(view, pos);
    this.marker = marker;
    this.delimiter = delimiter;
  }
  applyStyles(element) {
    element.className = COMPOSITE_CSS.STANDARD_LIST_MARKER_CLASSES;
  }
  setContent(element) {
    const innerSpan = this.createElement(
      "span",
      CSS_CLASSES.LIST_NUMBER,
      this.marker + this.delimiter + " "
    );
    element.appendChild(innerSpan);
  }
  eq(other) {
    return other.marker === this.marker && other.delimiter === this.delimiter && other.pos === this.pos;
  }
};
var HashListMarkerWidget = class extends BaseWidget {
  constructor(number, view, pos) {
    super(view, pos);
    this.number = number;
  }
  applyStyles(element) {
    element.className = COMPOSITE_CSS.STANDARD_LIST_MARKER_CLASSES;
  }
  setContent(element) {
    const innerSpan = this.createElement(
      "span",
      CSS_CLASSES.LIST_NUMBER,
      `${this.number}. `
    );
    element.appendChild(innerSpan);
  }
  eq(other) {
    return other.number === this.number && other.pos === this.pos;
  }
};
var ExampleListMarkerWidget = class extends BaseWidget {
  constructor(number, label, view, pos) {
    super(view, pos);
    this.number = number;
    this.label = label;
  }
  applyStyles(element) {
    element.className = `${COMPOSITE_CSS.STANDARD_LIST_MARKER_CLASSES} ${CSS_CLASSES.EXAMPLE_REF}`;
  }
  setContent(element) {
    const innerSpan = this.createElement(
      "span",
      CSS_CLASSES.LIST_NUMBER,
      `(${this.number}) `
    );
    element.appendChild(innerSpan);
  }
  setupTooltip(element) {
    const tooltipText = this.label ? `@${this.label}` : "@";
    this.addSimpleTooltip(element, tooltipText);
  }
  eq(other) {
    return other.number === this.number && other.label === this.label && other.pos === this.pos;
  }
};
var DuplicateExampleLabelWidget = class extends BaseWidget {
  constructor(label, originalLine, originalLineContent, view, pos) {
    super(view, pos);
    this.label = label;
    this.originalLine = originalLine;
    this.originalLineContent = originalLineContent;
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.DUPLICATE_MARKERS;
  }
  setContent(element) {
    element.textContent = `(@${this.label})`;
  }
  setupTooltip(element) {
    let lineContent = this.originalLineContent.trim();
    if (lineContent.length > DECORATION_STYLES.LINE_TRUNCATION_LIMIT) {
      lineContent = lineContent.substring(0, DECORATION_STYLES.LINE_TRUNCATION_LIMIT) + "...";
    }
    const tooltipText = `Duplicate index at line ${this.originalLine}: ${lineContent}`;
    this.addSimpleTooltip(element, tooltipText);
  }
  eq(other) {
    return other.label === this.label && other.originalLine === this.originalLine && other.originalLineContent === this.originalLineContent && other.pos === this.pos;
  }
};

// src/live-preview/widgets/definitionWidget.ts
var DefinitionBulletWidget = class extends BaseWidget {
  constructor(view, pos) {
    super(view, pos);
  }
  applyStyles(element) {
    element.className = "cm-formatting cm-formatting-list cm-list-1 pandoc-list-marker";
  }
  setContent(element) {
    element.textContent = "\u2022 ";
  }
  eq(other) {
    return other.pos === this.pos;
  }
};

// src/live-preview/widgets/referenceWidget.ts
var ExampleReferenceWidget = class extends BaseWidget {
  constructor(number, tooltipText, view, pos, app, component, context) {
    super(view, pos);
    this.number = number;
    this.tooltipText = tooltipText;
    this.app = app;
    this.component = component;
    this.context = context;
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.EXAMPLE_REF;
  }
  setContent(element) {
    element.textContent = `(${this.number})`;
  }
  setupTooltip(element) {
    if (this.tooltipText) {
      if (this.app && this.component) {
        this.addRenderedHoverPreview(
          element,
          this.tooltipText,
          this.app,
          this.component,
          this.context,
          CSS_CLASSES.HOVER_POPOVER_CONTENT
        );
      } else {
        this.addSimpleTooltip(element, this.tooltipText);
      }
    }
  }
  eq(other) {
    return other.number === this.number && other.tooltipText === this.tooltipText && other.pos === this.pos && other.app === this.app && other.component === this.component && other.context === this.context;
  }
};

// src/live-preview/widgets/formatWidgets.ts
var SuperscriptWidget = class extends BaseWidget {
  constructor(content, view, pos) {
    super(view, pos);
    this.content = content;
  }
  createRootElement() {
    return document.createElement("sup");
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.SUPERSCRIPT;
  }
  setContent(element) {
    element.textContent = this.content;
  }
  eq(other) {
    return other.content === this.content && other.pos === this.pos;
  }
};
var SubscriptWidget = class extends BaseWidget {
  constructor(content, view, pos) {
    super(view, pos);
    this.content = content;
  }
  createRootElement() {
    return document.createElement("sub");
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.SUBSCRIPT;
  }
  setContent(element) {
    element.textContent = this.content;
  }
  eq(other) {
    return other.content === this.content && other.pos === this.pos;
  }
};

// src/live-preview/widgets/customLabelWidget.ts
var CustomLabelMarkerWidget = class extends BaseWidget {
  constructor(label, view, position) {
    super(view, position);
    this.label = label;
  }
  applyStyles(element) {
    element.className = COMPOSITE_CSS.STANDARD_LIST_MARKER_CLASSES;
    if (this.view && this.pos !== void 0) {
      element.classList.add(CSS_CLASSES.CUSTOM_LABEL_REF_CLICKABLE);
    }
  }
  setContent(element) {
    const innerSpan = this.createElement("span", "list-number", `(${this.label}) `);
    element.appendChild(innerSpan);
  }
  setupClickHandler(element) {
    if (this.view && this.pos !== void 0) {
      element.addEventListener("click", () => {
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
  }
  eq(other) {
    return other.label === this.label && other.pos === this.pos;
  }
};
var CustomLabelPartialWidget = class extends BaseWidget {
  constructor(text, view, position) {
    super(view, position);
    this.text = text;
  }
  applyStyles(element) {
    element.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
  }
  setContent(element) {
    element.textContent = this.text;
  }
  eq(other) {
    return other.text === this.text && other.pos === this.pos;
  }
};
var CustomLabelProcessedWidget = class extends BaseWidget {
  constructor(text, view, position) {
    super(view, position);
    this.text = text;
  }
  applyStyles(element) {
    element.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
  }
  setContent(element) {
    element.textContent = this.text;
  }
  eq(other) {
    return other.text === this.text && other.pos === this.pos;
  }
};
var CustomLabelInlineNumberWidget = class extends BaseWidget {
  constructor(number, view) {
    super(view, void 0);
    this.number = number;
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.INLINE_PLACEHOLDER_NUMBER;
  }
  setContent(element) {
    element.textContent = this.number;
  }
  setupClickHandler(element) {
  }
  eq(other) {
    return other.number === this.number;
  }
};
var CustomLabelReferenceWidget = class extends BaseWidget {
  constructor(label, content, view, position, app, component, context) {
    super(view, position);
    this.label = label;
    this.content = content;
    this.app = app;
    this.component = component;
    this.context = context;
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.EXAMPLE_REF;
    element.setAttribute("data-custom-label-ref", this.label);
  }
  setContent(element) {
    element.textContent = `(${this.label})`;
  }
  setupTooltip(element) {
    if (this.content) {
      if (this.app && this.component) {
        this.addRenderedHoverPreview(
          element,
          this.content,
          this.app,
          this.component,
          this.context,
          CSS_CLASSES.HOVER_POPOVER_CONTENT
        );
      } else {
        element.setAttribute("title", this.content);
      }
    }
  }
  eq(other) {
    return other.label === this.label && other.content === this.content && other.pos === this.pos && other.app === this.app && other.component === this.component && other.context === this.context;
  }
};
var DuplicateCustomLabelWidget = class extends BaseWidget {
  /**
   * @param rawLabel - The raw label text (e.g., "P(#a)")
   * @param originalLine - Line number of the first occurrence
   * @param originalLineContent - Content of the first occurrence line
   * @param view - Optional editor view for cursor positioning
   * @param pos - Optional position for cursor placement
   */
  constructor(rawLabel, originalLine, originalLineContent, view, pos) {
    super(view, pos);
    this.rawLabel = rawLabel;
    this.originalLine = originalLine;
    this.originalLineContent = originalLineContent;
  }
  applyStyles(element) {
    element.className = CSS_CLASSES.DUPLICATE_MARKERS;
  }
  setContent(element) {
    element.textContent = `{::${this.rawLabel}}`;
  }
  setupTooltip(element) {
    let lineContent = this.originalLineContent.trim();
    if (lineContent.length > DECORATION_STYLES.LINE_TRUNCATION_LIMIT) {
      lineContent = lineContent.substring(0, DECORATION_STYLES.LINE_TRUNCATION_LIMIT) + "...";
    }
    const tooltipText = `Duplicate label at line ${this.originalLine}: ${lineContent}`;
    this.addSimpleTooltip(element, tooltipText);
  }
  eq(other) {
    return other.rawLabel === this.rawLabel && other.originalLine === this.originalLine && other.originalLineContent === this.originalLineContent && other.pos === this.pos;
  }
};

// src/live-preview/widgets/ListContinuationIndentWidget.ts
var import_view2 = require("@codemirror/view");
var ListContinuationIndentWidget = class extends import_view2.WidgetType {
  constructor(width, listLevel) {
    super();
    this.width = Math.max(width, 0);
    this.listLevel = listLevel;
  }
  eq(other) {
    return this.width === other.width && this.listLevel === other.listLevel;
  }
  toDOM() {
    const outerSpacing = document.createElement("span");
    outerSpacing.className = "cm-indent-spacing";
    const innerSpacing = document.createElement("span");
    innerSpacing.className = "cm-indent-spacing";
    outerSpacing.appendChild(innerSpacing);
    const indentSpan = document.createElement("span");
    indentSpan.className = `cm-hmd-list-indent cm-hmd-list-indent-${this.getClampedLevel()} ${CSS_CLASSES.LIST_CONTINUATION_WIDGET}`;
    indentSpan.style.width = `${this.width}px`;
    indentSpan.style.whiteSpace = "pre";
    indentSpan.textContent = "\xA0";
    indentSpan.setAttribute("aria-hidden", "true");
    innerSpacing.appendChild(indentSpan);
    return outerSpacing;
  }
  ignoreEvent() {
    return false;
  }
  getClampedLevel() {
    if (this.listLevel < 1) {
      return 1;
    }
    if (this.listLevel > 4) {
      return 4;
    }
    return this.listLevel;
  }
};

// src/live-preview/pipeline/structural/BaseStructuralProcessor.ts
var import_view3 = require("@codemirror/view");
var BaseStructuralProcessor = class {
  /**
   * Check if cursor is within a marker range
   */
  isCursorInMarker(markerStart, markerEnd, context) {
    var _a, _b;
    const cursorPos = (_b = (_a = context.view.state.selection) == null ? void 0 : _a.main) == null ? void 0 : _b.head;
    return cursorPos !== void 0 && cursorPos >= markerStart && cursorPos < markerEnd;
  }
  /**
   * Check if strict mode validation should block processing
   */
  isInvalidInStrictMode(line, context) {
    return context.settings.strictPandocMode && context.invalidLines.has(line.number);
  }
  /**
   * Create standard line decoration for lists
   */
  createLineDecoration(line, additionalClasses) {
    const classes = [
      CSS_CLASSES.LIST_LINE,
      CSS_CLASSES.LIST_LINE_1,
      CSS_CLASSES.PANDOC_LIST_LINE,
      additionalClasses
    ].filter(Boolean).join(" ");
    return {
      from: line.from,
      to: line.from,
      decoration: import_view3.Decoration.line({ class: classes })
    };
  }
  /**
   * Create content area wrapping decoration
   */
  createContentMarkDecoration(contentStart, contentEnd, listLevel = 1) {
    const className = listLevel === 1 ? CSS_CLASSES.CM_LIST_1 : listLevel === 2 ? CSS_CLASSES.CM_LIST_2 : listLevel === 3 ? CSS_CLASSES.CM_LIST_3 : CSS_CLASSES.CM_LIST_1;
    return {
      from: contentStart,
      to: contentEnd,
      decoration: import_view3.Decoration.mark({ class: className })
    };
  }
  /**
   * Create marker replacement decoration
   */
  createMarkerReplacement(markerStart, markerEnd, widget) {
    return {
      from: markerStart,
      to: markerEnd,
      decoration: import_view3.Decoration.replace({
        widget,
        inclusive: false
      })
    };
  }
  /**
   * Create content region for inline processing
   */
  createContentRegion(contentStart, contentEnd, parentStructure, metadata) {
    return {
      from: contentStart,
      to: contentEnd,
      type: "list-content",
      parentStructure,
      metadata
    };
  }
  /**
   * Set list context for continuation line detection
   */
  setListContext(context, contentStartColumn, listLevel, parentStructure) {
    context.listContext = {
      isInList: true,
      contentStartColumn,
      listLevel,
      parentStructure
    };
  }
  /**
   * Standard pattern for processing list lines
   * This provides the common structure that most list processors follow
   */
  processStandardList(line, context, markerStart, markerEnd, contentStart, widget, parentStructure, listLevel = 1) {
    const decorations = [];
    decorations.push(this.createLineDecoration(line));
    const cursorInMarker = this.isCursorInMarker(markerStart, markerEnd, context);
    if (!cursorInMarker) {
      decorations.push(this.createMarkerReplacement(markerStart, markerEnd, widget));
    }
    decorations.push(this.createContentMarkDecoration(contentStart, line.to, listLevel));
    const contentRegion = this.createContentRegion(contentStart, line.to, parentStructure);
    this.setListContext(context, contentStart - line.from, listLevel, parentStructure);
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
};

// src/live-preview/pipeline/structural/HashListProcessor.ts
var HashListProcessor = class extends BaseStructuralProcessor {
  constructor() {
    super(...arguments);
    this.name = "hash-list";
    this.priority = 10;
  }
  canProcess(line, context) {
    const lineText = line.text;
    return ListPatterns.isHashList(lineText) !== null;
  }
  process(line, context) {
    const lineText = line.text;
    const hashMatch = ListPatterns.isHashList(lineText);
    if (!hashMatch) {
      return { decorations: [] };
    }
    if (this.isInvalidInStrictMode(line, context)) {
      return { decorations: [] };
    }
    const indent = hashMatch[1];
    const marker = hashMatch[2];
    const space = hashMatch[3];
    const markerStart = line.from + indent.length;
    const markerEnd = line.from + indent.length + marker.length + space.length;
    const contentStart = markerEnd;
    const widget = new HashListMarkerWidget(context.hashCounter.value, context.view, markerStart);
    context.hashCounter.value++;
    return this.processStandardList(
      line,
      context,
      markerStart,
      markerEnd,
      contentStart,
      widget,
      "hash-list",
      1
    );
  }
};

// src/live-preview/pipeline/structural/FancyListProcessor.ts
var FancyListProcessor = class extends BaseStructuralProcessor {
  constructor() {
    super(...arguments);
    this.name = "fancy-list";
    this.priority = 20;
  }
  canProcess(line, context) {
    const lineText = line.text;
    return ListPatterns.isFancyList(lineText) !== null;
  }
  process(line, context) {
    const lineText = line.text;
    const fancyMatch = ListPatterns.isFancyList(lineText);
    if (!fancyMatch) {
      return { decorations: [] };
    }
    if (this.isInvalidInStrictMode(line, context)) {
      return { decorations: [] };
    }
    const indent = fancyMatch[1];
    const markerWithDelimiter = fancyMatch[2];
    const marker = fancyMatch[3];
    const delimiter = fancyMatch[4];
    const space = fancyMatch[5];
    const markerStart = line.from + indent.length;
    const markerEnd = line.from + indent.length + marker.length + delimiter.length + space.length;
    const contentStart = markerEnd;
    const widget = new FancyListMarkerWidget(marker, delimiter, context.view, markerStart);
    return this.processStandardList(
      line,
      context,
      markerStart,
      markerEnd,
      contentStart,
      widget,
      "fancy-list",
      1
      // Can be calculated based on indent depth
    );
  }
};

// src/live-preview/pipeline/structural/ExampleListProcessor.ts
var import_view4 = require("@codemirror/view");
var ExampleListProcessor = class extends BaseStructuralProcessor {
  constructor() {
    super(...arguments);
    this.name = "example-list";
    this.priority = 30;
  }
  canProcess(line, context) {
    const lineText = line.text;
    return ListPatterns.isExampleList(lineText) !== null;
  }
  process(line, context) {
    var _a;
    const lineText = line.text;
    const exampleMatch = ListPatterns.isExampleList(lineText);
    if (!exampleMatch) {
      return { decorations: [] };
    }
    if (this.isInvalidInStrictMode(line, context)) {
      return { decorations: [] };
    }
    const markerInfo = this.extractMarkerInfo(exampleMatch, line);
    const decorations = [];
    decorations.push(this.createLineDecoration(line));
    const cursorInMarker = this.isCursorInMarker(markerInfo.markerStart, markerInfo.markerEnd, context);
    if (!cursorInMarker) {
      this.addMarkerWidget(decorations, markerInfo, line, lineText, context);
    }
    decorations.push(this.createContentMarkDecoration(markerInfo.contentStart, line.to));
    const contentRegion = this.createContentRegion(
      markerInfo.contentStart,
      line.to,
      "example-list",
      { label: markerInfo.label, isDuplicate: ((_a = context.duplicateExampleLineNumbers) == null ? void 0 : _a.has(line.number)) || false }
    );
    this.setListContext(
      context,
      markerInfo.indent.length + markerInfo.fullMarker.length + markerInfo.space.length,
      1,
      "example-list"
    );
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
  /**
   * Extracts marker information from the regex match.
   */
  extractMarkerInfo(match, line) {
    const indent = match[1] || "";
    const fullMarker = match[2];
    const label = match[3] || "";
    const space = match[4] || "";
    const markerStart = line.from + indent.length;
    const markerEnd = line.from + indent.length + fullMarker.length + space.length;
    const contentStart = markerEnd;
    return { indent, fullMarker, label, space, markerStart, markerEnd, contentStart };
  }
  /**
   * Adds the appropriate marker widget.
   */
  addMarkerWidget(decorations, markerInfo, line, lineText, context) {
    var _a, _b, _c, _d, _e;
    const isDuplicate = (_a = context.duplicateExampleLineNumbers) == null ? void 0 : _a.has(line.number);
    if (isDuplicate && markerInfo.label) {
      const firstLine = ((_b = context.duplicateExampleLabels) == null ? void 0 : _b.get(markerInfo.label)) || 0;
      const firstContent = ((_c = context.duplicateExampleContent) == null ? void 0 : _c.get(markerInfo.label)) || "";
      decorations.push({
        from: markerInfo.markerStart,
        to: markerInfo.markerEnd,
        decoration: import_view4.Decoration.replace({
          widget: new DuplicateExampleLabelWidget(
            markerInfo.label,
            firstLine,
            firstContent,
            context.view,
            markerInfo.markerStart
          ),
          inclusive: false
        })
      });
    } else {
      const exampleNumber = ((_d = context.exampleLineNumbers) == null ? void 0 : _d.get(line.number)) || (markerInfo.label ? (_e = context.exampleLabels) == null ? void 0 : _e.get(markerInfo.label) : 0) || 0;
      decorations.push({
        from: markerInfo.markerStart,
        to: markerInfo.markerEnd,
        decoration: import_view4.Decoration.replace({
          widget: new ExampleListMarkerWidget(
            exampleNumber,
            markerInfo.label,
            context.view,
            markerInfo.markerStart
          ),
          inclusive: false
        })
      });
    }
  }
};

// src/live-preview/pipeline/structural/customLabel/parser.ts
function parseCustomLabel(line, context) {
  var _a, _b;
  const lineText = context.document.sliceString(line.from, line.to);
  const lineNum = context.document.lineAt(line.from).number;
  const customLabelMatch = ListPatterns.isCustomLabelList(lineText);
  if (!customLabelMatch) {
    return null;
  }
  if (context.settings.strictPandocMode && context.invalidLines.has(lineNum - 1)) {
    return null;
  }
  const indent = customLabelMatch[1];
  const fullMarker = customLabelMatch[2];
  const rawLabel = customLabelMatch[3];
  const space = customLabelMatch[4];
  const processedLabel = ((_a = context.rawToProcessed) == null ? void 0 : _a.get(rawLabel)) || rawLabel;
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + fullMarker.length + space.length;
  const isDuplicate = ((_b = context.duplicateCustomLabels) == null ? void 0 : _b.has(processedLabel)) || false;
  return {
    indent,
    fullMarker,
    rawLabel,
    space,
    processedLabel,
    markerStart,
    markerEnd,
    isDuplicate
  };
}
function parsePlaceholders(parsedLabel) {
  const placeholderMatches = Array.from(parsedLabel.rawLabel.matchAll(ListPatterns.PLACEHOLDER_PATTERN));
  const placeholderRanges = [];
  for (const match of placeholderMatches) {
    if (match.index !== void 0) {
      const placeholderStart = parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH + match.index;
      const placeholderEnd = placeholderStart + match[0].length;
      placeholderRanges.push({
        start: placeholderStart,
        end: placeholderEnd,
        name: match[1]
      });
    }
  }
  return placeholderRanges;
}
function handleCursorPosition(parsedLabel, placeholderRanges, context) {
  var _a;
  const selection = context.view.state.selection;
  const cursorPos = (_a = selection == null ? void 0 : selection.main) == null ? void 0 : _a.from;
  if (cursorPos === void 0) {
    return {
      pos: -1,
      isInMarker: false,
      isAtListMarker: false,
      cursorPlaceholder: null
    };
  }
  const isInMarker = cursorPos >= parsedLabel.markerStart && cursorPos <= parsedLabel.markerEnd;
  const isAtListMarker = cursorPos >= parsedLabel.markerStart && cursorPos < parsedLabel.markerEnd;
  let cursorPlaceholder = null;
  if (isInMarker) {
    for (const range of placeholderRanges) {
      if (cursorPos >= range.start && cursorPos <= range.end) {
        cursorPlaceholder = range;
        break;
      }
    }
  }
  return {
    pos: cursorPos,
    isInMarker,
    isAtListMarker,
    cursorPlaceholder
  };
}

// src/live-preview/pipeline/structural/customLabel/decorations.ts
var import_view5 = require("@codemirror/view");
function determineDisplayLevel(line, parsedLabel, placeholderRanges, cursorInfo) {
  if (cursorInfo.isAtListMarker) {
    return "full";
  }
  if (placeholderRanges.length > 0 && !cursorInfo.isInMarker) {
    const isCursorInLine = cursorInfo.pos !== -1 && cursorInfo.pos >= line.from && cursorInfo.pos <= line.to;
    return isCursorInLine ? "semi-expanded" : "collapsed";
  }
  return "collapsed";
}
function createCollapsedDecorations(parsedLabel, context) {
  const decorations = [];
  decorations.push({
    from: parsedLabel.markerStart,
    to: parsedLabel.markerEnd,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelMarkerWidget(
        parsedLabel.processedLabel,
        context.view,
        parsedLabel.markerStart
      ),
      inclusive: false
    })
  });
  return decorations;
}
function createSemiExpandedDecorations(parsedLabel, context) {
  const decorations = [];
  decorations.push({
    from: parsedLabel.markerStart,
    to: parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelPartialWidget("{::", context.view, parsedLabel.markerStart),
      inclusive: false
    })
  });
  const labelStart = parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH;
  const labelEnd = parsedLabel.markerEnd - parsedLabel.space.length - 1;
  decorations.push({
    from: labelStart,
    to: labelEnd,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelProcessedWidget(
        parsedLabel.processedLabel,
        context.view,
        labelStart
      ),
      inclusive: false
    })
  });
  decorations.push({
    from: labelEnd,
    to: labelEnd + 1,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelPartialWidget("}", context.view, labelEnd),
      inclusive: false
    })
  });
  return decorations;
}
function processPlaceholders(line, parsedLabel, placeholderRanges, cursorInfo, context) {
  var _a, _b, _c;
  const decorations = [];
  const labelStart = parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH;
  const labelEnd = parsedLabel.markerEnd - parsedLabel.space.length - 1;
  let lastEnd = labelStart;
  for (const range of placeholderRanges) {
    if (range.start > lastEnd) {
      decorations.push({
        from: lastEnd,
        to: range.start,
        decoration: import_view5.Decoration.mark({ class: CSS_CLASSES.CUSTOM_LABEL_TEXT })
      });
    }
    if (cursorInfo.cursorPlaceholder && cursorInfo.cursorPlaceholder === range) {
      decorations.push({
        from: range.start,
        to: range.end,
        decoration: import_view5.Decoration.mark({ class: CSS_CLASSES.CUSTOM_LABEL_PLACEHOLDER })
      });
    } else {
      const placeholderKey = `${parsedLabel.rawLabel.substring(
        0,
        parsedLabel.rawLabel.indexOf("(")
      )}(#${range.name})`;
      const processedKey = (_a = context.rawToProcessed) == null ? void 0 : _a.get(placeholderKey);
      const number = processedKey ? parseInt(((_b = processedKey.match(ListPatterns.TRAILING_DIGITS)) == null ? void 0 : _b[0]) || "0") : ((_c = context.placeholderContext) == null ? void 0 : _c.getPlaceholderNumber(range.name)) || 0;
      decorations.push({
        from: range.start,
        to: range.end,
        decoration: import_view5.Decoration.replace({
          widget: new CustomLabelInlineNumberWidget(String(number), context.view),
          inclusive: false
        })
      });
    }
    lastEnd = range.end;
  }
  if (lastEnd < labelEnd) {
    decorations.push({
      from: lastEnd,
      to: labelEnd,
      decoration: import_view5.Decoration.mark({ class: CSS_CLASSES.CUSTOM_LABEL_TEXT })
    });
  }
  return decorations;
}
function createFullDisplayDecorations(line, parsedLabel, placeholderRanges, cursorInfo, context) {
  var _a, _b, _c;
  const decorations = [];
  const labelStart = parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH;
  const labelEnd = parsedLabel.markerEnd - parsedLabel.space.length - 1;
  decorations.push({
    from: parsedLabel.markerStart,
    to: parsedLabel.markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelPartialWidget("{::", context.view, parsedLabel.markerStart),
      inclusive: false
    })
  });
  if (parsedLabel.isDuplicate) {
    const firstOccurrence = (_a = context.duplicateCustomLineInfo) == null ? void 0 : _a.get(parsedLabel.processedLabel);
    decorations.push({
      from: labelStart,
      to: labelEnd,
      decoration: import_view5.Decoration.replace({
        widget: new DuplicateCustomLabelWidget(
          parsedLabel.rawLabel,
          (_b = firstOccurrence == null ? void 0 : firstOccurrence.firstLine) != null ? _b : void 0,
          (_c = firstOccurrence == null ? void 0 : firstOccurrence.firstContent) != null ? _c : void 0
        ),
        inclusive: false
      })
    });
  } else if (placeholderRanges.length > 0) {
    const placeholderDecorations = processPlaceholders(
      line,
      parsedLabel,
      placeholderRanges,
      cursorInfo,
      context
    );
    decorations.push(...placeholderDecorations);
  } else {
    decorations.push({
      from: labelStart,
      to: labelEnd,
      decoration: import_view5.Decoration.mark({ class: CSS_CLASSES.CUSTOM_LABEL_TEXT })
    });
  }
  decorations.push({
    from: labelEnd,
    to: labelEnd + 1,
    decoration: import_view5.Decoration.replace({
      widget: new CustomLabelPartialWidget("}", context.view, labelEnd),
      inclusive: false
    })
  });
  return decorations;
}
function buildStructuralResult(parsedLabel, line, decorations, context) {
  const contentRegion = {
    from: parsedLabel.markerEnd,
    to: line.to,
    type: "list-content",
    parentStructure: "custom-label-list",
    metadata: {
      rawLabel: parsedLabel.rawLabel,
      processedLabel: parsedLabel.processedLabel,
      isDuplicate: parsedLabel.isDuplicate
    }
  };
  context.listContext = {
    isInList: true,
    contentStartColumn: parsedLabel.markerEnd - line.from,
    listLevel: 1,
    parentStructure: "custom-label-list"
  };
  return contentRegion;
}

// src/live-preview/pipeline/structural/CustomLabelProcessor.ts
var CustomLabelProcessor = class {
  constructor() {
    this.name = "custom-label-list";
    this.priority = 15;
  }
  // Process after basic lists
  canProcess(line, context) {
    if (!context.settings.moreExtendedSyntax) {
      return false;
    }
    const lineText = context.document.sliceString(line.from, line.to);
    return ListPatterns.isCustomLabelList(lineText) !== null;
  }
  process(line, context) {
    const parsedLabel = parseCustomLabel(line, context);
    if (!parsedLabel) {
      return { decorations: [] };
    }
    const placeholderRanges = parsePlaceholders(parsedLabel);
    const cursorInfo = handleCursorPosition(parsedLabel, placeholderRanges, context);
    const displayLevel = determineDisplayLevel(line, parsedLabel, placeholderRanges, cursorInfo);
    let decorations;
    if (displayLevel === "collapsed" && !parsedLabel.isDuplicate) {
      decorations = createCollapsedDecorations(parsedLabel, context);
    } else if (displayLevel === "semi-expanded") {
      decorations = createSemiExpandedDecorations(parsedLabel, context);
    } else {
      decorations = createFullDisplayDecorations(
        line,
        parsedLabel,
        placeholderRanges,
        cursorInfo,
        context
      );
    }
    const contentRegion = buildStructuralResult(parsedLabel, line, decorations, context);
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
};

// src/live-preview/pipeline/structural/DefinitionProcessor.ts
var import_view6 = require("@codemirror/view");
var DefinitionProcessor = class {
  constructor() {
    this.name = "definition-list";
    this.priority = 20;
  }
  // Process after other lists
  canProcess(line, context) {
    const lineText = context.document.sliceString(line.from, line.to);
    if (ListPatterns.isDefinitionMarker(lineText)) {
      return true;
    }
    if (this.isPotentialDefinitionTerm(line, context)) {
      return true;
    }
    if (this.isIndentedDefinitionContent(line, context)) {
      return true;
    }
    return false;
  }
  process(line, context) {
    const lineText = context.document.sliceString(line.from, line.to);
    const lineNum = context.document.lineAt(line.from).number;
    const decorations = [];
    const defItemMatch = ListPatterns.isDefinitionMarker(lineText);
    if (defItemMatch) {
      return this.processDefinitionItem(line, lineText, lineNum, context, defItemMatch);
    }
    if (this.isPotentialDefinitionTerm(line, context)) {
      return this.processDefinitionTerm(line, context);
    }
    if (this.isIndentedDefinitionContent(line, context)) {
      return this.processIndentedContent(line, context);
    }
    return { decorations };
  }
  processDefinitionItem(line, lineText, lineNum, context, defItemMatch) {
    var _a;
    const decorations = [];
    if (context.settings.strictPandocMode && context.invalidLines.has(lineNum - 1)) {
      return { decorations };
    }
    const indent = defItemMatch[1] || "";
    const marker = defItemMatch[2] || "";
    const space = defItemMatch[3] || "";
    if (!marker) {
      return { decorations };
    }
    const markerStart = line.from + indent.length;
    const markerEnd = line.from + indent.length + marker.length + space.length;
    if (markerStart < line.from || markerEnd > line.to || markerStart >= markerEnd) {
      handleError(`Invalid marker positions for definition: start=${markerStart}, end=${markerEnd}, line=${line.from}-${line.to}`, "warning");
      return { decorations };
    }
    const selection = context.view.state.selection;
    const cursorPos = (_a = selection == null ? void 0 : selection.main) == null ? void 0 : _a.from;
    const cursorInMarker = cursorPos !== void 0 && cursorPos >= markerStart && cursorPos < markerEnd;
    if (!cursorInMarker) {
      try {
        decorations.push({
          from: markerStart,
          to: markerEnd,
          decoration: import_view6.Decoration.replace({
            widget: new DefinitionBulletWidget(context.view, markerStart),
            inclusive: false
          })
        });
      } catch (e) {
        handleError(e, "error");
      }
    } else {
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view6.Decoration.mark({
          class: CSS_CLASSES.DEFINITION_MARKER_CURSOR
        })
      });
    }
    context.definitionState.lastWasItem = true;
    context.definitionState.pendingBlankLine = false;
    const contentRegion = {
      from: markerEnd,
      to: line.to,
      type: "definition-content",
      parentStructure: "definition"
    };
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
  processDefinitionTerm(line, context) {
    const decorations = [];
    decorations.push({
      from: line.from,
      to: line.to,
      decoration: import_view6.Decoration.mark({
        class: "cm-strong cm-pandoc-definition-term"
      })
    });
    return {
      decorations,
      skipFurtherProcessing: true
    };
  }
  processIndentedContent(line, context) {
    const decorations = [];
    decorations.push({
      from: line.from,
      to: line.from,
      decoration: import_view6.Decoration.line({
        class: CSS_CLASSES.DEFINITION_PARAGRAPH
      })
    });
    const contentRegion = {
      from: line.from,
      to: line.to,
      type: "definition-content",
      parentStructure: "definition"
    };
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
  isPotentialDefinitionTerm(line, context) {
    const lineText = context.document.sliceString(line.from, line.to);
    if (!lineText.trim() || ListPatterns.isDefinitionMarker(lineText) || ListPatterns.isIndentedContent(lineText)) {
      return false;
    }
    const lineNum = context.document.lineAt(line.from).number;
    if (lineNum < context.document.lines) {
      const nextLine = context.document.line(lineNum + 1);
      const nextText = context.document.sliceString(nextLine.from, nextLine.to);
      if (ListPatterns.isDefinitionMarker(nextText)) {
        return true;
      }
      if (nextText.trim() === "" && lineNum + 1 < context.document.lines) {
        const lineAfterEmpty = context.document.line(lineNum + 2);
        const afterEmptyText = context.document.sliceString(lineAfterEmpty.from, lineAfterEmpty.to);
        if (ListPatterns.isDefinitionMarker(afterEmptyText)) {
          return true;
        }
      }
    }
    return false;
  }
  isIndentedDefinitionContent(line, context) {
    const lineText = context.document.sliceString(line.from, line.to);
    if (!ListPatterns.isIndentedContent(lineText)) {
      return false;
    }
    return context.definitionState.lastWasItem || context.definitionState.pendingBlankLine;
  }
};

// src/live-preview/pipeline/structural/StandardListProcessor.ts
var import_view7 = require("@codemirror/view");
var StandardListProcessor = class {
  constructor() {
    this.name = "standard-list";
    this.priority = 25;
  }
  // Process after fancy lists but before definition lists
  canProcess(line, context) {
    return false;
  }
  process(line, context) {
    const lineText = line.text;
    const match = lineText.match(ListPatterns.UNORDERED_LIST);
    if (!match) {
      return { decorations: [] };
    }
    if (context.settings.strictPandocMode && context.invalidLines.has(line.number)) {
      return { decorations: [] };
    }
    const indent = match[1];
    const markerMatch = lineText.match(/^(\s*)([-*+])(\s+)/);
    if (!markerMatch) {
      return { decorations: [] };
    }
    const marker = markerMatch[2];
    const space = markerMatch[3];
    const markerStart = line.from + indent.length;
    const markerEnd = line.from + indent.length + marker.length + space.length;
    const contentStart = markerEnd;
    const decorations = [];
    const spacesPerTab = " ".repeat(TEXT_PROCESSING.TAB_EQUIVALENT_SPACES);
    const indentLevel = Math.floor(indent.replace(/\t/g, spacesPerTab).length / TEXT_PROCESSING.TAB_EQUIVALENT_SPACES) + 1;
    const listClass = indentLevel === 1 ? CSS_CLASSES.LIST_LINE_1 : indentLevel === 2 ? CSS_CLASSES.LIST_LINE_2 : indentLevel === 3 ? CSS_CLASSES.LIST_LINE_3 : CSS_CLASSES.LIST_LINE_4;
    decorations.push({
      from: line.from,
      to: line.from,
      decoration: import_view7.Decoration.line({
        class: `${CSS_CLASSES.LIST_LINE} ${listClass} HyperMD-list-line HyperMD-list-line-${indentLevel}`
      })
    });
    decorations.push({
      from: markerStart,
      to: markerEnd - space.length,
      decoration: import_view7.Decoration.mark({
        class: "cm-formatting-list cm-formatting-list-ul"
      })
    });
    if (contentStart < line.to) {
      decorations.push({
        from: contentStart,
        to: line.to,
        decoration: import_view7.Decoration.mark({
          class: `cm-list-${indentLevel}`
        })
      });
    }
    const contentRegion = {
      from: contentStart,
      to: line.to,
      type: "list-content",
      parentStructure: "standard-list"
    };
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
};

// src/live-preview/pipeline/structural/ListContinuationProcessor.ts
var import_view8 = require("@codemirror/view");
var ListContinuationProcessor = class {
  constructor() {
    this.name = "list-continuation";
    this.priority = 100;
  }
  // Run after all list processors
  canProcess(line, context) {
    var _a;
    if (!((_a = context.listContext) == null ? void 0 : _a.isInList)) {
      return false;
    }
    const lineText = line.text;
    const indent = this.getIndentMetrics(lineText);
    return indent.visualLength >= INDENTATION.CONTINUATION_MIN_VISUAL;
  }
  process(line, context) {
    if (!context.listContext) {
      return { decorations: [] };
    }
    const lineText = line.text;
    const decorations = [];
    const indent = this.getIndentMetrics(lineText);
    const listLevel = this.getListLevel(context);
    const indentWidthPx = this.calculateIndentWidth(
      context.listContext.contentStartColumn,
      indent.visualLength
    );
    this.addLineDecoration(decorations, line, indentWidthPx);
    if (indent.textLength > 0) {
      this.addIndentDecorations(
        decorations,
        line,
        indent.textLength,
        indentWidthPx,
        listLevel
      );
    }
    this.addContentDecoration(decorations, line, indent.textLength, listLevel);
    const contentRegion = {
      from: line.from + indent.textLength,
      to: line.to,
      type: "list-content",
      parentStructure: context.listContext.parentStructure
    };
    this.updateListContext(line, context);
    return {
      decorations,
      contentRegion,
      skipFurtherProcessing: true
    };
  }
  /**
   * Adds line decoration with proper styling for continuation lines.
   */
  addLineDecoration(decorations, line, indentWidthPx) {
    const baseConfig = {
      class: `${CSS_CLASSES.LIST_LINE} ${CSS_CLASSES.LIST_LINE_1} ${CSS_CLASSES.LIST_LINE_NOBULLET}`
    };
    decorations.push({
      from: line.from,
      to: line.from,
      decoration: import_view8.Decoration.line(baseConfig)
    });
  }
  /**
   * Adds indent decorations for leading whitespace.
   */
  addIndentDecorations(decorations, line, indentCharLength, indentWidthPx, listLevel) {
    decorations.push({
      from: line.from,
      to: line.from + indentCharLength,
      decoration: import_view8.Decoration.replace({
        widget: new ListContinuationIndentWidget(indentWidthPx, listLevel),
        inclusive: false
      })
    });
  }
  /**
   * Adds content area decoration.
   */
  addContentDecoration(decorations, line, indentCharLength, listLevel) {
    decorations.push({
      from: line.from + indentCharLength,
      to: line.to,
      decoration: import_view8.Decoration.mark({
        class: this.getContentClass(listLevel)
      })
    });
  }
  /**
   * Updates list context based on the next line.
   */
  updateListContext(line, context) {
    const nextLineNum = line.number + 1;
    if (nextLineNum <= context.document.lines) {
      const nextLine = context.document.line(nextLineNum);
      const nextLineText = nextLine.text.trim();
      const nextIndent = this.getIndentMetrics(nextLine.text);
      if (nextLineText === "" || nextIndent.visualLength < INDENTATION.CONTINUATION_MIN_VISUAL) {
        context.listContext = void 0;
      }
    } else {
      context.listContext = void 0;
    }
  }
  getIndentMetrics(text) {
    let visualLength = 0;
    let textLength = 0;
    for (const char of text) {
      if (char === " ") {
        visualLength += INDENTATION.SINGLE_SPACE;
        textLength += 1;
      } else if (char === INDENTATION.TAB) {
        visualLength += INDENTATION.TAB_SIZE;
        textLength += 1;
      } else {
        break;
      }
    }
    return {
      visualLength,
      textLength
    };
  }
  calculateIndentWidth(contentStartColumn, indentVisualLength) {
    const columnWidth = DECORATION_STYLES.CONTINUATION_INDENT_UNIT_PX;
    const baseColumns = contentStartColumn > 0 ? contentStartColumn : indentVisualLength;
    return Math.max(baseColumns, INDENTATION.CONTINUATION_MIN_VISUAL) * columnWidth;
  }
  calculatePadding(indentWidthPx) {
    return `${indentWidthPx}px`;
  }
  getListLevel(context) {
    var _a;
    return ((_a = context.listContext) == null ? void 0 : _a.listLevel) && context.listContext.listLevel > 0 ? context.listContext.listLevel : 1;
  }
  getContentClass(listLevel) {
    switch (listLevel) {
      case 2:
        return CSS_CLASSES.CM_LIST_2;
      case 3:
        return CSS_CLASSES.CM_LIST_3;
      default:
        return CSS_CLASSES.CM_LIST_1;
    }
  }
};

// src/live-preview/pipeline/inline/ExampleReferenceProcessor.ts
var import_view9 = require("@codemirror/view");

// src/shared/utils/cursorUtils.ts
function getRegionCursorPosition(context, region) {
  var _a, _b, _c, _d;
  const cursorPos = (_d = (_c = (_b = (_a = context.view) == null ? void 0 : _a.state) == null ? void 0 : _b.selection) == null ? void 0 : _c.main) == null ? void 0 : _d.head;
  return cursorPos !== void 0 ? cursorPos - region.from : -1;
}

// src/shared/utils/contextUtils.ts
function buildReferenceContext(context) {
  return {
    exampleLabels: context.exampleLabels,
    exampleContent: context.exampleContent,
    customLabels: context.customLabels,
    rawToProcessed: context.rawToProcessed
  };
}

// src/live-preview/pipeline/inline/ExampleReferenceProcessor.ts
var ExampleReferenceProcessor = class {
  constructor() {
    this.name = "example-reference";
    this.priority = 10;
    this.supportedRegions = /* @__PURE__ */ new Set(["list-content", "definition-content", "paragraph", "normal"]);
  }
  findMatches(text, region, context) {
    const matches = [];
    const pattern = ListPatterns.EXAMPLE_REFERENCE;
    const regionCursorPos = getRegionCursorPosition(context, region);
    let match;
    while ((match = pattern.exec(text)) !== null) {
      const label = match[1];
      const refStart = match.index;
      const refEnd = match.index + match[0].length;
      const cursorInRef = regionCursorPos >= refStart && regionCursorPos <= refEnd;
      if (context.exampleLabels.has(label) && !cursorInRef) {
        matches.push({
          from: refStart,
          to: refEnd,
          type: "example-ref",
          data: {
            label,
            rawText: match[0],
            region
          }
        });
      }
    }
    return matches;
  }
  createDecoration(match, context) {
    const { label, region } = match.data;
    const number = context.exampleLabels.get(label) || 0;
    const content = context.exampleContent.get(label) || "";
    const absolutePosition = match.from + ((region == null ? void 0 : region.from) || 0);
    const referenceContext = buildReferenceContext(context);
    return import_view9.Decoration.replace({
      widget: new ExampleReferenceWidget(
        number,
        content,
        context.view,
        absolutePosition,
        context.app,
        context.component,
        referenceContext
      ),
      inclusive: false
    });
  }
};

// src/live-preview/pipeline/inline/SuperscriptProcessor.ts
var import_view10 = require("@codemirror/view");
var SuperscriptProcessor = class {
  constructor() {
    this.name = "superscript";
    this.priority = 20;
    this.supportedRegions = /* @__PURE__ */ new Set(["list-content", "definition-content", "paragraph", "normal"]);
  }
  findMatches(text, region, context) {
    const matches = [];
    const pattern = ListPatterns.SUPERSCRIPT_INLINE;
    const regionCursorPos = getRegionCursorPosition(context, region);
    let match;
    while ((match = pattern.exec(text)) !== null) {
      const supStart = match.index;
      const supEnd = match.index + match[0].length;
      const cursorInSup = regionCursorPos >= supStart && regionCursorPos <= supEnd;
      if (!cursorInSup) {
        matches.push({
          from: supStart,
          to: supEnd,
          type: "superscript",
          data: {
            content: match[1],
            rawText: match[0],
            absoluteFrom: region.from + supStart
          }
        });
      }
    }
    return matches;
  }
  createDecoration(match, context) {
    const { content, absoluteFrom } = match.data;
    return import_view10.Decoration.replace({
      widget: new SuperscriptWidget(content, context.view, absoluteFrom),
      inclusive: false
    });
  }
};

// src/live-preview/pipeline/inline/SubscriptProcessor.ts
var import_view11 = require("@codemirror/view");
var SubscriptProcessor = class {
  constructor() {
    this.name = "subscript";
    this.priority = 30;
    this.supportedRegions = /* @__PURE__ */ new Set(["list-content", "definition-content", "paragraph", "normal"]);
  }
  findMatches(text, region, context) {
    const matches = [];
    const pattern = ListPatterns.SUBSCRIPT_INLINE;
    const regionCursorPos = getRegionCursorPosition(context, region);
    let match;
    while ((match = pattern.exec(text)) !== null) {
      const subStart = match.index;
      const subEnd = match.index + match[0].length;
      const cursorInSub = regionCursorPos >= subStart && regionCursorPos <= subEnd;
      if (!cursorInSub) {
        matches.push({
          from: subStart,
          to: subEnd,
          type: "subscript",
          data: {
            content: match[1],
            rawText: match[0],
            absoluteFrom: region.from + subStart
          }
        });
      }
    }
    return matches;
  }
  createDecoration(match, context) {
    const { content, absoluteFrom } = match.data;
    return import_view11.Decoration.replace({
      widget: new SubscriptWidget(content, context.view, absoluteFrom),
      inclusive: false
    });
  }
};

// src/live-preview/pipeline/inline/CustomLabelReferenceProcessor.ts
var import_view12 = require("@codemirror/view");
var CustomLabelReferenceProcessor = class {
  constructor() {
    this.name = "custom-label-reference";
    this.priority = 40;
    this.supportedRegions = /* @__PURE__ */ new Set(["list-content", "definition-content", "paragraph", "normal"]);
  }
  findMatches(text, region, context) {
    const matches = [];
    if (!context.settings.moreExtendedSyntax) {
      return matches;
    }
    const regionCursorPos = getRegionCursorPosition(context, region);
    const pattern = ListPatterns.findCustomLabelReferences(text);
    pattern.forEach((match) => {
      var _a, _b, _c;
      const fullMatch = match[0];
      const rawLabel = match[1];
      let isValid = false;
      if ((_a = context.rawToProcessed) == null ? void 0 : _a.has(rawLabel)) {
        isValid = true;
      } else if ((_b = context.customLabels) == null ? void 0 : _b.has(rawLabel)) {
        isValid = true;
      } else if ((_c = context.duplicateCustomLabels) == null ? void 0 : _c.has(rawLabel)) {
        isValid = true;
      } else if (context.placeholderContext) {
        const processedLabel = context.placeholderContext.getProcessedLabel(rawLabel);
        isValid = processedLabel !== null;
      }
      const refStart = match.index;
      const refEnd = match.index + fullMatch.length;
      const cursorInReference = regionCursorPos >= refStart && regionCursorPos < refEnd;
      if (isValid && !cursorInReference) {
        matches.push({
          from: refStart,
          to: refEnd,
          type: "custom-label-ref",
          data: {
            rawLabel,
            fullMatch,
            absoluteFrom: region.from + refStart
          }
        });
      }
    });
    return matches;
  }
  createDecoration(match, context) {
    var _a, _b, _c, _d, _e, _f;
    const { rawLabel, absoluteFrom } = match.data;
    let processedLabel;
    if ((_a = context.rawToProcessed) == null ? void 0 : _a.has(rawLabel)) {
      processedLabel = context.rawToProcessed.get(rawLabel);
    } else if ((_b = context.customLabels) == null ? void 0 : _b.has(rawLabel)) {
      processedLabel = rawLabel;
    } else if ((_c = context.duplicateCustomLabels) == null ? void 0 : _c.has(rawLabel)) {
      processedLabel = rawLabel;
    } else if (context.placeholderContext) {
      const processed = context.placeholderContext.getProcessedLabel(rawLabel);
      processedLabel = processed !== null ? processed : rawLabel;
    } else {
      processedLabel = rawLabel;
    }
    const isDuplicate = (_d = context.duplicateCustomLabels) == null ? void 0 : _d.has(processedLabel);
    if (isDuplicate) {
      const duplicateInfo = (_e = context.duplicateCustomLineInfo) == null ? void 0 : _e.get(processedLabel);
      return import_view12.Decoration.replace({
        widget: new DuplicateCustomLabelWidget(
          processedLabel,
          (duplicateInfo == null ? void 0 : duplicateInfo.firstLine) || 0,
          (duplicateInfo == null ? void 0 : duplicateInfo.firstContent) || "",
          context.view
        ),
        inclusive: false
      });
    }
    const labelContent = ((_f = context.customLabels) == null ? void 0 : _f.get(processedLabel)) || "";
    const referenceContext = buildReferenceContext(context);
    return import_view12.Decoration.replace({
      widget: new CustomLabelReferenceWidget(
        processedLabel,
        labelContent,
        context.view,
        absoluteFrom,
        context.app,
        context.component,
        referenceContext
      ),
      inclusive: false
    });
  }
  processPlaceholders(label, placeholderContext) {
    if (!placeholderContext) return label;
    return ListPatterns.replacePlaceholderLetters(label, (match, letter) => {
      var _a;
      const value = (_a = placeholderContext.getPlaceholderValue) == null ? void 0 : _a.call(placeholderContext, letter);
      return value !== void 0 ? `(${value})` : match;
    });
  }
};

// src/live-preview/extension.ts
var pandocExtendedMarkdownPlugin = (getSettings, getDocPath, getApp, getComponent) => import_view13.ViewPlugin.fromClass(
  class PandocExtendedMarkdownView {
    constructor(view) {
      this.initializePipeline(getApp, getComponent);
      this.decorations = this.buildDecorations(view);
    }
    initializePipeline(getApp2, getComponent2) {
      const app = getApp2 ? getApp2() : void 0;
      const component = getComponent2 ? getComponent2() : void 0;
      this.pipeline = new ProcessingPipeline(pluginStateManager, app, component);
      this.pipeline.registerStructuralProcessor(new HashListProcessor());
      this.pipeline.registerStructuralProcessor(new FancyListProcessor());
      this.pipeline.registerStructuralProcessor(new StandardListProcessor());
      this.pipeline.registerStructuralProcessor(new ExampleListProcessor());
      this.pipeline.registerStructuralProcessor(new CustomLabelProcessor());
      this.pipeline.registerStructuralProcessor(new DefinitionProcessor());
      this.pipeline.registerStructuralProcessor(new ListContinuationProcessor());
      this.pipeline.registerInlineProcessor(new ExampleReferenceProcessor());
      this.pipeline.registerInlineProcessor(new SuperscriptProcessor());
      this.pipeline.registerInlineProcessor(new SubscriptProcessor());
      this.pipeline.registerInlineProcessor(new CustomLabelReferenceProcessor());
    }
    update(update) {
      const prevLivePreview = update.startState.field(import_obsidian9.editorLivePreviewField);
      const currLivePreview = update.state.field(import_obsidian9.editorLivePreviewField);
      const livePreviewChanged = prevLivePreview !== currLivePreview;
      if (update.docChanged || update.viewportChanged || update.selectionSet || livePreviewChanged) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const isLivePreview = view.state.field(import_obsidian9.editorLivePreviewField);
      if (!isLivePreview || !this.pipeline) {
        return new import_state2.RangeSetBuilder().finish();
      }
      const settings = getSettings();
      return this.pipeline.process(view, settings);
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocExtendedMarkdownExtension(getSettings, getDocPath, getApp, getComponent) {
  return pandocExtendedMarkdownPlugin(getSettings, getDocPath, getApp, getComponent);
}

// src/shared/types/obsidian-extended.ts
function isMarkdownPreviewSection(element) {
  return element !== null && element.classList.contains("markdown-preview-section");
}
function getSectionInfo(element) {
  if (!isMarkdownPreviewSection(element)) {
    return null;
  }
  if (typeof element.getSection === "function") {
    try {
      return element.getSection();
    } catch (error) {
      return null;
    }
  }
  return null;
}

// src/reading-mode/utils/domUtils.ts
var import_obsidian10 = require("obsidian");
function createTextNodeWalker(element, filter) {
  return document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: filter || (() => NodeFilter.FILTER_ACCEPT)
    }
  );
}

// src/reading-mode/parsers/fancyListParser.ts
function parseFancyListMarker(line) {
  const hashMatch = ListPatterns.isHashList(line);
  if (hashMatch) {
    return {
      indent: hashMatch[1],
      marker: hashMatch[2],
      type: "hash",
      delimiter: ".",
      value: void 0
    };
  }
  const match = ListPatterns.isFancyList(line);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (ListPatterns.DECIMAL.test(value)) {
    return null;
  } else if (ListPatterns.ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ListPatterns.ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ListPatterns.ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ListPatterns.ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/reading-mode/parsers/exampleListParser.ts
var import_obsidian11 = require("obsidian");
function parseExampleListMarker(line) {
  const match = ListPatterns.isExampleList(line);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3] || void 0
  };
}

// src/reading-mode/parsers/superSubParser.ts
function extractContent(match, delimiter) {
  const content = match.slice(1, -1);
  return ListPatterns.unescapeSpaces(content);
}
function findSuperSubInText(text) {
  const matches = [];
  const superscripts = ListPatterns.findSuperscripts(text);
  superscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "^"),
        type: "superscript"
      });
    }
  });
  const subscripts = ListPatterns.findSubscripts(text);
  subscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "~"),
        type: "subscript"
      });
    }
  });
  matches.sort((a, b) => a.index - b.index);
  return matches;
}
function processSuperSub(element) {
  const walker = createTextNodeWalker(element, (node) => {
    const parent = node.parentElement;
    if (parent && (parent.classList.contains(CSS_CLASSES.SUPERSCRIPT) || parent.classList.contains(CSS_CLASSES.SUBSCRIPT))) {
      return NodeFilter.FILTER_REJECT;
    }
    return NodeFilter.FILTER_ACCEPT;
  });
  const nodesToReplace = [];
  while (walker.nextNode()) {
    const node = walker.currentNode;
    const text = node.textContent || "";
    const matches = findSuperSubInText(text);
    if (matches.length > 0) {
      nodesToReplace.push({ node, matches });
    }
  }
  nodesToReplace.forEach(({ node, matches }) => {
    const parent = node.parentNode;
    if (!parent) return;
    let lastIndex = 0;
    const fragments = [];
    matches.forEach((match) => {
      if (match.index > lastIndex) {
        fragments.push(node.textContent.substring(lastIndex, match.index));
      }
      const elem = match.type === "superscript" ? document.createElement("sup") : document.createElement("sub");
      elem.className = match.type === "superscript" ? CSS_CLASSES.SUPERSCRIPT : CSS_CLASSES.SUBSCRIPT;
      elem.textContent = match.content;
      fragments.push(elem);
      lastIndex = match.index + match.length;
    });
    if (lastIndex < node.textContent.length) {
      fragments.push(node.textContent.substring(lastIndex));
    }
    fragments.forEach((fragment) => {
      if (typeof fragment === "string") {
        parent.insertBefore(document.createTextNode(fragment), node);
      } else {
        parent.insertBefore(fragment, node);
      }
    });
    parent.removeChild(node);
  });
}

// src/reading-mode/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(ListPatterns.DEFINITION_TERM_PATTERN);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(ListPatterns.NUMBERED_LIST)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = ListPatterns.isDefinitionMarker(line);
  if (defMatch) {
    const content = line.substring(defMatch[0].length);
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content
    };
  }
  return null;
}

// src/reading-mode/parsers/parser.ts
var ReadingModeParser = class {
  /**
   * Parse a single line and identify its type and data
   */
  parseLine(line, context) {
    const hashMatch = ListPatterns.isHashList(line);
    if (hashMatch) {
      return {
        type: "hash",
        content: line,
        metadata: {
          indent: hashMatch[1],
          marker: hashMatch[2],
          spacing: hashMatch[3],
          content: line.substring(hashMatch[1].length + hashMatch[2].length + hashMatch[3].length)
        }
      };
    }
    const fancyMarker = parseFancyListMarker(line);
    if (fancyMarker && fancyMarker.type !== "hash") {
      return {
        type: "fancy",
        content: line,
        metadata: {
          type: fancyMarker.type,
          marker: fancyMarker.marker,
          indent: fancyMarker.indent,
          content: line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1)
        }
      };
    }
    if ((context == null ? void 0 : context.isInParagraph) && (context == null ? void 0 : context.isAtParagraphStart) !== false) {
      const exampleMarker = parseExampleListMarker(line);
      if (exampleMarker) {
        const contentStart = exampleMarker.indent.length + exampleMarker.originalMarker.length + 1;
        return {
          type: "example",
          content: line,
          metadata: {
            indent: exampleMarker.indent,
            originalMarker: exampleMarker.originalMarker,
            label: exampleMarker.label,
            content: line.substring(contentStart)
          }
        };
      }
    }
    const defMarker = parseDefinitionListMarker(line);
    if (defMarker && defMarker.type === "definition") {
      return {
        type: "definition-item",
        content: line,
        metadata: {
          content: defMarker.content
        }
      };
    }
    if ((context == null ? void 0 : context.nextLine) && ListPatterns.isDefinitionMarker(context.nextLine)) {
      return {
        type: "definition-term",
        content: line,
        metadata: {
          content: line.trim()
        }
      };
    }
    const references = this.findExampleReferences(line);
    if (references.length > 0) {
      return {
        type: "reference",
        content: line,
        metadata: {
          references
        }
      };
    }
    return {
      type: "plain",
      content: line
    };
  }
  /**
   * Parse multiple lines with context
   */
  parseLines(lines, isInParagraph = false, isAtParagraphStart = true) {
    return lines.map((line, index) => {
      const nextLine = index < lines.length - 1 ? lines[index + 1] : void 0;
      const isLineAtStart = index === 0 ? isAtParagraphStart : true;
      return this.parseLine(line, { nextLine, isInParagraph, isAtParagraphStart: isLineAtStart });
    });
  }
  /**
   * Find example references in text
   */
  findExampleReferences(text) {
    const references = [];
    const regex = ListPatterns.EXAMPLE_REFERENCE;
    let match;
    while ((match = regex.exec(text)) !== null) {
      references.push({
        fullMatch: match[0],
        label: match[1],
        startIndex: match.index,
        endIndex: match.index + match[0].length
      });
    }
    return references;
  }
  /**
   * Check if strict validation should be applied
   */
  shouldValidateStrict(parsedLine, lines, currentLineIndex) {
    if (parsedLine.type !== "fancy") {
      return false;
    }
    return true;
  }
};

// src/reading-mode/renderer.ts
var import_obsidian12 = require("obsidian");
var ReadingModeRenderer = class {
  /**
   * Render a parsed line to DOM elements
   */
  renderLine(parsedLine, context, lineNumber) {
    switch (parsedLine.type) {
      case "hash":
        return this.renderHashList(parsedLine.metadata, lineNumber, context);
      case "fancy":
        return this.renderFancyList(parsedLine.metadata, context);
      case "example":
        return this.renderExampleList(parsedLine.metadata, lineNumber, context);
      case "definition-term":
        return this.renderDefinitionTerm(parsedLine.metadata);
      case "definition-item":
        return this.renderDefinitionItem(parsedLine.metadata, context);
      case "reference":
        return this.renderWithReferences(parsedLine.content, parsedLine.metadata, context);
      default:
        return [document.createTextNode(parsedLine.content)];
    }
  }
  /**
   * Render multiple parsed lines with line breaks
   */
  renderLines(parsedLines, context, numberProvider) {
    const elements = [];
    parsedLines.forEach((parsedLine, index) => {
      if (index > 0) {
        if (context.strictLineBreaks) {
          elements.push(document.createElement("br"));
        }
        elements.push(document.createTextNode("\n"));
      }
      let lineNumber;
      if (numberProvider) {
        if (parsedLine.type === "hash") {
          lineNumber = numberProvider("hash", index);
        } else if (parsedLine.type === "example") {
          lineNumber = numberProvider("example", index);
        }
      }
      const lineElements = this.renderLine(parsedLine, context, lineNumber);
      elements.push(...lineElements);
    });
    return elements;
  }
  /**
   * Render hash auto-numbering list
   */
  renderHashList(data, number, context) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-hash`;
    span.textContent = `${number || "#"}. `;
    elements.push(span);
    if (data.content) {
      const contentElements = this.processContentForReferences(data.content, context);
      elements.push(...contentElements);
    }
    return elements;
  }
  /**
   * Render fancy list marker
   */
  renderFancyList(data, context) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-${data.type}`;
    span.textContent = data.marker + " ";
    elements.push(span);
    if (data.content) {
      const contentElements = this.processContentForReferences(data.content, context);
      elements.push(...contentElements);
    }
    return elements;
  }
  /**
   * Render example list
   */
  renderExampleList(data, number, context) {
    const elements = [];
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_LIST;
    span.textContent = `(${number || "@"}) `;
    if (number) {
      span.dataset.exampleNumber = String(number);
    }
    elements.push(span);
    if (data.content) {
      const contentElements = this.processContentForReferences(data.content, context);
      elements.push(...contentElements);
    }
    return elements;
  }
  /**
   * Render definition term
   */
  renderDefinitionTerm(data) {
    const strong = document.createElement("strong");
    const u = document.createElement("u");
    u.textContent = data.content;
    strong.appendChild(u);
    return [strong];
  }
  /**
   * Render definition item
   */
  renderDefinitionItem(data, context) {
    const elements = [];
    const span = document.createElement("span");
    span.textContent = "\u2022 ";
    elements.push(span);
    const contentElements = this.processContentForReferences(data.content, context);
    elements.push(...contentElements);
    return elements;
  }
  /**
   * Render text with example references
   */
  renderWithReferences(text, data, context) {
    const elements = [];
    let lastIndex = 0;
    data.references.forEach((ref) => {
      var _a, _b;
      if (ref.startIndex > lastIndex) {
        elements.push(document.createTextNode(text.substring(lastIndex, ref.startIndex)));
      }
      const exampleNumber = (_a = context.getExampleNumber) == null ? void 0 : _a.call(context, ref.label);
      if (exampleNumber !== void 0) {
        const span = document.createElement("span");
        span.className = CSS_CLASSES.EXAMPLE_REF;
        span.textContent = `(${exampleNumber})`;
        const tooltipText = (_b = context.getExampleContent) == null ? void 0 : _b.call(context, ref.label);
        if (tooltipText) {
          (0, import_obsidian12.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
        }
        elements.push(span);
      } else {
        elements.push(document.createTextNode(ref.fullMatch));
      }
      lastIndex = ref.endIndex;
    });
    if (lastIndex < text.length) {
      elements.push(document.createTextNode(text.substring(lastIndex)));
    }
    return elements;
  }
  /**
   * Create a line break element
   */
  createLineBreak() {
    return document.createElement("br");
  }
  /**
   * Create a newline text node
   */
  createNewline() {
    return document.createTextNode("\n");
  }
  /**
   * Process content text for references and return appropriate elements
   */
  processContentForReferences(content, context) {
    if (!context) {
      return [document.createTextNode(content)];
    }
    const references = ListPatterns.findExampleReferences(content);
    if (references.length === 0) {
      const customRefs = ListPatterns.findCustomLabelReferences(content);
      if (customRefs.length === 0) {
        return [document.createTextNode(content)];
      }
      return [document.createTextNode(content)];
    }
    const elements = [];
    let lastIndex = 0;
    references.forEach((match) => {
      var _a, _b;
      const startIndex = match.index;
      const endIndex = startIndex + match[0].length;
      const label = match[1];
      if (startIndex > lastIndex) {
        elements.push(document.createTextNode(content.substring(lastIndex, startIndex)));
      }
      const exampleNumber = (_a = context.getExampleNumber) == null ? void 0 : _a.call(context, label);
      if (exampleNumber !== void 0) {
        const span = document.createElement("span");
        span.className = CSS_CLASSES.EXAMPLE_REF;
        span.textContent = `(${exampleNumber})`;
        const tooltipText = (_b = context.getExampleContent) == null ? void 0 : _b.call(context, label);
        if (tooltipText) {
          (0, import_obsidian12.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
        }
        elements.push(span);
      } else {
        elements.push(document.createTextNode(match[0]));
      }
      lastIndex = endIndex;
    });
    if (lastIndex < content.length) {
      elements.push(document.createTextNode(content.substring(lastIndex)));
    }
    return elements;
  }
};

// src/reading-mode/parsers/customLabelListParser.ts
function processCustomLabelLists(element, context, placeholderContext) {
  if (!element.textContent || !element.textContent.includes("{::")) {
    return;
  }
  if (placeholderContext) {
    const allElements = element.querySelectorAll("p, li");
    allElements.forEach((elem) => {
      const text = elem.textContent || "";
      const lines = text.split("\n");
      for (const line of lines) {
        const listMatch = ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT.exec(line);
        if (listMatch) {
          const labelPart = listMatch[3];
          placeholderContext.processLabel(labelPart);
        }
      }
    });
  }
  const paragraphs = element.querySelectorAll("p");
  paragraphs.forEach((p) => {
    processElement(p, placeholderContext);
  });
  const listItems = element.querySelectorAll("li");
  listItems.forEach((li) => {
    processElement(li, placeholderContext);
    if (li.querySelector(`.${CSS_CLASSES.PANDOC_LIST_MARKER}`)) {
      li.classList.add("pandoc-custom-label-item");
    }
  });
}
function processTextNode(node, container, placeholderContext) {
  const text = node.textContent || "";
  const listMatch = text.match(ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT);
  if (listMatch) {
    const indent = listMatch[1];
    const rawLabel = listMatch[3];
    const space = listMatch[4];
    const rest = listMatch[5];
    const processedLabel = placeholderContext ? placeholderContext.processLabel(rawLabel) : rawLabel;
    if (indent) {
      container.appendChild(document.createTextNode(indent));
    }
    const markerSpan = document.createElement("span");
    markerSpan.className = CSS_CLASSES.PANDOC_LIST_MARKER;
    markerSpan.textContent = `(${processedLabel})`;
    container.appendChild(markerSpan);
    container.appendChild(document.createTextNode(space));
    processReferencesInText(rest, container, placeholderContext);
  } else {
    processReferencesInText(text, container, placeholderContext);
  }
}
function processReferencesInText(text, container, placeholderContext) {
  const refPattern = ListPatterns.CUSTOM_LABEL_REFERENCE;
  let lastIndex = 0;
  let match;
  while ((match = refPattern.exec(text)) !== null) {
    if (match.index > lastIndex) {
      container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
    }
    const rawLabel = match[1];
    const processedLabel = placeholderContext ? placeholderContext.getProcessedLabel(rawLabel) : rawLabel;
    if (processedLabel === null) {
      container.appendChild(document.createTextNode(match[0]));
    } else {
      const refSpan = document.createElement("span");
      refSpan.className = CSS_CLASSES.CUSTOM_LABEL_REFERENCE_PROCESSED;
      refSpan.setAttribute("data-custom-label-ref", processedLabel);
      refSpan.textContent = `(${processedLabel})`;
      container.appendChild(refSpan);
    }
    lastIndex = refPattern.lastIndex;
  }
  if (lastIndex < text.length) {
    container.appendChild(document.createTextNode(text.substring(lastIndex)));
  }
}
function processElementPreservingSpans(elem, placeholderContext) {
  const walker = createTextNodeWalker(elem, (node2) => {
    const parent = node2.parentElement;
    if (parent && (parent.className === CSS_CLASSES.EXAMPLE_REF || parent.className === CSS_CLASSES.PANDOC_LIST_MARKER || parent.className.includes("pandoc-list-fancy") || parent.className === CSS_CLASSES.EXAMPLE_LIST || parent.className === CSS_CLASSES.CUSTOM_LABEL_REFERENCE_PROCESSED || parent.tagName === "STRONG" || // Skip text inside strong tags that might contain processed content
    parent.tagName === "EM")) {
      return NodeFilter.FILTER_SKIP;
    }
    const grandParent = parent == null ? void 0 : parent.parentElement;
    if (grandParent && (grandParent.className === CSS_CLASSES.EXAMPLE_REF || grandParent.className === CSS_CLASSES.EXAMPLE_LIST)) {
      return NodeFilter.FILTER_SKIP;
    }
    return NodeFilter.FILTER_ACCEPT;
  });
  const nodesToProcess = [];
  let node;
  while (node = walker.nextNode()) {
    if (node.textContent && node.textContent.includes("{::")) {
      nodesToProcess.push(node);
    }
  }
  nodesToProcess.forEach((textNode) => {
    const text = textNode.textContent || "";
    const parent = textNode.parentNode;
    if (!parent) return;
    if (!text.includes("{::")) return;
    const tempContainer = document.createElement("span");
    processReferencesInText(text, tempContainer, placeholderContext);
    while (tempContainer.firstChild) {
      parent.insertBefore(tempContainer.firstChild, textNode);
    }
    parent.removeChild(textNode);
  });
}
function shouldSkipElement(elem) {
  if (elem.querySelector("code, pre") || elem.closest("code, pre")) {
    return true;
  }
  if (!elem.textContent || !elem.textContent.includes("{::")) {
    return true;
  }
  return false;
}
function hasProcessedContent(elem) {
  return !!(elem.querySelector("span") || elem.querySelector("strong") || elem.querySelector("em"));
}
function isProcessedSpan(elemNode) {
  return elemNode.tagName === "SPAN" && (elemNode.className === CSS_CLASSES.EXAMPLE_REF || elemNode.className === CSS_CLASSES.PANDOC_LIST_MARKER || elemNode.className.includes("pandoc-list-fancy") || elemNode.className === CSS_CLASSES.EXAMPLE_LIST || elemNode.className === CSS_CLASSES.CUSTOM_LABEL_REFERENCE_PROCESSED);
}
function processTextNodeLines(node, container, placeholderContext) {
  const text = node.textContent || "";
  const lines = text.split("\n");
  for (let i = 0; i < lines.length; i++) {
    if (i > 0) {
      container.appendChild(document.createTextNode("\n"));
    }
    if (lines[i]) {
      processTextNode({ textContent: lines[i] }, container, placeholderContext);
    }
  }
}
function processElementNode(node, container, placeholderContext) {
  if (isProcessedSpan(node)) {
    container.appendChild(node.cloneNode(true));
  } else if (node.textContent && node.textContent.includes("{::")) {
    const clonedElem = node.cloneNode(false);
    const tempContainer = document.createElement("div");
    Array.from(node.childNodes).forEach((child) => {
      tempContainer.appendChild(child.cloneNode(true));
    });
    processElement(tempContainer, placeholderContext);
    while (tempContainer.firstChild) {
      clonedElem.appendChild(tempContainer.firstChild);
    }
    container.appendChild(clonedElem);
  } else {
    container.appendChild(node.cloneNode(true));
  }
}
function processElement(elem, placeholderContext) {
  if (shouldSkipElement(elem)) {
    return;
  }
  if (hasProcessedContent(elem)) {
    return processElementPreservingSpans(elem, placeholderContext);
  }
  const newContainer = document.createElement("div");
  const childNodes = Array.from(elem.childNodes);
  for (const node of childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      processTextNodeLines(node, newContainer, placeholderContext);
    } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
      newContainer.appendChild(document.createElement("br"));
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      processElementNode(node, newContainer, placeholderContext);
    } else {
      newContainer.appendChild(node.cloneNode(true));
    }
  }
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
  while (newContainer.firstChild) {
    elem.appendChild(newContainer.firstChild);
  }
}

// src/editor-extensions/pandocValidator.ts
function isStrictPandocFormatting(context, strictMode) {
  if (!strictMode) {
    return true;
  }
  const { lines, currentLine } = context;
  const line = lines[currentLine];
  const isPartOfListBlock = currentLine > 0 && isListItem(lines[currentLine - 1], false);
  if (currentLine > 0 && !isPartOfListBlock) {
    const prevLine = lines[currentLine - 1];
    if (prevLine.trim() !== "") {
      return false;
    }
  }
  const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
  if (capitalLetterMatch && capitalLetterMatch[3] === ".") {
    if (capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      return false;
    }
  }
  let isLastItemInList = true;
  if (currentLine < lines.length - 1) {
    const nextLine = lines[currentLine + 1];
    const nextIsListItem = isListItem(nextLine, false);
    if (!nextIsListItem && nextLine.trim() !== "") {
      return false;
    }
    if (nextIsListItem) {
      isLastItemInList = false;
    }
  }
  return true;
}
function isListItem(line, includeCustomLabels = false) {
  if (ListPatterns.FANCY_LIST_WITH_NUMBERS.test(line) || ListPatterns.STANDARD_ORDERED_LIST.test(line) || ListPatterns.UNORDERED_LIST.test(line) || ListPatterns.isExampleList(line) || ListPatterns.isDefinitionMarker(line)) {
    return true;
  }
  if (includeCustomLabels && ListPatterns.isCustomLabelList(line)) {
    return true;
  }
  return false;
}
function formatToPandocStandard(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const result = [];
  let inListBlock = false;
  let lastWasEmpty = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList && !inListBlock) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      inListBlock = true;
    }
    if (!isCurrentLineList && !isEmpty && inListBlock) {
      if (!lastWasEmpty) {
        result.push("");
      }
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (result.length > 0 && !lastWasEmpty && i > 0) {
        result.push("");
      }
      let formattedLine = line;
      result.push(formattedLine);
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        result.push("");
        lastWasEmpty = true;
      } else {
        lastWasEmpty = false;
      }
      continue;
    }
    const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
    if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      const formattedLine = line.replace(ListPatterns.CAPITAL_LETTER_REPLACE, "$1$2  ");
      result.push(formattedLine);
    } else {
      result.push(line);
    }
    lastWasEmpty = isEmpty;
  }
  const cleanedResult = [];
  let prevWasEmpty = false;
  for (const line of result) {
    if (line.trim() === "") {
      if (!prevWasEmpty) {
        cleanedResult.push(line);
        prevWasEmpty = true;
      }
    } else {
      cleanedResult.push(line);
      prevWasEmpty = false;
    }
  }
  return cleanedResult.join("\n");
}
function checkPandocFormatting(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const issues = [];
  let inListBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList) {
      if (!inListBlock && i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "List should have an empty line before it"
        });
      }
      const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
      if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
        issues.push({
          line: i + 1,
          message: "Capital letter list with period requires at least 2 spaces after marker"
        });
      }
      inListBlock = true;
    } else if (!isEmpty && inListBlock) {
      if (i > 0 && isListItem(lines[i - 1])) {
        issues.push({
          line: i,
          message: "List should have an empty line after it"
        });
      }
      inListBlock = false;
    } else if (isEmpty) {
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line before it"
        });
      }
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line after it"
        });
      }
    }
  }
  return issues;
}

// src/reading-mode/processor.ts
function processReadingMode(element, context, config) {
  const docPath = context.sourcePath || "unknown";
  const parser = new ReadingModeParser();
  const renderer = new ReadingModeRenderer();
  const elementsToProcess = element.querySelectorAll("p, li");
  let validationLines = [];
  if (config.strictPandocMode) {
    const section = element.closest(".markdown-preview-section");
    const sectionInfo = getSectionInfo(section);
    if (sectionInfo == null ? void 0 : sectionInfo.text) {
      validationLines = sectionInfo.text.split("\n");
    }
  }
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    if (pluginStateManager.isElementProcessed(elem, "pandoc-processed", docPath)) {
      return;
    }
    processElementTextNodes(elem, parser, renderer, config, docPath, validationLines);
    pluginStateManager.markElementProcessed(elem, "pandoc-processed", true);
  });
  if (config.enableSuperSubscripts) {
    processSuperSub(element);
  }
  if (config.enableCustomLabelLists) {
    const counters = pluginStateManager.getDocumentCounters(docPath);
    processCustomLabelLists(element, context, counters.placeholderContext);
  }
}
function processElementTextNodes(elem, parser, renderer, config, docPath, validationLines) {
  const walker = document.createTreeWalker(
    elem,
    NodeFilter.SHOW_TEXT,
    null
  );
  const nodesToProcess = [];
  while (walker.nextNode()) {
    nodesToProcess.push(walker.currentNode);
  }
  nodesToProcess.forEach((node) => {
    const parent = node.parentNode;
    if (!parent) return;
    if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
      return;
    }
    const text = node.textContent || "";
    if (!containsPandocSyntax(text, config)) {
      return;
    }
    const isInParagraph = parent.nodeName === "P";
    const isAtParagraphStart = parent.firstChild === node;
    const lines = text.split("\n");
    const parsedLines = parser.parseLines(lines, isInParagraph, isAtParagraphStart);
    if (config.strictPandocMode) {
      parsedLines.forEach((parsedLine, index) => {
        if (parsedLine.type === "fancy" && validationLines.length > 0) {
          if (!validateListInStrictMode(lines[index], validationLines, config)) {
            parsedLine.type = "plain";
          }
        }
      });
    }
    const renderContext = {
      strictLineBreaks: config.strictLineBreaks,
      getExampleNumber: (label) => pluginStateManager.getLabeledExampleNumber(docPath, label),
      getExampleContent: (label) => pluginStateManager.getLabeledExampleContent(docPath, label)
    };
    const numberProvider = (type, index) => {
      var _a;
      const parsedLine = parsedLines[index];
      if (type === "hash") {
        return pluginStateManager.incrementHashCounter(docPath);
      }
      if (type === "example" && parsedLine.type === "example") {
        const metadata = parsedLine.metadata;
        const number = pluginStateManager.incrementExampleCounter(docPath);
        if (metadata.label) {
          pluginStateManager.setLabeledExample(
            docPath,
            metadata.label,
            number,
            (_a = metadata.content) == null ? void 0 : _a.trim()
          );
        }
        return number;
      }
      return 0;
    };
    const newElements = renderer.renderLines(parsedLines, renderContext, numberProvider);
    if (newElements.length > 0) {
      newElements.forEach((elem2) => {
        parent.insertBefore(elem2, node);
      });
      parent.removeChild(node);
    }
  });
}
function containsPandocSyntax(text, config) {
  const hasBasicSyntax = ListPatterns.isHashList(text) || ListPatterns.isFancyList(text) || ListPatterns.isExampleList(text) || ListPatterns.isDefinitionMarker(text) || ListPatterns.findExampleReferences(text).length > 0;
  const hasCustomLabelSyntax = (config == null ? void 0 : config.enableCustomLabelLists) && (ListPatterns.isCustomLabelList(text) || ListPatterns.findCustomLabelReferences(text).length > 0);
  return hasBasicSyntax || hasCustomLabelSyntax;
}
function validateListInStrictMode(line, documentLines, config) {
  let lineNum = -1;
  for (let i = 0; i < documentLines.length; i++) {
    if (documentLines[i].includes(line.trim())) {
      lineNum = i;
      break;
    }
  }
  if (lineNum >= 0) {
    const validationContext = {
      lines: documentLines,
      currentLine: lineNum
    };
    return isStrictPandocFormatting(validationContext, config.strictPandocMode);
  }
  return true;
}

// src/editor-extensions/suggestions/exampleReferenceSuggest.ts
var import_obsidian13 = require("obsidian");
var ExampleReferenceSuggest = class extends import_obsidian13.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = ListPatterns.findExampleRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = ListPatterns.isExampleList(line);
      if (match) {
        const label = match[3];
        if (label) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!exampleData.has(label)) {
            exampleData.set(label, { number: counter, text });
          }
        }
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > TEXT_PROCESSING.PREVIEW_TRUNCATE_LENGTH) {
          previewText = previewText.substring(0, TEXT_PROCESSING.PREVIEW_TRUNCATE_LENGTH) + TEXT_PROCESSING.PREVIEW_ELLIPSIS;
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/editor-extensions/suggestions/customLabelReferenceSuggest.ts
var import_obsidian14 = require("obsidian");
var CustomLabelReferenceSuggest = class extends import_obsidian14.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    if (!this.plugin.settings.moreExtendedSyntax) return null;
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.includes("{::")) return null;
    const matches = ListPatterns.findCustomLabelRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterStart = line.substring(startIndex + 3);
    if (afterStart.includes("}")) return null;
    const query = afterStart;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  /**
   * Scans the document for custom label definitions.
   * @returns Map of raw labels to their content
   */
  scanDocumentForLabels(doc) {
    const lines = doc.split("\n");
    const labelData = /* @__PURE__ */ new Map();
    for (const line of lines) {
      const match = ListPatterns.isCustomLabelList(line);
      if (match) {
        const rawLabel = match[3];
        if (rawLabel) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!labelData.has(rawLabel)) {
            labelData.set(rawLabel, { text, rawLabel });
          }
        }
      }
    }
    return labelData;
  }
  /**
   * Processes a label to extract placeholder information.
   */
  extractPlaceholderParts(rawLabel, placeholderContext) {
    const placeholderParts = [];
    const regex = /\(#([^)]+)\)/g;
    let match;
    while ((match = regex.exec(rawLabel)) !== null) {
      const placeholderName = match[1];
      const placeholderNumber = placeholderContext.getPlaceholderNumber(placeholderName);
      if (placeholderNumber !== null) {
        placeholderParts.push({
          original: match[0],
          replacement: placeholderNumber.toString(),
          index: match.index
        });
      }
    }
    return placeholderParts.length > 0 ? placeholderParts : null;
  }
  getSuggestions(context) {
    return withErrorBoundary(() => this.getSuggestionsInternal(context), [], "CustomLabelReferenceSuggest.getSuggestions");
  }
  getSuggestionsInternal(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const labelData = this.scanDocumentForLabels(doc);
    const placeholderContext = new PlaceholderContext();
    for (const [rawLabel] of labelData) {
      if (/\(#[^)]+\)/.test(rawLabel)) {
        placeholderContext.processLabel(rawLabel);
      }
    }
    const suggestions = [];
    for (const [rawLabel, data] of labelData) {
      let processedLabel = null;
      if (/\(#[^)]+\)/.test(rawLabel)) {
        processedLabel = placeholderContext.processLabel(rawLabel);
      }
      const matchesRaw = !query || rawLabel.toLowerCase().startsWith(query.toLowerCase());
      const matchesProcessed = processedLabel && (!query || processedLabel.toLowerCase().startsWith(query.toLowerCase()));
      if (matchesRaw || matchesProcessed) {
        let previewText = data.text;
        if (previewText.length > TEXT_PROCESSING.PREVIEW_TRUNCATE_LENGTH) {
          previewText = previewText.substring(0, TEXT_PROCESSING.PREVIEW_TRUNCATE_LENGTH) + TEXT_PROCESSING.PREVIEW_ELLIPSIS;
        }
        let displayLabel = processedLabel;
        let placeholderParts = null;
        if (processedLabel) {
          placeholderParts = this.extractPlaceholderParts(rawLabel, placeholderContext);
        }
        suggestions.push({
          label: rawLabel,
          displayLabel,
          placeholderParts,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  /**
   * Renders a suggestion item with styled placeholder display.
   */
  renderSuggestion(suggestion, el) {
    withErrorBoundary(() => this.renderSuggestionInternal(suggestion, el), void 0, "CustomLabelReferenceSuggest.renderSuggestion");
  }
  renderSuggestionInternal(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    if (suggestion.displayLabel && suggestion.placeholderParts) {
      title.setText("::");
      let lastIndex = 0;
      const sortedParts = [...suggestion.placeholderParts].sort((a, b) => a.index - b.index);
      for (const part of sortedParts) {
        if (part.index > lastIndex) {
          const beforeText = suggestion.label.substring(lastIndex, part.index);
          title.createSpan().setText(beforeText);
        }
        const numberSpan = title.createSpan({ cls: CSS_CLASSES.SUGGESTION_NUMBER });
        numberSpan.setText(part.replacement);
        const placeholderSpan = title.createSpan({ cls: CSS_CLASSES.SUGGESTION_PLACEHOLDER });
        placeholderSpan.setText(part.original);
        lastIndex = part.index + part.original.length;
      }
      if (lastIndex < suggestion.label.length) {
        const afterText = suggestion.label.substring(lastIndex);
        title.createSpan().setText(afterText);
      }
    } else {
      title.setText(`::${suggestion.label}`);
    }
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  /**
   * Handles selection of a suggestion, inserting the original label.
   */
  selectSuggestion(suggestion, evt) {
    withErrorBoundary(() => this.selectSuggestionInternal(suggestion, evt), void 0, "CustomLabelReferenceSuggest.selectSuggestion");
  }
  selectSuggestionInternal(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingBrace = afterCursor.startsWith("}");
    let replacement;
    if (hasClosingBrace) {
      replacement = `{::${suggestion.label}`;
    } else {
      replacement = `{::${suggestion.label}}`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingBrace) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/editor-extensions/listAutocompletion/utils/lineInfo.ts
function getCurrentLineInfo(view) {
  const state = view.state;
  const selection = state.selection.main;
  const line = state.doc.lineAt(selection.from);
  const lineText = line.text;
  const isAtEndOfLine = selection.from === line.to;
  const distanceFromEnd = line.to - selection.from;
  return {
    line,
    lineText,
    selection,
    isAtEndOfLine,
    distanceFromEnd
  };
}

// src/editor-extensions/listAutocompletion/utils/markerDetection.ts
function detectListMarker(currentLine, view) {
  const { lineText, selection, line, distanceFromEnd } = currentLine;
  const state = view.state;
  const isEmptyExampleList = lineText.match(ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL);
  if (isEmptyExampleList) {
    const beforeCursor = state.doc.sliceString(line.from, selection.from);
    const afterCursor = state.doc.sliceString(selection.from, line.to);
    if (beforeCursor.endsWith("(@") && afterCursor.startsWith(")")) {
      return {
        isListItem: true,
        shouldHandleEnter: true,
        isEmptyExampleListSpecial: true,
        isEmptyCustomLabelSpecial: false
      };
    }
  }
  const isEmptyCustomLabelList = lineText.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL);
  if (isEmptyCustomLabelList) {
    const beforeCursor = state.doc.sliceString(line.from, selection.from);
    const afterCursor = state.doc.sliceString(selection.from, line.to);
    if (beforeCursor.endsWith("{::") && afterCursor.startsWith("}")) {
      return {
        isListItem: true,
        shouldHandleEnter: true,
        isEmptyExampleListSpecial: false,
        isEmptyCustomLabelSpecial: true
      };
    }
  }
  const isListItem2 = lineText.match(ListPatterns.ANY_LIST_MARKER);
  if (!isListItem2) {
    const shouldHandle2 = selection.from === line.to && selection.from === selection.to;
    return {
      isListItem: false,
      shouldHandleEnter: shouldHandle2,
      isEmptyExampleListSpecial: false,
      isEmptyCustomLabelSpecial: false
    };
  }
  const shouldHandle = distanceFromEnd <= 2 && selection.from === selection.to;
  return {
    isListItem: true,
    shouldHandleEnter: shouldHandle,
    isEmptyExampleListSpecial: false,
    isEmptyCustomLabelSpecial: false
  };
}
function isExtendedList(lineText) {
  return !!(ListPatterns.isFancyList(lineText) || ListPatterns.isExampleList(lineText) || ListPatterns.isCustomLabelList(lineText) || ListPatterns.isHashList(lineText));
}

// src/editor-extensions/listAutocompletion/handlers/emptyListHandler.ts
var import_state3 = require("@codemirror/state");

// src/shared/utils/listHelpers.ts
function getNextLetter(letter) {
  if (letter === "Z" || letter === "z") {
    return null;
  }
  return String.fromCharCode(letter.charCodeAt(0) + 1);
}
function numberToLetter(num, isUpperCase) {
  const letter = String.fromCharCode("A".charCodeAt(0) + num - 1);
  return isUpperCase ? letter : letter.toLowerCase();
}
function romanToInt(roman) {
  const romanValues = ROMAN_NUMERALS.VALUES;
  let value = 0;
  let i = 0;
  const normalizedRoman = roman.toLowerCase();
  while (i < normalizedRoman.length) {
    if (i + 1 < normalizedRoman.length && romanValues[normalizedRoman.substring(i, i + 2)]) {
      value += romanValues[normalizedRoman.substring(i, i + 2)];
      i += 2;
    } else {
      value += romanValues[normalizedRoman[i]] || 0;
      i++;
    }
  }
  return value;
}
function intToRoman(num, isUpperCase) {
  let result = "";
  const table = isUpperCase ? ROMAN_NUMERALS.TO_ROMAN_UPPER : ROMAN_NUMERALS.TO_ROMAN_LOWER;
  for (const [value, sym] of table) {
    while (num >= value) {
      result += sym;
      num -= value;
    }
  }
  return result;
}
function getNextRoman(roman) {
  const value = romanToInt(roman);
  const isUpperCase = roman[0] === roman[0].toUpperCase();
  return intToRoman(value + 1, isUpperCase);
}
function isEmptyListItem(line) {
  if (line.match(ListPatterns.EMPTY_HASH_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_FANCY_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL)) return true;
  if (line.match(ListPatterns.EMPTY_DEFINITION_LIST)) return true;
  return false;
}

// src/shared/utils/listMarkerDetector.ts
function parseMarkerParts(line) {
  const hashMatch = ListPatterns.isHashList(line);
  if (hashMatch) {
    return {
      type: "hash",
      indent: hashMatch[1],
      marker: "#.",
      spaces: hashMatch[3]
    };
  }
  const customLabelMatch = ListPatterns.isCustomLabelList(line);
  if (customLabelMatch) {
    return {
      type: "custom-label",
      indent: customLabelMatch[1],
      marker: "{::}",
      spaces: customLabelMatch[4]
      // Group 4 is spaces in CUSTOM_LABEL_LIST pattern
    };
  }
  const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_LIST);
  if (listMatch) {
    return {
      type: "unknown",
      // Will be determined by detectListType
      indent: listMatch[1],
      marker: listMatch[2],
      punctuation: listMatch[3],
      spaces: listMatch[4]
    };
  }
  const exampleMatch = line.match(ListPatterns.EXAMPLE_LIST);
  if (exampleMatch) {
    return {
      type: LIST_TYPES.EXAMPLE,
      indent: exampleMatch[1],
      marker: LIST_MARKERS.EXAMPLE_FULL,
      spaces: exampleMatch[4]
      // Group 4 is spaces in EXAMPLE_LIST pattern
    };
  }
  const altMatch = line.match(ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE);
  if (altMatch && line.length > altMatch[0].length) {
    return {
      type: LIST_TYPES.EXAMPLE,
      indent: altMatch[1],
      marker: LIST_MARKERS.EXAMPLE_FULL,
      spaces: altMatch[3] || " "
      // Group 3 is spaces in EXAMPLE_LIST_OPTIONAL_SPACE pattern
    };
  }
  const definitionMatch = line.match(ListPatterns.DEFINITION_MARKER);
  if (definitionMatch) {
    return {
      type: LIST_TYPES.DEFINITION,
      indent: definitionMatch[1],
      marker: definitionMatch[2],
      spaces: definitionMatch[3]
    };
  }
  return null;
}
function detectListType(components, context) {
  if (components.type !== "unknown") {
    return components.type;
  }
  const { marker, indent, punctuation } = components;
  const { allLines, currentLineIndex } = context;
  if (marker.length > NUMERIC_CONSTANTS.SINGLE_CHARACTER && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
    return "roman";
  }
  if (marker.length === NUMERIC_CONSTANTS.SINGLE_CHARACTER && allLines && currentLineIndex !== void 0) {
    return detectSingleCharacterType(marker, indent, punctuation || "", allLines, currentLineIndex);
  }
  return "letter";
}
function detectSingleCharacterType(marker, indent, punctuation, allLines, currentLineIndex) {
  if (marker.match(ListPatterns.SINGLE_I)) {
    return detectIMarkerType(indent, punctuation, allLines, currentLineIndex);
  }
  return detectGeneralSingleCharType(indent, punctuation, allLines, currentLineIndex);
}
function detectIMarkerType(indent, punctuation, allLines, currentLineIndex) {
  let isRoman = true;
  for (let i = currentLineIndex - 1; i >= NUMERIC_CONSTANTS.FIRST_INDEX; i--) {
    const prevLine = allLines[i];
    if (!prevLine.trim()) continue;
    if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
    const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
    if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
      const prevMarker = prevMatch[2];
      if (prevMarker.match(ListPatterns.SINGLE_H)) {
        isRoman = false;
        break;
      } else if (prevMarker.length > NUMERIC_CONSTANTS.SINGLE_CHARACTER && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
        isRoman = true;
        break;
      } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
        isRoman = false;
        break;
      }
    }
  }
  return isRoman ? "roman" : "letter";
}
function detectGeneralSingleCharType(indent, punctuation, allLines, currentLineIndex) {
  for (let i = currentLineIndex - 1; i >= NUMERIC_CONSTANTS.FIRST_INDEX; i--) {
    const prevLine = allLines[i];
    if (!prevLine.trim()) continue;
    if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
    const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
    if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
      const prevMarker = prevMatch[2];
      if (prevMarker.length > NUMERIC_CONSTANTS.SINGLE_CHARACTER && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
        return "roman";
      } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
        return "letter";
      } else if (prevMarker.match(ListPatterns.SINGLE_AB)) {
        return "letter";
      }
    }
  }
  return "letter";
}
function incrementNumericMarker(components) {
  return {
    marker: components.marker,
    // '#.' stays the same
    indent: components.indent,
    spaces: components.spaces
  };
}
function incrementAlphabeticMarker(components) {
  const nextLetter = getNextLetter(components.marker);
  if (nextLetter) {
    return {
      marker: `${nextLetter}${components.punctuation}`,
      indent: components.indent,
      spaces: components.spaces
    };
  }
  return null;
}
function incrementRomanMarker(components) {
  if (components.marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
    const nextRoman = getNextRoman(components.marker);
    return {
      marker: `${nextRoman}${components.punctuation}`,
      indent: components.indent,
      spaces: components.spaces
    };
  }
  return null;
}
function handleSpecialCases(components) {
  switch (components.type) {
    case "example":
      return {
        marker: components.marker,
        // '(@)' stays the same
        indent: components.indent,
        spaces: components.spaces
      };
    case "definition":
      return {
        marker: components.marker,
        // ':' or '~' stays the same
        indent: components.indent,
        spaces: components.spaces
      };
    case "custom-label":
      return {
        marker: components.marker,
        // '{::}' stays the same
        indent: components.indent,
        spaces: components.spaces
      };
    default:
      return null;
  }
}
function getNextListMarker(currentLine, allLines, currentLineIndex) {
  const context = { currentLine, allLines, currentLineIndex };
  const components = parseMarkerParts(currentLine);
  if (!components) {
    return null;
  }
  const listType = detectListType(components, context);
  components.type = listType;
  switch (listType) {
    case "hash":
      return incrementNumericMarker(components);
    case "letter":
      return incrementAlphabeticMarker(components);
    case "roman":
      return incrementRomanMarker(components);
    case "example":
    case "definition":
    case "custom-label":
      return handleSpecialCases(components);
    default:
      return null;
  }
}

// src/editor-extensions/listAutocompletion/utils/indentation.ts
function calculateIndentation(currentIndent) {
  let newIndent = "";
  if (currentIndent.startsWith(INDENTATION.FOUR_SPACES)) {
    newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
  } else if (currentIndent.startsWith(INDENTATION.TAB)) {
    newIndent = currentIndent.substring(1);
  } else {
    newIndent = currentIndent.substring(Math.min(INDENTATION.TAB_SIZE, currentIndent.length));
  }
  return newIndent;
}
function removeIndentLevel(currentIndent) {
  if (currentIndent.startsWith(INDENTATION.FOUR_SPACES)) {
    return currentIndent.substring(INDENTATION.TAB_SIZE);
  } else if (currentIndent.startsWith(INDENTATION.TAB)) {
    return currentIndent.substring(1);
  } else {
    return currentIndent.substring(Math.min(INDENTATION.TAB_SIZE, currentIndent.length));
  }
}

// src/editor-extensions/listAutocompletion/handlers/emptyListHandler.ts
function handleEmptyListSpecialCases(config) {
  const { view, currentLine, beforeCursor, afterCursor } = config;
  const { line, lineText } = currentLine;
  const state = view.state;
  if (beforeCursor.endsWith("(@") && afterCursor.startsWith(")")) {
    const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
    const indent = indentMatch ? indentMatch[1] : "";
    const changes = {
      from: line.from,
      to: line.to,
      insert: indent
    };
    const transaction = state.update({
      changes,
      selection: import_state3.EditorSelection.cursor(line.from + indent.length)
    });
    view.dispatch(transaction);
    return true;
  }
  if (beforeCursor.endsWith("{::") && afterCursor.startsWith("}")) {
    const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
    const indent = indentMatch ? indentMatch[1] : "";
    const changes = {
      from: line.from,
      to: line.to,
      insert: indent
    };
    const transaction = state.update({
      changes,
      selection: import_state3.EditorSelection.cursor(line.from + indent.length)
    });
    view.dispatch(transaction);
    return true;
  }
  return false;
}
function handleEmptyListItem(config) {
  const { view, currentLine } = config;
  const { line, lineText } = currentLine;
  const state = view.state;
  if (!isEmptyListItem(lineText)) {
    return false;
  }
  const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
  if (indentMatch && indentMatch[1].length >= INDENTATION.TAB_SIZE) {
    const currentIndent = indentMatch[1];
    const newIndent = calculateIndentation(currentIndent);
    let previousMarker = null;
    for (let i = line.number - 1; i >= 1; i--) {
      const prevLine = state.doc.line(i);
      const prevText = prevLine.text;
      const prevIndentMatch = prevText.match(ListPatterns.INDENT_ONLY);
      if (prevIndentMatch && prevIndentMatch[1] === newIndent) {
        const allLines = state.doc.toString().split("\n");
        const markerInfo = getNextListMarker(prevText, allLines, i - 1);
        if (markerInfo) {
          previousMarker = markerInfo;
          break;
        }
      }
    }
    if (previousMarker && newIndent.length > 0) {
      const spaces = previousMarker.spaces || " ";
      const newLine = `${newIndent}${previousMarker.marker}${spaces}`;
      const changes2 = {
        from: line.from,
        to: line.to,
        insert: newLine
      };
      const transaction2 = state.update({
        changes: changes2,
        selection: import_state3.EditorSelection.cursor(line.from + newLine.length)
      });
      view.dispatch(transaction2);
      return true;
    }
  }
  const changes = {
    from: line.from,
    to: line.to,
    insert: ""
  };
  const transaction = state.update({
    changes,
    selection: import_state3.EditorSelection.cursor(line.from)
  });
  view.dispatch(transaction);
  return true;
}

// src/editor-extensions/listAutocompletion/handlers/listItemHandler.ts
var import_state4 = require("@codemirror/state");

// src/shared/utils/listRenumbering.ts
function calculateIndentLength(indent) {
  let length = NUMERIC_CONSTANTS.EMPTY_LENGTH;
  for (const char of indent) {
    length += char === INDENTATION.TAB ? INDENTATION.TAB_SIZE : INDENTATION.SINGLE_SPACE;
  }
  return length;
}
function findBlockBoundaries(allLines, insertedLineNum) {
  let blockStart = insertedLineNum;
  let blockEnd = insertedLineNum;
  const insertedLine = allLines[insertedLineNum];
  const insertedIndentMatch = insertedLine.match(ListPatterns.INDENT_ONLY);
  const insertedIndent = insertedIndentMatch ? insertedIndentMatch[1] : "";
  const insertedIndentLength = calculateIndentLength(insertedIndent);
  for (let i = insertedLineNum - 1; i >= NUMERIC_CONSTANTS.MIN_DOC_POSITION; i--) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    const indentMatch = line.match(ListPatterns.INDENT_ONLY);
    const lineIndent = indentMatch ? indentMatch[1] : "";
    const lineIndentLength = calculateIndentLength(lineIndent);
    if (listMatch) {
      if (lineIndentLength < insertedIndentLength) {
        break;
      }
      if (lineIndentLength === insertedIndentLength) {
        blockStart = i;
      }
      continue;
    }
    if (lineIndentLength > insertedIndentLength) {
      continue;
    }
    break;
  }
  for (let i = insertedLineNum + 1; i < allLines.length; i++) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    const indentMatch = line.match(ListPatterns.INDENT_ONLY);
    const lineIndent = indentMatch ? indentMatch[1] : "";
    const lineIndentLength = calculateIndentLength(lineIndent);
    if (listMatch) {
      if (lineIndentLength < insertedIndentLength) {
        break;
      }
      if (lineIndentLength === insertedIndentLength) {
        blockEnd = i;
      }
      continue;
    }
    if (lineIndentLength > insertedIndentLength) {
      continue;
    }
    break;
  }
  return {
    blockStart,
    blockEnd,
    insertedIndent
  };
}
function collectListItems(allLines, boundaries) {
  const listItems = [];
  const { blockStart, blockEnd, insertedIndent } = boundaries;
  for (let i = blockStart; i <= blockEnd; i++) {
    const line = allLines[i];
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT);
    if (listMatch && listMatch[1] === insertedIndent) {
      const marker = listMatch[2];
      const punctuation = listMatch[3];
      const spaces = listMatch[4];
      const content = listMatch[5];
      const typeInfo = determineListType(marker, i, blockStart, listItems);
      listItems.push({
        lineNum: i,
        marker,
        punctuation,
        spaces,
        content,
        isRoman: typeInfo.isRoman,
        isAlpha: typeInfo.isAlpha
      });
    }
  }
  return listItems;
}
function determineListType(marker, currentLineIndex, blockStartIndex, existingItems) {
  let isRoman = false;
  let isAlpha = false;
  if (marker === "#") {
    return { isRoman, isAlpha };
  }
  if (!marker.match(ListPatterns.ALPHABETIC_CHARS)) {
    return { isRoman, isAlpha };
  }
  if (marker.length > NUMERIC_CONSTANTS.SINGLE_CHARACTER && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
    isRoman = true;
  } else if (marker.length === NUMERIC_CONSTANTS.SINGLE_CHARACTER && marker.match(ListPatterns.SINGLE_ROMAN_CHAR)) {
    if (currentLineIndex === blockStartIndex) {
      isRoman = marker.match(ListPatterns.SINGLE_I) !== null;
      if (!isRoman) {
        isAlpha = true;
      }
    } else {
      isRoman = existingItems.length > NUMERIC_CONSTANTS.EMPTY_LENGTH && existingItems[NUMERIC_CONSTANTS.FIRST_INDEX].isRoman;
      isAlpha = existingItems.length > NUMERIC_CONSTANTS.EMPTY_LENGTH && existingItems[NUMERIC_CONSTANTS.FIRST_INDEX].isAlpha;
    }
  } else {
    isAlpha = true;
  }
  return { isRoman, isAlpha };
}
function calculateNewMarker(item, itemIndex) {
  if (item.marker === "#") {
    return "#";
  }
  if (item.isRoman) {
    const isUpperCase = item.marker[NUMERIC_CONSTANTS.FIRST_INDEX] === item.marker[NUMERIC_CONSTANTS.FIRST_INDEX].toUpperCase();
    return intToRoman(itemIndex + 1, isUpperCase);
  }
  if (item.isAlpha) {
    const isUpperCase = item.marker[NUMERIC_CONSTANTS.FIRST_INDEX] === item.marker[NUMERIC_CONSTANTS.FIRST_INDEX].toUpperCase();
    return numberToLetter(itemIndex + 1, isUpperCase);
  }
  return item.marker;
}
function validateListBlock(listItems) {
  return listItems.length > NUMERIC_CONSTANTS.SINGLE_CHARACTER;
}
function applyNumberingChanges(view, listItems, insertedIndent) {
  const state = view.state;
  const doc = state.doc;
  const allLines = doc.toString().split("\n");
  const changes = [];
  for (let i = NUMERIC_CONSTANTS.FIRST_INDEX; i < listItems.length; i++) {
    const item = listItems[i];
    const newMarker = calculateNewMarker(item, i);
    const newLine = `${insertedIndent}${newMarker}${item.punctuation}${item.spaces}${item.content}`;
    const oldLine = allLines[item.lineNum];
    if (newLine !== oldLine) {
      const lineStartPos = doc.line(item.lineNum + 1).from;
      const lineEndPos = doc.line(item.lineNum + 1).to;
      changes.push({
        from: lineStartPos,
        to: lineEndPos,
        insert: newLine
      });
    }
  }
  if (changes.length > NUMERIC_CONSTANTS.EMPTY_LENGTH) {
    const transaction = state.update({ changes });
    view.dispatch(transaction);
  }
}
function renumberListItems(view, insertedLineNum) {
  const state = view.state;
  const doc = state.doc;
  const allLines = doc.toString().split("\n");
  const boundaries = findBlockBoundaries(allLines, insertedLineNum);
  const listItems = collectListItems(allLines, boundaries);
  if (validateListBlock(listItems)) {
    applyNumberingChanges(view, listItems, boundaries.insertedIndent);
  }
}

// src/editor-extensions/listAutocompletion/handlers/listItemHandler.ts
function insertNewListItem(config) {
  const { view, currentLine, markerInfo, settings } = config;
  const { line, selection } = currentLine;
  const state = view.state;
  const spaces = markerInfo.spaces || " ";
  const newLine = `
${markerInfo.indent}${markerInfo.marker}${spaces}`;
  const insertPos = selection.from === line.to ? selection.from : line.to;
  const changes = {
    from: insertPos,
    to: insertPos,
    insert: newLine
  };
  const cursorOffset = markerInfo.marker === "(@)" ? newLine.length - spaces.length - 1 : markerInfo.marker === "{::}" ? newLine.length - spaces.length - 1 : newLine.length;
  const transaction = state.update({
    changes,
    selection: import_state4.EditorSelection.cursor(insertPos + cursorOffset)
  });
  view.dispatch(transaction);
  if (settings.autoRenumberLists && markerInfo.marker !== "(@)" && markerInfo.marker !== "{::}" && markerInfo.marker !== "#." && !markerInfo.marker.match(ListPatterns.DEFINITION_MARKER_ONLY)) {
    const newLineNum = line.number;
    setTimeout(() => {
      renumberListItems(view, newLineNum);
    }, 0);
  }
  return true;
}
function handleNonEmptyListItem(config) {
  const { currentLine } = config;
  const { lineText } = currentLine;
  if (lineText.match(ListPatterns.NUMBERED_LIST_WITH_SPACE)) {
    return false;
  }
  const state = config.view.state;
  const allLines = state.doc.toString().split("\n");
  const currentLineIndex = currentLine.line.number - 1;
  const markerInfo = getNextListMarker(lineText, allLines, currentLineIndex);
  if (markerInfo) {
    const newConfig = { ...config, markerInfo };
    return insertNewListItem(newConfig);
  }
  return false;
}

// src/editor-extensions/listAutocompletion/handlers/continuationHandler.ts
var import_state5 = require("@codemirror/state");

// src/editor-extensions/listAutocompletion/utils/continuationUtils.ts
function findLastListItem(state, currentLineNumber) {
  let lastListLine = null;
  let lastListLineText = "";
  let searchLineNum = currentLineNumber - 1;
  while (searchLineNum >= 1) {
    const prevLine = state.doc.line(searchLineNum);
    const prevText = prevLine.text;
    if (ListPatterns.isFancyList(prevText) || ListPatterns.isExampleList(prevText) || ListPatterns.isCustomLabelList(prevText) || ListPatterns.isHashList(prevText)) {
      lastListLine = prevLine;
      lastListLineText = prevText;
    }
    const prevIndent = prevText.match(/^(\s*)/);
    if (prevIndent && prevIndent[1].length === 0 && prevText.trim() !== "" && !ListPatterns.isFancyList(prevText) && !ListPatterns.isExampleList(prevText) && !ListPatterns.isCustomLabelList(prevText) && !ListPatterns.isHashList(prevText)) {
      break;
    }
    searchLineNum--;
  }
  if (lastListLine) {
    for (let lineNum = lastListLine.number; lineNum < currentLineNumber; lineNum++) {
      const line = state.doc.line(lineNum);
      const text = line.text;
      if (ListPatterns.isFancyList(text) || ListPatterns.isExampleList(text) || ListPatterns.isCustomLabelList(text) || ListPatterns.isHashList(text)) {
        lastListLine = line;
        lastListLineText = text;
      }
    }
  }
  return lastListLine ? { line: lastListLine, text: lastListLineText } : null;
}

// src/editor-extensions/listAutocompletion/handlers/continuationHandler.ts
function handleContinuationLine(config) {
  const { view, currentLine, settings } = config;
  const state = view.state;
  const { lineText } = currentLine;
  const indentMatch = lineText.match(/^(\s+)/);
  const isIndented = indentMatch && (indentMatch[1].length >= 2 || indentMatch[1].includes("	"));
  if (!isIndented || lineText.match(ListPatterns.ANY_LIST_MARKER)) {
    return false;
  }
  const lastListItem = findLastListItem(state, currentLine.line.number);
  if (!lastListItem) {
    return false;
  }
  const allLines = state.doc.toString().split("\n");
  const markerInfo = getNextListMarker(lastListItem.text, allLines, lastListItem.line.number - 1);
  if (!markerInfo) {
    return false;
  }
  const spaces = markerInfo.spaces || " ";
  const newLine = `
${markerInfo.indent}${markerInfo.marker}${spaces}`;
  const insertPos = currentLine.line.to;
  const changes = {
    from: insertPos,
    to: insertPos,
    insert: newLine
  };
  const cursorOffset = markerInfo.marker === "(@)" ? newLine.length - spaces.length - 1 : markerInfo.marker === "{::}" ? newLine.length - spaces.length - 1 : newLine.length;
  const transaction = state.update({
    changes,
    selection: import_state5.EditorSelection.cursor(insertPos + cursorOffset)
  });
  view.dispatch(transaction);
  if (settings.autoRenumberLists && markerInfo.marker !== "(@)" && markerInfo.marker !== "{::}" && markerInfo.marker !== "#." && !markerInfo.marker.match(ListPatterns.DEFINITION_MARKER_ONLY)) {
    const newLineNum = currentLine.line.number;
    setTimeout(() => {
      renumberListItems(view, newLineNum);
    }, 0);
  }
  return true;
}

// src/editor-extensions/listAutocompletion/handlers/enterHandler.ts
function createEnterHandler(settings) {
  return {
    key: "Enter",
    run: (view) => {
      const currentLine = getCurrentLineInfo(view);
      const continuationConfig = {
        view,
        currentLine,
        settings
      };
      if (handleContinuationLine(continuationConfig)) {
        return true;
      }
      const detection = detectListMarker(currentLine, view);
      if (!detection.shouldHandleEnter) {
        return false;
      }
      if (detection.isEmptyExampleListSpecial || detection.isEmptyCustomLabelSpecial) {
        const state = view.state;
        const beforeCursor = state.doc.sliceString(currentLine.line.from, currentLine.selection.from);
        const afterCursor = state.doc.sliceString(currentLine.selection.from, currentLine.line.to);
        const specialConfig = {
          view,
          currentLine,
          beforeCursor,
          afterCursor
        };
        return handleEmptyListSpecialCases(specialConfig);
      }
      if (currentLine.lineText.match(ListPatterns.NUMBERED_LIST_WITH_SPACE)) {
        return false;
      }
      const emptyListConfig = {
        view,
        currentLine,
        beforeCursor: "",
        afterCursor: ""
      };
      if (handleEmptyListItem(emptyListConfig)) {
        return true;
      }
      const nonEmptyConfig = {
        view,
        currentLine,
        settings
      };
      return handleNonEmptyListItem(nonEmptyConfig);
    }
  };
}

// src/editor-extensions/listAutocompletion/handlers/tabHandler.ts
var import_state6 = require("@codemirror/state");
function createTabHandler() {
  return {
    key: "Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_SPACE);
      if (listMatch) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        if (selection.from === line.from + markerEnd && selection.to === selection.from) {
          const newIndent = currentIndent + INDENTATION.FOUR_SPACES;
          const newLine = newIndent + marker + space + lineText.substring(markerEnd);
          const changes = {
            from: line.from,
            to: line.to,
            insert: newLine
          };
          const transaction = state.update({
            changes,
            selection: import_state6.EditorSelection.cursor(line.from + newIndent.length + marker.length + space.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      return false;
    }
  };
}
function createShiftTabHandler() {
  return {
    key: "Shift-Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE);
      if (listMatch && listMatch[1].length > 0) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        const newIndent = removeIndentLevel(currentIndent);
        const newLine = newIndent + marker + space + lineText.substring(markerEnd);
        const changes = {
          from: line.from,
          to: line.to,
          insert: newLine
        };
        const oldCursorOffset = selection.from - line.from;
        const indentDiff = currentIndent.length - newIndent.length;
        const newCursorOffset = Math.max(newIndent.length + marker.length + space.length, oldCursorOffset - indentDiff);
        const transaction = state.update({
          changes,
          selection: import_state6.EditorSelection.cursor(line.from + newCursorOffset)
        });
        view.dispatch(transaction);
        return true;
      }
      return false;
    }
  };
}

// src/editor-extensions/listAutocompletion/handlers/shiftHandlers.ts
var import_state7 = require("@codemirror/state");
function createShiftEnterHandler() {
  return {
    key: "Shift-Enter",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      if (isExtendedList(lineText)) {
        const continuationIndent = "   ";
        const insertPos = selection.from;
        const changes = {
          from: insertPos,
          to: insertPos,
          insert: "\n" + continuationIndent
        };
        const transaction = state.update({
          changes,
          selection: import_state7.EditorSelection.cursor(insertPos + 1 + 3)
          // Cursor after 3 spaces
        });
        view.dispatch(transaction);
        return true;
      }
      return false;
    }
  };
}

// src/editor-extensions/listAutocompletion/index.ts
function createListAutocompletionKeymap(settings) {
  return [
    createEnterHandler(settings),
    createShiftEnterHandler(),
    createTabHandler(),
    createShiftTabHandler()
  ];
}

// src/core/main.ts
var PandocExtendedMarkdownPlugin = class extends import_obsidian15.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerViewIcons();
    this.addSettingTab(new PandocExtendedMarkdownSettingTab(this.app, this));
    this.registerExtensions();
    this.registerPostProcessor();
    this.setupModeChangeDetection();
    this.suggester = new ExampleReferenceSuggest(this);
    this.registerEditorSuggest(this.suggester);
    this.customLabelSuggester = new CustomLabelReferenceSuggest(this);
    this.registerEditorSuggest(this.customLabelSuggester);
    this.registerView(
      VIEW_TYPE_LIST_PANEL,
      (leaf) => new ListPanelView(leaf, this)
    );
    this.addRibbonIcon(ICONS.LIST_PANEL_ID, "Open list panel", () => {
      this.activateListPanelView();
    });
    this.registerCommands();
  }
  registerViewIcons() {
    (0, import_obsidian15.addIcon)(ICONS.CUSTOM_LABEL_ID, ICONS.CUSTOM_LABEL_SVG);
    (0, import_obsidian15.addIcon)(ICONS.LIST_PANEL_ID, ICONS.LIST_PANEL_SVG);
  }
  registerExtensions() {
    this.registerEditorExtension(pandocExtendedMarkdownExtension(
      () => this.settings,
      () => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
        return ((_a = activeView == null ? void 0 : activeView.file) == null ? void 0 : _a.path) || null;
      },
      () => this.app,
      () => this
    ));
    this.registerEditorExtension(import_state8.Prec.highest(import_view14.keymap.of(createListAutocompletionKeymap(this.settings))));
  }
  registerPostProcessor() {
    this.registerMarkdownPostProcessor((element, context) => {
      const config = createProcessorConfig(
        { strictLineBreaks: this.app.vault.getConfig("strictLineBreaks") },
        this.settings
      );
      processReadingMode(element, context, config);
    });
  }
  setupModeChangeDetection() {
    const updateStates = () => {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      const hadChanges = pluginStateManager.scanAllLeaves(leaves);
      if (hadChanges) {
        setTimeout(() => {
          this.app.workspace.iterateCodeMirrors((cm) => {
            if (cm.dispatch) {
              cm.dispatch({ effects: [] });
            }
          });
        }, 10);
      }
    };
    updateStates();
    this.registerEvent(this.app.workspace.on("layout-change", updateStates));
    this.registerEvent(this.app.workspace.on("active-leaf-change", updateStates));
    this.registerEvent(this.app.workspace.on("file-open", updateStates));
  }
  registerCommands() {
    this.addCommand({
      id: COMMANDS.CHECK_PANDOC,
      name: "Check pandoc formatting",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const issues = checkPandocFormatting(content, this.settings.moreExtendedSyntax);
        if (issues.length === 0) {
          new import_obsidian15.Notice(MESSAGES.PANDOC_COMPLIANT);
        } else {
          const issueList = issues.map(
            (issue) => `Line ${issue.line}: ${issue.message}`
          ).join("\n");
          new import_obsidian15.Notice(`${MESSAGES.FORMATTING_ISSUES(issues.length)}:
${issueList}`, UI_CONSTANTS.NOTICE_DURATION_MS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.FORMAT_PANDOC,
      name: "Format document to pandoc standard",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const formatted = formatToPandocStandard(content, this.settings.moreExtendedSyntax);
        if (content !== formatted) {
          editor.setValue(formatted);
          new import_obsidian15.Notice(MESSAGES.FORMAT_SUCCESS);
        } else {
          new import_obsidian15.Notice(MESSAGES.FORMAT_ALREADY_COMPLIANT);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_BOLD,
      name: "Toggle definition list bold style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionBoldStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian15.Notice(MESSAGES.TOGGLE_BOLD_SUCCESS);
        } else {
          new import_obsidian15.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_UNDERLINE,
      name: "Toggle definition list underline style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionUnderlineStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian15.Notice(MESSAGES.TOGGLE_UNDERLINE_SUCCESS);
        } else {
          new import_obsidian15.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.OPEN_LIST_PANEL,
      name: "Open list panel",
      callback: () => {
        this.activateListPanelView();
      }
    });
  }
  onunload() {
    pluginStateManager.clearAllStates();
  }
  async activateListPanelView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_LIST_PANEL);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_LIST_PANEL, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isDefinitionTerm(lines, index) {
    if (index + 1 >= lines.length) {
      return false;
    }
    const nextLine = lines[index + 1].trim();
    if (ListPatterns.isDefinitionMarker(nextLine)) {
      return true;
    }
    if (nextLine === "" && index + 2 < lines.length) {
      const lineAfterEmpty = lines[index + 2].trim();
      return ListPatterns.isDefinitionMarker(lineAfterEmpty) !== null;
    }
    return false;
  }
  identifyDefinitionTerms(lines) {
    const definitionTerms = [];
    let anyHasBold = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasBold = ListPatterns.BOLD_TEXT.test(trimmedLine);
        definitionTerms.push({ index: i, hasBold });
        if (hasBold) {
          anyHasBold = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasBold };
  }
  identifyDefinitionTermsWithUnderline(lines) {
    const definitionTerms = [];
    let anyHasUnderline = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasUnderline = ListPatterns.UNDERLINE_SPAN.test(trimmedLine);
        definitionTerms.push({ index: i, hasUnderline });
        if (hasUnderline) {
          anyHasUnderline = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasUnderline };
  }
  toggleDefinitionBoldStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasBold } = this.identifyDefinitionTerms(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasBold) {
        const match = trimmedLine.match(ListPatterns.BOLD_TEXT);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.BOLD_TEXT.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + "**" + trimmedLine + "**";
        }
      }
    }
    return modifiedLines.join("\n");
  }
  toggleDefinitionUnderlineStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasUnderline } = this.identifyDefinitionTermsWithUnderline(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasUnderline) {
        const match = trimmedLine.match(ListPatterns.UNDERLINE_SPAN);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.UNDERLINE_SPAN.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + '<span class="underline">' + trimmedLine + "</span>";
        }
      }
    }
    return modifiedLines.join("\n");
  }
};
var main_default = PandocExtendedMarkdownPlugin;
