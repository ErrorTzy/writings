/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  PandocExtendedMarkdownPlugin: () => PandocExtendedMarkdownPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian9 = require("obsidian");
var import_state3 = require("@codemirror/state");
var import_view11 = require("@codemirror/view");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types/settingsTypes.ts
var DEFAULT_SETTINGS = {
  strictPandocMode: false,
  autoRenumberLists: false,
  moreExtendedSyntax: false
};

// src/settings.ts
var PandocExtendedMarkdownSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Strict Pandoc mode").setDesc("Enable strict pandoc formatting requirements. When enabled, lists must have empty lines before and after them, and capital letter lists require double spacing after markers.").addToggle((toggle) => toggle.setValue(this.plugin.settings.strictPandocMode).onChange(async (value) => {
      this.plugin.settings.strictPandocMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-renumber lists").setDesc("Automatically renumber all list items when inserting a new item. This ensures proper sequential ordering of fancy lists (A, B, C... or i, ii, iii...) when you add items in the middle of a list.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRenumberLists).onChange(async (value) => {
      this.plugin.settings.autoRenumberLists = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("More extended syntax").setDesc("Should use it together with more_extended_syntax.lua to enhance pandoc output. Enables custom label lists using {::LABEL} syntax. When strict pandoc mode is enabled, custom label lists must be preceded and followed by blank lines.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moreExtendedSyntax).onChange(async (value) => {
      this.plugin.settings.moreExtendedSyntax = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types/ProcessorConfig.ts
function createProcessorConfig(vaultConfig, pluginSettings) {
  var _a, _b, _c;
  const moreExtendedSyntax = (_a = pluginSettings.moreExtendedSyntax) != null ? _a : false;
  return {
    strictLineBreaks: (_b = vaultConfig.strictLineBreaks) != null ? _b : false,
    strictPandocMode: (_c = pluginSettings.strictPandocMode) != null ? _c : false,
    moreExtendedSyntax,
    enableHashLists: true,
    enableFancyLists: true,
    enableExampleLists: true,
    enableDefinitionLists: true,
    enableSuperSubscripts: true,
    enableCustomLabelLists: moreExtendedSyntax
  };
}

// src/constants.ts
var INDENTATION = {
  TAB_SIZE: 4,
  MIN_INDENT: 0,
  MAX_INDENT: 40,
  SINGLE_SPACE: 1,
  DOUBLE_SPACE: 2,
  TAB: "	",
  FOUR_SPACES: "    "
};
var CSS_CLASSES = {
  // Fancy List Classes
  FANCY_LIST: "pandoc-list-fancy",
  FANCY_LIST_UPPER_ALPHA: "pandoc-list-upper-alpha",
  FANCY_LIST_LOWER_ALPHA: "pandoc-list-lower-alpha",
  FANCY_LIST_UPPER_ROMAN: "pandoc-list-upper-roman",
  FANCY_LIST_LOWER_ROMAN: "pandoc-list-lower-roman",
  FANCY_LIST_PAREN: "pandoc-list-paren",
  // Definition List Classes
  DEFINITION_LIST: "pandoc-definition-list",
  DEFINITION_TERM: "pandoc-definition-term",
  DEFINITION_DESC: "pandoc-list-definition-desc",
  DEFINITION_ITEMS: "pandoc-definition-items",
  DEFINITION_CONTENT_TEXT: "pandoc-definition-content-text",
  // Example List Classes
  EXAMPLE_REF: "pandoc-example-reference",
  EXAMPLE_LIST: "pandoc-example-list",
  EXAMPLE_ITEM: "pandoc-example-item",
  EXAMPLE_DUPLICATE: "pandoc-example-duplicate",
  // Superscript and Subscript Classes
  SUPERSCRIPT: "pandoc-superscript",
  SUBSCRIPT: "pandoc-subscript",
  // Suggestion Classes
  SUGGESTION_CONTENT: "pandoc-suggestion-content",
  SUGGESTION_TITLE: "pandoc-suggestion-title",
  SUGGESTION_PREVIEW: "pandoc-suggestion-preview",
  // CodeMirror Classes
  LIST_LINE: "HyperMD-list-line",
  LIST_LINE_1: "HyperMD-list-line-1",
  CM_LIST_1: "cm-list-1",
  CM_FORMATTING: "cm-formatting",
  CM_FORMATTING_LIST: "cm-formatting-list",
  CM_FORMATTING_LIST_OL: "cm-formatting-list-ol",
  LIST_NUMBER: "list-number",
  DEFINITION_TERM_DECORATION: "cm-pandoc-definition-term",
  DEFINITION_PARAGRAPH: "cm-pandoc-definition-paragraph",
  // Generic Classes
  PANDOC_LIST_MARKER: "pandoc-list-marker"
};
var DECORATION_STYLES = {
  HASH_LIST_INDENT: 29,
  EXAMPLE_LIST_INDENT: 35,
  FANCY_LIST_INDENT_MULTIPLIER: 7,
  LINE_TRUNCATION_LIMIT: 100,
  TOOLTIP_DELAY_MS: 300
};
var MESSAGES = {
  // Success messages
  FORMAT_SUCCESS: "Document formatted to pandoc standard",
  FORMAT_ALREADY_COMPLIANT: "Document already follows pandoc standard",
  PANDOC_COMPLIANT: "Document follows pandoc formatting standards",
  TOGGLE_BOLD_SUCCESS: "Definition terms bold style toggled",
  TOGGLE_UNDERLINE_SUCCESS: "Definition terms underline style toggled",
  // Error messages
  NO_DEFINITION_TERMS: "No definition terms found to toggle",
  // Formatting issue messages
  FORMATTING_ISSUES: (count) => `Found ${count} formatting issues`
};
var COMMANDS = {
  CHECK_PANDOC: "check-pandoc-formatting",
  FORMAT_PANDOC: "format-to-pandoc-standard",
  TOGGLE_DEFINITION_BOLD: "toggle-definition-bold-style",
  TOGGLE_DEFINITION_UNDERLINE: "toggle-definition-underline-style"
};
var UI_CONSTANTS = {
  NOTICE_DURATION_MS: 1e4
};

// src/patterns.ts
var ListPatterns = class {
  // Note: Patterns are already compiled as static readonly RegExp objects,
  // providing optimal performance without needing additional caching.
  /**
   * Test if a line matches a hash list pattern.
   */
  static isHashList(line) {
    return line.match(this.HASH_LIST);
  }
  /**
   * Test if a line matches a fancy list pattern.
   */
  static isFancyList(line) {
    const match = line.match(this.FANCY_LIST);
    if (match && !line.match(this.NUMBERED_LIST)) {
      return match;
    }
    return null;
  }
  /**
   * Test if a line matches an example list pattern.
   */
  static isExampleList(line) {
    return line.match(this.EXAMPLE_LIST);
  }
  /**
   * Test if a line matches a definition marker pattern.
   */
  static isDefinitionMarker(line) {
    return line.match(this.DEFINITION_MARKER);
  }
  /**
   * Test if a line is indented (for definition list content).
   */
  static isIndentedContent(line) {
    return this.DEFINITION_INDENTED.test(line);
  }
  /**
   * Find all example references in a text.
   */
  static findExampleReferences(text) {
    const matches = [];
    const regex = new RegExp(this.EXAMPLE_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Check if a string is a roman numeral.
   */
  static isRomanNumeral(str) {
    return this.ROMAN_NUMERALS.test(str) || this.LOWER_ROMAN_NUMERALS.test(str);
  }
  /**
   * Check if a line is any type of list item.
   */
  static isListItem(line) {
    return !!(this.isHashList(line) || this.isFancyList(line) || this.isExampleList(line) || this.isDefinitionMarker(line) || line.match(this.UNORDERED_LIST) || line.match(this.NUMBERED_LIST));
  }
  /**
   * Find all superscripts in a text.
   */
  static findSuperscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUPERSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Find all subscripts in a text.
   */
  static findSubscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUBSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line matches a custom label list pattern.
   */
  static isCustomLabelList(line) {
    return line.match(this.CUSTOM_LABEL_LIST);
  }
  /**
   * Test if a label is valid for custom label lists.
   */
  static isValidCustomLabel(label) {
    return this.VALID_CUSTOM_LABEL.test(label);
  }
  /**
   * Find all custom label references in a text.
   */
  static findCustomLabelReferences(text) {
    const matches = [];
    const regex = new RegExp(this.CUSTOM_LABEL_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line is a heading.
   */
  static isHeading(line) {
    return this.HEADING.test(line);
  }
  /**
   * Test if text might be a definition term (not a marker or indented).
   */
  static isDefinitionTerm(line) {
    const trimmed = line.trim();
    return trimmed !== "" && !this.isDefinitionMarker(trimmed) && !this.isIndentedContent(line);
  }
  /**
   * Extract letter and delimiter from a fancy list marker.
   */
  static extractLetterMarker(marker) {
    return marker.match(/^([A-Za-z]+)([.)])$/);
  }
  /**
   * Extract roman numeral and delimiter from a fancy list marker.
   */
  static extractRomanMarker(marker) {
    return marker.match(/^([ivxlcdmIVXLCDM]+)([.)])$/);
  }
  /**
   * Check if text starts with a formatting marker.
   */
  static startsWithFormatting(text) {
    return /^(\*\*|__|\*|_|`)/.test(text);
  }
  /**
   * Get indent from a line.
   */
  static getIndent(line) {
    const match = line.match(this.INDENT_ONLY);
    return match ? match[1] : "";
  }
  /**
   * Replace escaped spaces with regular spaces.
   */
  static unescapeSpaces(text) {
    return text.replace(this.ESCAPED_SPACE, " ");
  }
  /**
   * Find all example reference starts in text.
   */
  static findExampleRefStarts(text) {
    return [...text.matchAll(this.EXAMPLE_REF_START)];
  }
  /**
   * Find all custom label reference starts in text.
   */
  static findCustomLabelRefStarts(text) {
    return [...text.matchAll(this.CUSTOM_LABEL_REF_START)];
  }
  /**
   * Split text by inline formatting markers.
   */
  static splitByInlineFormatting(text) {
    return text.split(this.INLINE_FORMATTING_SPLIT);
  }
};
// Base patterns as static readonly properties
ListPatterns.HASH_LIST = /^(\s*)(#\.)(\s+)/;
ListPatterns.FANCY_LIST = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/;
ListPatterns.EXAMPLE_LIST = /^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/;
ListPatterns.EXAMPLE_LIST_WITH_CONTENT = /^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/;
ListPatterns.EXAMPLE_REFERENCE = /\(@([a-zA-Z0-9_-]+)\)/g;
ListPatterns.DEFINITION_MARKER = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_MARKER_WITH_INDENT = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_INDENTED = /^(    |\t)/;
ListPatterns.DEFINITION_INDENTED_WITH_CONTENT = /^(    |\t)(.*)$/;
ListPatterns.DEFINITION_TERM_PATTERN = /^([^\n:~]+)$/;
ListPatterns.NUMBERED_LIST = /^(\s*)([0-9]+[.)])/;
ListPatterns.UNORDERED_LIST = /^(\s*)[-*+]\s+/;
ListPatterns.CAPITAL_LETTER_LIST = /^(\s*)([A-Z])(\.)(\s+)/;
// Additional list patterns for validation
ListPatterns.STANDARD_ORDERED_LIST = /^(\s*)\d+\.\s+/;
ListPatterns.CAPITAL_LETTER_REPLACE = /^(\s*)([A-Z]\.)(\s+)/;
ListPatterns.UNLABELED_EXAMPLE_LIST = /^(\s*)\(@\)\s+/;
// Combined fancy list pattern for validation (includes numbers)
ListPatterns.FANCY_LIST_WITH_NUMBERS = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|[0-9]+|#)([.)]))(\s+)/;
ListPatterns.ROMAN_NUMERALS = /^[IVXLCDM]+$/;
ListPatterns.LOWER_ROMAN_NUMERALS = /^[ivxlcdm]+$/;
// Character type patterns for fancy list parsing
ListPatterns.ROMAN_UPPER = /^[IVXLCDM]+$/;
ListPatterns.ROMAN_LOWER = /^[ivxlcdm]+$/;
ListPatterns.ALPHA_UPPER = /^[A-Z]+$/;
ListPatterns.ALPHA_LOWER = /^[a-z]+$/;
ListPatterns.DECIMAL = /^[0-9]+$/;
// Autocompletion patterns
ListPatterns.LETTER_OR_ROMAN_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)(.*)$/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)(.*)$/;
ListPatterns.VALID_ROMAN_NUMERAL = /^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i;
ListPatterns.SINGLE_I = /^[Ii]$/;
ListPatterns.SINGLE_H = /^[Hh]$/;
ListPatterns.SINGLE_AB = /^[ABab]$/;
ListPatterns.SINGLE_ROMAN_CHAR = /^[IVXLCDM]$/i;
ListPatterns.ANY_ROMAN_CHARS = /^[ivxlcdmIVXLCDM]+$/i;
ListPatterns.ALPHABETIC_CHARS = /^[A-Za-z]+$/;
ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)/;
ListPatterns.NUMBERED_LIST_WITH_SPACE = /^\s*\d+[.)]\s/;
ListPatterns.DEFINITION_MARKER_ONLY = /^[~:]$/;
// Empty list item patterns
ListPatterns.EMPTY_HASH_LIST = /^(\s*)(#\.)(\s*)$/;
ListPatterns.EMPTY_FANCY_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL = /^(\s*)\(@\)(\s*)$/;
ListPatterns.EMPTY_DEFINITION_LIST = /^(\s*)([~:])(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST = /^(\s*)(\{::([a-zA-Z][a-zA-Z0-9_']*)*\})(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL = /^(\s*)(\{::\})(\s*)$/;
// Complex list patterns for autocompletion
ListPatterns.ANY_LIST_MARKER = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})/;
ListPatterns.ANY_LIST_MARKER_WITH_SPACE = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE = /^(\s+)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
// Indentation patterns
ListPatterns.INDENT_ONLY = /^(\s*)/;
// Text formatting patterns
ListPatterns.BOLD_TEXT = /^\*\*(.+)\*\*$/;
ListPatterns.UNDERLINE_SPAN = /^<span class="underline">(.+)<\/span>$/;
// Inline formatting patterns for parsing
ListPatterns.INLINE_FORMATTING_SPLIT = /(__(.+?)__|\*\*(.+?)\*\*|_(.+?)_|\*(.+?)\*|`(.+?)`)/g;
// Escaped space pattern
ListPatterns.ESCAPED_SPACE = /\\[ ]/g;
// Example reference start pattern (for autocomplete)
ListPatterns.EXAMPLE_REF_START = /\(@/g;
// Custom label reference start pattern (for autocomplete)
ListPatterns.CUSTOM_LABEL_REF_START = /\{::/g;
// Heading patterns
ListPatterns.HEADING = /^#{1,6}\s+/;
ListPatterns.HEADING_WITH_CONTENT = /^(#{1,6})\s+(.*)$/;
// Superscript and subscript patterns
// Matches ^text^ for superscript and ~text~ for subscript
// Text can contain escaped spaces (\ ) but not unescaped spaces
ListPatterns.SUPERSCRIPT = /\^([^\^\s]|\\[ ])+?\^/g;
ListPatterns.SUBSCRIPT = /~([^~\s]|\\[ ])+?~/g;
// Custom label list patterns for More Extended Syntax
// Matches {::LABEL} at start of line with required space after
ListPatterns.CUSTOM_LABEL_LIST = /^(\s*)(\{::([a-zA-Z][a-zA-Z0-9_']*)\})(\s+)/;
ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT = /^(\s*)(\{::([a-zA-Z][a-zA-Z0-9_']*)\})(\s+)(.*)$/;
// Reference to custom label anywhere in text
ListPatterns.CUSTOM_LABEL_REFERENCE = /\{::([a-zA-Z][a-zA-Z0-9_']*)\}/g;
// Valid label pattern (for validation)
ListPatterns.VALID_CUSTOM_LABEL = /^[a-zA-Z][a-zA-Z0-9_']*$/;

// src/decorations/pandocExtendedMarkdownExtension.ts
var import_state = require("@codemirror/state");
var import_view10 = require("@codemirror/view");
var import_obsidian4 = require("obsidian");

// src/decorations/validators/listBlockValidator.ts
var ListBlockValidator = class {
  static isListItemForValidation(line) {
    return !!(ListPatterns.isHashList(line) || // Hash auto-numbering
    ListPatterns.isFancyList(line) || // Fancy lists
    ListPatterns.isExampleList(line) || // Example lists
    ListPatterns.isDefinitionMarker(line) || // Definition lists
    line.match(ListPatterns.UNORDERED_LIST) || // Unordered lists
    line.match(ListPatterns.NUMBERED_LIST));
  }
  static validateListBlocks(lines, settings) {
    const invalidListBlocks = /* @__PURE__ */ new Set();
    if (!settings.strictPandocMode) {
      return invalidListBlocks;
    }
    let listBlockStart = -1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isCurrentList = this.isListItemForValidation(line);
      const prevIsListOrEmpty = i > 0 && (this.isListItemForValidation(lines[i - 1]) || lines[i - 1].trim() === "");
      const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && !ListPatterns.isDefinitionMarker(lines[i - 1]) && !ListPatterns.isIndentedContent(lines[i - 1]) && ListPatterns.isDefinitionMarker(line);
      if (isCurrentList && listBlockStart === -1) {
        listBlockStart = i;
        if (i > 0 && lines[i - 1].trim() !== "" && !prevIsDefinitionTerm) {
          for (let j = i; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
            invalidListBlocks.add(j);
          }
        }
      } else if (!isCurrentList && listBlockStart !== -1) {
        if (line.trim() !== "") {
          for (let j = listBlockStart; j < i; j++) {
            invalidListBlocks.add(j);
          }
        }
        listBlockStart = -1;
      }
      if (isCurrentList) {
        const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
        if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
          for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
            invalidListBlocks.add(j);
          }
          for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
            invalidListBlocks.add(j);
          }
        }
      }
    }
    return invalidListBlocks;
  }
};

// src/decorations/scanners/exampleScanner.ts
function scanExampleLabels(view, settings) {
  const result = {
    exampleLabels: /* @__PURE__ */ new Map(),
    exampleContent: /* @__PURE__ */ new Map(),
    exampleLineNumbers: /* @__PURE__ */ new Map(),
    duplicateLabels: /* @__PURE__ */ new Map(),
    duplicateLabelContent: /* @__PURE__ */ new Map()
  };
  let counter = 1;
  const docText = view.state.doc.toString();
  const lines = docText.split("\n");
  const invalidListBlocks = settings.strictPandocMode ? ListBlockValidator.validateListBlocks(lines, settings) : /* @__PURE__ */ new Set();
  for (let i = 0; i < lines.length; i++) {
    if (settings.strictPandocMode && invalidListBlocks.has(i)) {
      continue;
    }
    const line = lines[i];
    const match = line.match(ListPatterns.EXAMPLE_LIST_WITH_CONTENT);
    if (match) {
      const label = match[2];
      const content = match[3].trim();
      if (!result.exampleLabels.has(label)) {
        result.exampleLabels.set(label, counter);
        if (content) {
          result.exampleContent.set(label, content);
        }
        result.duplicateLabels.set(label, i + 1);
        result.duplicateLabelContent.set(label, line);
      }
      result.exampleLineNumbers.set(i + 1, counter);
      counter++;
    } else {
      const unlabeledMatch = line.match(ListPatterns.UNLABELED_EXAMPLE_LIST);
      if (unlabeledMatch) {
        result.exampleLineNumbers.set(i + 1, counter);
        counter++;
      }
    }
  }
  return result;
}

// src/decorations/scanners/customLabelScanner.ts
function scanCustomLabels(doc, settings) {
  const customLabels = /* @__PURE__ */ new Map();
  const duplicateLabels = /* @__PURE__ */ new Set();
  const seenLabels = /* @__PURE__ */ new Set();
  if (!settings.moreExtendedSyntax) {
    return { customLabels, duplicateLabels };
  }
  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i);
    const lineText = line.text;
    const match = ListPatterns.isCustomLabelList(lineText);
    if (match) {
      const label = match[3];
      if (seenLabels.has(label)) {
        duplicateLabels.add(label);
      } else {
        seenLabels.add(label);
        const contentStart = match[0].length;
        const content = lineText.substring(contentStart).trim();
        if (content) {
          customLabels.set(label, content);
        }
      }
    }
  }
  return { customLabels, duplicateLabels };
}
function validateCustomLabelBlocks(doc, settings) {
  const invalidLines = /* @__PURE__ */ new Set();
  if (!settings.moreExtendedSyntax || !settings.strictPandocMode) {
    return invalidLines;
  }
  const blocks = [];
  let inBlock = false;
  let blockStart = -1;
  let blockValid = true;
  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i);
    const lineText = line.text;
    const isCustomLabel = ListPatterns.isCustomLabelList(lineText);
    if (isCustomLabel) {
      if (!inBlock) {
        inBlock = true;
        blockStart = i;
        blockValid = true;
        if (i > 1) {
          const prevLine = doc.line(i - 1);
          if (prevLine.text.trim() !== "") {
            blockValid = false;
          }
        }
      }
    } else if (inBlock) {
      const blockEnd = i - 1;
      if (line.text.trim() !== "") {
        blockValid = false;
      }
      blocks.push({ start: blockStart, end: blockEnd, valid: blockValid });
      inBlock = false;
    }
  }
  if (inBlock) {
    blocks.push({ start: blockStart, end: doc.lines, valid: blockValid });
  }
  for (const block of blocks) {
    if (!block.valid) {
      for (let i = block.start; i <= block.end; i++) {
        invalidLines.add(i - 1);
      }
    }
  }
  return invalidLines;
}

// src/decorations/processors/listProcessors.ts
var import_view5 = require("@codemirror/view");

// src/decorations/widgets/listWidgets.ts
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type, view, pos) {
    super();
    this.marker = marker;
    this.type = type;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = this.marker + " ";
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.marker === this.marker && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, view, pos) {
    super();
    this.number = number;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `${this.number}. `;
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, label, view, pos) {
    super();
    this.number = number;
    this.label = label;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER} ${CSS_CLASSES.EXAMPLE_REF}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.number}) `;
    span.appendChild(innerSpan);
    const tooltipText = this.label ? `@${this.label}` : "@";
    (0, import_obsidian2.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.label === this.label && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var DuplicateExampleLabelWidget = class extends import_view.WidgetType {
  constructor(label, originalLine, originalLineContent, view, pos) {
    super();
    this.label = label;
    this.originalLine = originalLine;
    this.originalLineContent = originalLineContent;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_DUPLICATE;
    span.textContent = `(@${this.label})`;
    let lineContent = this.originalLineContent.trim();
    if (lineContent.length > DECORATION_STYLES.LINE_TRUNCATION_LIMIT) {
      lineContent = lineContent.substring(0, DECORATION_STYLES.LINE_TRUNCATION_LIMIT) + "...";
    }
    const tooltipText = `Duplicate index at line ${this.originalLine}: ${lineContent}`;
    (0, import_obsidian2.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.originalLine === this.originalLine && other.originalLineContent === this.originalLineContent && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};

// src/decorations/widgets/definitionWidget.ts
var import_view2 = require("@codemirror/view");
var DefinitionBulletWidget = class extends import_view2.WidgetType {
  constructor(view, pos) {
    super();
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-list-1 pandoc-list-marker";
    span.textContent = "\u2022 ";
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};

// src/decorations/widgets/referenceWidget.ts
var import_view3 = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var ExampleReferenceWidget = class extends import_view3.WidgetType {
  constructor(number, tooltipText) {
    super();
    this.number = number;
    this.tooltipText = tooltipText;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_REF;
    span.textContent = `(${this.number})`;
    if (this.tooltipText) {
      (0, import_obsidian3.setTooltip)(span, this.tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    }
    return span;
  }
  // Make the widget editable - allow all editing events to pass through
  ignoreEvent() {
    return false;
  }
  eq(other) {
    return other.number === this.number && other.tooltipText === this.tooltipText;
  }
};

// src/decorations/widgets/formatWidgets.ts
var import_view4 = require("@codemirror/view");
var SuperscriptWidget = class extends import_view4.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sup = document.createElement("sup");
    sup.className = CSS_CLASSES.SUPERSCRIPT;
    sup.textContent = this.content;
    return sup;
  }
  eq(other) {
    return other.content === this.content;
  }
  ignoreEvent() {
    return false;
  }
};
var SubscriptWidget = class extends import_view4.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sub = document.createElement("sub");
    sub.className = CSS_CLASSES.SUBSCRIPT;
    sub.textContent = this.content;
    return sub;
  }
  eq(other) {
    return other.content === this.content;
  }
  ignoreEvent() {
    return false;
  }
};

// src/decorations/processors/listProcessors.ts
function processHashList(context, hashCounter) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const hashMatch = ListPatterns.isHashList(lineText);
  if (!hashMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = hashMatch[1];
  const marker = hashMatch[2];
  const space = hashMatch[3];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view5.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view5.Decoration.replace({
        widget: new HashListMarkerWidget(hashCounter.value, view, markerStart)
      })
    });
  }
  decorations.push({
    from: line.from + indent.length + marker.length + space.length,
    to: line.to,
    decoration: import_view5.Decoration.mark({
      class: "cm-list-1"
    })
  });
  hashCounter.value++;
  return decorations;
}
function processFancyList(context) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const fancyMatch = ListPatterns.isFancyList(lineText);
  if (!fancyMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = fancyMatch[1];
  const marker = fancyMatch[2];
  const space = fancyMatch[5];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  let listClass = CSS_CLASSES.FANCY_LIST_UPPER_ALPHA;
  const letterMatch = ListPatterns.extractLetterMarker(marker);
  const romanMatch = ListPatterns.extractRomanMarker(marker);
  if (letterMatch) {
    const letter = letterMatch[1];
    if (letter[0] === letter[0].toLowerCase()) {
      listClass = CSS_CLASSES.FANCY_LIST_LOWER_ALPHA;
    }
  } else if (romanMatch) {
    const roman = romanMatch[1];
    if (roman[0] === roman[0].toLowerCase()) {
      listClass = CSS_CLASSES.FANCY_LIST_LOWER_ROMAN;
    } else {
      listClass = CSS_CLASSES.FANCY_LIST_UPPER_ROMAN;
    }
  }
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view5.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view5.Decoration.replace({
        widget: new FancyListMarkerWidget(marker, listClass, view, markerStart)
      })
    });
  }
  decorations.push({
    from: line.from + indent.length + marker.length + space.length,
    to: line.to,
    decoration: import_view5.Decoration.mark({
      class: "cm-list-1"
    })
  });
  return decorations;
}
function processExampleList(context) {
  const {
    line,
    lineNum,
    lineText,
    cursorPos,
    view,
    invalidListBlocks,
    settings,
    exampleLabels,
    exampleLineNumbers,
    duplicateLabels,
    duplicateLabelContent
  } = context;
  const decorations = [];
  const exampleMatch = ListPatterns.isExampleList(lineText);
  if (!exampleMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = exampleMatch[1];
  const fullMarker = exampleMatch[2];
  const label = exampleMatch[3] || "";
  const space = exampleMatch[4];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + fullMarker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  const exampleNumber = (exampleLineNumbers == null ? void 0 : exampleLineNumbers.get(lineNum)) || 1;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view5.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  const isDuplicate = label && (duplicateLabels == null ? void 0 : duplicateLabels.has(label)) && duplicateLabels.get(label) !== lineNum;
  if (!cursorInMarker) {
    if (isDuplicate && duplicateLabels && duplicateLabelContent) {
      const originalLine = duplicateLabels.get(label);
      const originalContent = duplicateLabelContent.get(label);
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view5.Decoration.replace({
          widget: new DuplicateExampleLabelWidget(label, originalLine, originalContent, view, markerStart)
        })
      });
    } else {
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view5.Decoration.replace({
          widget: new ExampleListMarkerWidget(exampleNumber, label || void 0, view, markerStart)
        })
      });
    }
  }
  decorations.push({
    from: line.from + indent.length + fullMarker.length + space.length,
    to: line.to,
    decoration: import_view5.Decoration.mark({
      class: CSS_CLASSES.EXAMPLE_ITEM
    })
  });
  return decorations;
}

// src/decorations/processors/definitionProcessor.ts
var import_view6 = require("@codemirror/view");
function processDefinitionItem(context) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const defItemMatch = ListPatterns.isDefinitionMarker(lineText);
  if (!defItemMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = defItemMatch[1];
  const marker = defItemMatch[2];
  const space = defItemMatch[3];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view6.Decoration.replace({
        widget: new DefinitionBulletWidget(view, markerStart)
      })
    });
  }
  return decorations;
}
function processDefinitionTerm(context) {
  const { line, lineText, view } = context;
  const decorations = [];
  if (!lineText.trim() || ListPatterns.isDefinitionMarker(lineText) || ListPatterns.isIndentedContent(lineText)) {
    return null;
  }
  let isDefinitionTerm = false;
  if (line.number < view.state.doc.lines) {
    const nextLine = view.state.doc.line(line.number + 1);
    const nextText = nextLine.text;
    if (ListPatterns.isDefinitionMarker(nextText)) {
      isDefinitionTerm = true;
    } else if (nextText.trim() === "" && line.number + 1 < view.state.doc.lines) {
      const lineAfterEmpty = view.state.doc.line(line.number + 2);
      if (ListPatterns.isDefinitionMarker(lineAfterEmpty.text)) {
        isDefinitionTerm = true;
      }
    }
  }
  if (isDefinitionTerm) {
    decorations.push({
      from: line.from,
      to: line.to,
      decoration: import_view6.Decoration.mark({
        class: "cm-strong cm-pandoc-definition-term"
      })
    });
    return decorations;
  }
  return null;
}
function processDefinitionParagraph(context) {
  const { line, lineNum, lineText, view } = context;
  const decorations = [];
  const indentMatch = ListPatterns.isIndentedContent(lineText) ? lineText.match(ListPatterns.DEFINITION_INDENTED_WITH_CONTENT) : null;
  if (!indentMatch) return null;
  let inDefinitionContext = false;
  for (let checkLine = lineNum - 1; checkLine >= 1; checkLine--) {
    const prevLine = view.state.doc.line(checkLine);
    const prevText = prevLine.text;
    if (ListPatterns.isDefinitionMarker(prevText)) {
      inDefinitionContext = true;
      break;
    }
    if (prevText.trim() && !ListPatterns.isIndentedContent(prevText) && !ListPatterns.isDefinitionMarker(prevText)) {
      break;
    }
  }
  if (!inDefinitionContext) return null;
  const content = indentMatch[2];
  if (content && content.trim()) {
    decorations.push({
      from: line.from,
      to: line.from,
      decoration: import_view6.Decoration.line({
        class: "cm-pandoc-definition-paragraph",
        attributes: {
          "data-definition-content": "true"
        }
      })
    });
    decorations.push({
      from: line.from,
      to: line.to,
      decoration: import_view6.Decoration.mark({
        class: CSS_CLASSES.DEFINITION_CONTENT_TEXT
      })
    });
  }
  return decorations;
}

// src/decorations/processors/inlineFormatProcessor.ts
var import_view7 = require("@codemirror/view");
function processExampleReferences(context) {
  const { line, lineText, cursorPos, exampleLabels, exampleContent } = context;
  const decorations = [];
  if (!exampleLabels) return decorations;
  const refRegex = ListPatterns.EXAMPLE_REFERENCE;
  let match;
  while ((match = refRegex.exec(lineText)) !== null) {
    const label = match[1];
    if (exampleLabels.has(label)) {
      const refStart = line.from + match.index;
      const refEnd = line.from + match.index + match[0].length;
      const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
      if (!cursorInRef) {
        const number = exampleLabels.get(label);
        const tooltipText = exampleContent == null ? void 0 : exampleContent.get(label);
        decorations.push({
          from: refStart,
          to: refEnd,
          decoration: import_view7.Decoration.replace({
            widget: new ExampleReferenceWidget(number, tooltipText),
            inclusive: false
          })
        });
      }
    }
  }
  return decorations;
}
function processSuperscripts(context) {
  const { line, lineText, cursorPos } = context;
  const decorations = [];
  const superscripts = ListPatterns.findSuperscripts(lineText);
  for (const supMatch of superscripts) {
    const supStart = line.from + supMatch.index;
    const supEnd = line.from + supMatch.index + supMatch[0].length;
    const cursorInSup = cursorPos >= supStart && cursorPos <= supEnd;
    if (!cursorInSup) {
      const content = ListPatterns.unescapeSpaces(supMatch[0].slice(1, -1));
      decorations.push({
        from: supStart,
        to: supEnd,
        decoration: import_view7.Decoration.replace({
          widget: new SuperscriptWidget(content)
        })
      });
    }
  }
  return decorations;
}
function processSubscripts(context) {
  const { line, lineText, cursorPos } = context;
  const decorations = [];
  const subscripts = ListPatterns.findSubscripts(lineText);
  for (const subMatch of subscripts) {
    const subStart = line.from + subMatch.index;
    const subEnd = line.from + subMatch.index + subMatch[0].length;
    const cursorInSub = cursorPos >= subStart && cursorPos <= subEnd;
    if (!cursorInSub) {
      const content = ListPatterns.unescapeSpaces(subMatch[0].slice(1, -1));
      decorations.push({
        from: subStart,
        to: subEnd,
        decoration: import_view7.Decoration.replace({
          widget: new SubscriptWidget(content)
        })
      });
    }
  }
  return decorations;
}

// src/decorations/processors/customLabelProcessor.ts
var import_view9 = require("@codemirror/view");

// src/decorations/widgets/customLabelWidget.ts
var import_view8 = require("@codemirror/view");
var CustomLabelMarkerWidget = class extends import_view8.WidgetType {
  constructor(label, view, position) {
    super();
    this.label = label;
    this.view = view;
    this.position = position;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.label}) `;
    span.appendChild(innerSpan);
    if (this.view && this.position !== void 0) {
      span.classList.add("pandoc-custom-label-ref-clickable");
      span.addEventListener("click", () => {
        if (this.view && this.position !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.position }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.position === this.position;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var CustomLabelReferenceWidget = class extends import_view8.WidgetType {
  constructor(label, content, view, position) {
    super();
    this.label = label;
    this.content = content;
    this.view = view;
    this.position = position;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_REF;
    span.setAttribute("data-custom-label-ref", this.label);
    span.textContent = `(${this.label})`;
    if (this.content) {
      span.setAttribute("title", this.content);
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.content === this.content && other.position === this.position;
  }
  ignoreEvent() {
    return false;
  }
};

// src/decorations/processors/customLabelProcessor.ts
function processCustomLabelList(context) {
  const {
    line,
    lineNum,
    lineText,
    cursorPos,
    view,
    invalidListBlocks,
    settings,
    customLabels
  } = context;
  if (!settings.moreExtendedSyntax) {
    return null;
  }
  const decorations = [];
  const customLabelMatch = ListPatterns.isCustomLabelList(lineText);
  if (!customLabelMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = customLabelMatch[1];
  const fullMarker = customLabelMatch[2];
  const label = customLabelMatch[3];
  const space = customLabelMatch[4];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + fullMarker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view9.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line-indent"
    })
  });
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view9.Decoration.replace({
        widget: new CustomLabelMarkerWidget(label, view, markerStart)
      })
    });
  }
  decorations.push({
    from: line.from + indent.length + fullMarker.length + space.length,
    to: line.to,
    decoration: import_view9.Decoration.mark({
      class: "cm-list-1 pandoc-custom-label-item"
    })
  });
  if (customLabels) {
    const contentStart = indent.length + fullMarker.length + space.length;
    const content = lineText.substring(contentStart).trim();
    if (content) {
      customLabels.set(label, content);
    }
  }
  return decorations;
}
function processCustomLabelReferences(text, from, customLabels, view, cursorPos, settings, isValidLine = true) {
  const decorations = [];
  if (!settings.moreExtendedSyntax) {
    return decorations;
  }
  if (!isValidLine && ListPatterns.isCustomLabelList(text)) {
    return decorations;
  }
  const matches = ListPatterns.findCustomLabelReferences(text);
  matches.forEach((match) => {
    const label = match[1];
    const content = customLabels.get(label);
    const matchStart = from + (match.index || 0);
    const matchEnd = matchStart + match[0].length;
    const cursorInReference = cursorPos >= matchStart && cursorPos < matchEnd;
    if (!cursorInReference && customLabels.has(label)) {
      decorations.push({
        from: matchStart,
        to: matchEnd,
        decoration: import_view9.Decoration.replace({
          widget: new CustomLabelReferenceWidget(label, content, view, matchStart)
        })
      });
    }
  });
  return decorations;
}

// src/decorations/pandocExtendedMarkdownExtension.ts
var pandocExtendedMarkdownPlugin = (getSettings) => import_view10.ViewPlugin.fromClass(
  class PandocExtendedMarkdownView {
    constructor(view) {
      const settings = getSettings();
      this.scanResult = scanExampleLabels(view, settings);
      this.customLabelScanResult = scanCustomLabels(view.state.doc, settings);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      const prevLivePreview = update.startState.field(import_obsidian4.editorLivePreviewField);
      const currLivePreview = update.state.field(import_obsidian4.editorLivePreviewField);
      const livePreviewChanged = prevLivePreview !== currLivePreview;
      if (update.docChanged || update.viewportChanged || update.selectionSet || livePreviewChanged) {
        if (update.docChanged) {
          const settings = getSettings();
          this.scanResult = scanExampleLabels(update.view, settings);
          this.customLabelScanResult = scanCustomLabels(update.view.state.doc, settings);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const isLivePreview = view.state.field(import_obsidian4.editorLivePreviewField);
      if (!isLivePreview) {
        return builder.finish();
      }
      const settings = getSettings();
      const lines = view.state.doc.toString().split("\n");
      const selection = view.state.selection.main;
      const cursorPos = selection.head;
      const decorations = [];
      const hashCounter = { value: 1 };
      const invalidListBlocks = ListBlockValidator.validateListBlocks(lines, settings);
      const invalidCustomLabelBlocks = validateCustomLabelBlocks(view.state.doc, settings);
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        const lineText = line.text;
        const processorContext = {
          line,
          lineNum,
          lineText,
          cursorPos,
          view,
          invalidListBlocks,
          settings,
          exampleLabels: this.scanResult.exampleLabels,
          exampleLineNumbers: this.scanResult.exampleLineNumbers,
          duplicateLabels: this.scanResult.duplicateLabels,
          duplicateLabelContent: this.scanResult.duplicateLabelContent
        };
        const hashDecorations = processHashList(processorContext, hashCounter);
        if (hashDecorations) {
          decorations.push(...hashDecorations);
          continue;
        }
        const fancyDecorations = processFancyList(processorContext);
        if (fancyDecorations) {
          decorations.push(...fancyDecorations);
          continue;
        }
        const exampleDecorations = processExampleList(processorContext);
        if (exampleDecorations) {
          decorations.push(...exampleDecorations);
          continue;
        }
        if (settings.moreExtendedSyntax) {
          const customLabelContext = {
            line,
            lineNum,
            lineText,
            cursorPos,
            view,
            invalidListBlocks: invalidCustomLabelBlocks,
            settings,
            customLabels: this.customLabelScanResult.customLabels
          };
          const customLabelDecorations = processCustomLabelList(customLabelContext);
          if (customLabelDecorations) {
            decorations.push(...customLabelDecorations);
            continue;
          }
        }
        const definitionContext = {
          line,
          lineNum,
          lineText,
          cursorPos,
          view,
          invalidListBlocks,
          settings,
          lines
        };
        const defItemDecorations = processDefinitionItem(definitionContext);
        if (defItemDecorations) {
          decorations.push(...defItemDecorations);
        }
        const defParagraphDecorations = processDefinitionParagraph(definitionContext);
        if (defParagraphDecorations) {
          decorations.push(...defParagraphDecorations);
          continue;
        }
        const defTermDecorations = processDefinitionTerm(definitionContext);
        if (defTermDecorations) {
          decorations.push(...defTermDecorations);
        }
        const inlineContext = {
          line,
          lineText,
          cursorPos,
          exampleLabels: this.scanResult.exampleLabels,
          exampleContent: this.scanResult.exampleContent
        };
        decorations.push(...processExampleReferences(inlineContext));
        decorations.push(...processSuperscripts(inlineContext));
        decorations.push(...processSubscripts(inlineContext));
        if (settings.moreExtendedSyntax) {
          const isValidLine = !invalidCustomLabelBlocks.has(lineNum - 1);
          const customLabelRefs = processCustomLabelReferences(
            lineText,
            line.from,
            this.customLabelScanResult.customLabels,
            view,
            cursorPos,
            settings,
            isValidLine
          );
          decorations.push(...customLabelRefs);
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocExtendedMarkdownExtension(getSettings) {
  return pandocExtendedMarkdownPlugin(getSettings);
}

// src/types/obsidian-extended.ts
function isMarkdownPreviewSection(element) {
  return element !== null && element.classList.contains("markdown-preview-section");
}
function getSectionInfo(element) {
  if (!isMarkdownPreviewSection(element)) {
    return null;
  }
  if (typeof element.getSection === "function") {
    try {
      return element.getSection();
    } catch (error) {
      return null;
    }
  }
  return null;
}

// src/parsers/fancyListParser.ts
function parseFancyListMarker(line) {
  const hashMatch = ListPatterns.isHashList(line);
  if (hashMatch) {
    return {
      indent: hashMatch[1],
      marker: hashMatch[2],
      type: "hash",
      delimiter: ".",
      value: void 0
    };
  }
  const match = ListPatterns.isFancyList(line);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (ListPatterns.DECIMAL.test(value)) {
    return null;
  } else if (ListPatterns.ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ListPatterns.ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ListPatterns.ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ListPatterns.ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
var import_obsidian5 = require("obsidian");
function parseExampleListMarker(line) {
  const match = ListPatterns.isExampleList(line);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3] || void 0
  };
}

// src/parsers/superSubParser.ts
function extractContent(match, delimiter) {
  const content = match.slice(1, -1);
  return ListPatterns.unescapeSpaces(content);
}
function findSuperSubInText(text) {
  const matches = [];
  const superscripts = ListPatterns.findSuperscripts(text);
  superscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "^"),
        type: "superscript"
      });
    }
  });
  const subscripts = ListPatterns.findSubscripts(text);
  subscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "~"),
        type: "subscript"
      });
    }
  });
  matches.sort((a, b) => a.index - b.index);
  return matches;
}
function processSuperSub(element) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (parent && (parent.classList.contains(CSS_CLASSES.SUPERSCRIPT) || parent.classList.contains(CSS_CLASSES.SUBSCRIPT))) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );
  const nodesToReplace = [];
  while (walker.nextNode()) {
    const node = walker.currentNode;
    const text = node.textContent || "";
    const matches = findSuperSubInText(text);
    if (matches.length > 0) {
      nodesToReplace.push({ node, matches });
    }
  }
  nodesToReplace.forEach(({ node, matches }) => {
    const parent = node.parentNode;
    if (!parent) return;
    let lastIndex = 0;
    const fragments = [];
    matches.forEach((match) => {
      if (match.index > lastIndex) {
        fragments.push(node.textContent.substring(lastIndex, match.index));
      }
      const elem = match.type === "superscript" ? document.createElement("sup") : document.createElement("sub");
      elem.className = match.type === "superscript" ? CSS_CLASSES.SUPERSCRIPT : CSS_CLASSES.SUBSCRIPT;
      elem.textContent = match.content;
      fragments.push(elem);
      lastIndex = match.index + match.length;
    });
    if (lastIndex < node.textContent.length) {
      fragments.push(node.textContent.substring(lastIndex));
    }
    fragments.forEach((fragment) => {
      if (typeof fragment === "string") {
        parent.insertBefore(document.createTextNode(fragment), node);
      } else {
        parent.insertBefore(fragment, node);
      }
    });
    parent.removeChild(node);
  });
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(ListPatterns.DEFINITION_TERM_PATTERN);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(ListPatterns.NUMBERED_LIST)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = ListPatterns.isDefinitionMarker(line);
  if (defMatch) {
    const content = line.substring(defMatch[0].length);
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content
    };
  }
  return null;
}

// src/parsers/ReadingModeParser.ts
var ReadingModeParser = class {
  /**
   * Parse a single line and identify its type and data
   */
  parseLine(line, context) {
    const hashMatch = ListPatterns.isHashList(line);
    if (hashMatch) {
      return {
        type: "hash",
        content: line,
        metadata: {
          indent: hashMatch[1],
          marker: hashMatch[2],
          spacing: hashMatch[3],
          content: line.substring(hashMatch[1].length + hashMatch[2].length + hashMatch[3].length)
        }
      };
    }
    const fancyMarker = parseFancyListMarker(line);
    if (fancyMarker && fancyMarker.type !== "hash") {
      return {
        type: "fancy",
        content: line,
        metadata: {
          type: fancyMarker.type,
          marker: fancyMarker.marker,
          indent: fancyMarker.indent,
          content: line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1)
        }
      };
    }
    if (context == null ? void 0 : context.isInParagraph) {
      const exampleMarker = parseExampleListMarker(line);
      if (exampleMarker) {
        const contentStart = exampleMarker.indent.length + exampleMarker.originalMarker.length + 1;
        return {
          type: "example",
          content: line,
          metadata: {
            indent: exampleMarker.indent,
            originalMarker: exampleMarker.originalMarker,
            label: exampleMarker.label,
            content: line.substring(contentStart)
          }
        };
      }
    }
    const defMarker = parseDefinitionListMarker(line);
    if (defMarker && defMarker.type === "definition") {
      return {
        type: "definition-item",
        content: line,
        metadata: {
          content: defMarker.content
        }
      };
    }
    if ((context == null ? void 0 : context.nextLine) && ListPatterns.isDefinitionMarker(context.nextLine)) {
      return {
        type: "definition-term",
        content: line,
        metadata: {
          content: line.trim()
        }
      };
    }
    const references = this.findExampleReferences(line);
    if (references.length > 0) {
      return {
        type: "reference",
        content: line,
        metadata: {
          references
        }
      };
    }
    return {
      type: "plain",
      content: line
    };
  }
  /**
   * Parse multiple lines with context
   */
  parseLines(lines, isInParagraph = false) {
    return lines.map((line, index) => {
      const nextLine = index < lines.length - 1 ? lines[index + 1] : void 0;
      return this.parseLine(line, { nextLine, isInParagraph });
    });
  }
  /**
   * Find example references in text
   */
  findExampleReferences(text) {
    const references = [];
    const regex = ListPatterns.EXAMPLE_REFERENCE;
    let match;
    while ((match = regex.exec(text)) !== null) {
      references.push({
        fullMatch: match[0],
        label: match[1],
        startIndex: match.index,
        endIndex: match.index + match[0].length
      });
    }
    return references;
  }
  /**
   * Check if strict validation should be applied
   */
  shouldValidateStrict(parsedLine, lines, currentLineIndex) {
    if (parsedLine.type !== "fancy") {
      return false;
    }
    return true;
  }
};

// src/renderers/ReadingModeRenderer.ts
var import_obsidian6 = require("obsidian");
var ReadingModeRenderer = class {
  /**
   * Render a parsed line to DOM elements
   */
  renderLine(parsedLine, context, lineNumber) {
    switch (parsedLine.type) {
      case "hash":
        return this.renderHashList(parsedLine.metadata, lineNumber);
      case "fancy":
        return this.renderFancyList(parsedLine.metadata);
      case "example":
        return this.renderExampleList(parsedLine.metadata, lineNumber);
      case "definition-term":
        return this.renderDefinitionTerm(parsedLine.metadata);
      case "definition-item":
        return this.renderDefinitionItem(parsedLine.metadata);
      case "reference":
        return this.renderWithReferences(parsedLine.content, parsedLine.metadata, context);
      default:
        return [document.createTextNode(parsedLine.content)];
    }
  }
  /**
   * Render multiple parsed lines with line breaks
   */
  renderLines(parsedLines, context, numberProvider) {
    const elements = [];
    parsedLines.forEach((parsedLine, index) => {
      if (index > 0) {
        if (context.strictLineBreaks) {
          elements.push(document.createElement("br"));
        }
        elements.push(document.createTextNode("\n"));
      }
      let lineNumber;
      if (numberProvider) {
        if (parsedLine.type === "hash") {
          lineNumber = numberProvider("hash", index);
        } else if (parsedLine.type === "example") {
          lineNumber = numberProvider("example", index);
        }
      }
      const lineElements = this.renderLine(parsedLine, context, lineNumber);
      elements.push(...lineElements);
    });
    return elements;
  }
  /**
   * Render hash auto-numbering list
   */
  renderHashList(data, number) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-hash`;
    span.textContent = `${number || "#"}. `;
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render fancy list marker
   */
  renderFancyList(data) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-${data.type}`;
    span.textContent = data.marker + " ";
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render example list
   */
  renderExampleList(data, number) {
    const elements = [];
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_LIST;
    span.textContent = `(${number || "@"}) `;
    if (number) {
      span.dataset.exampleNumber = String(number);
    }
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render definition term
   */
  renderDefinitionTerm(data) {
    const strong = document.createElement("strong");
    const u = document.createElement("u");
    u.textContent = data.content;
    strong.appendChild(u);
    return [strong];
  }
  /**
   * Render definition item
   */
  renderDefinitionItem(data) {
    const elements = [];
    const span = document.createElement("span");
    span.textContent = "\u2022 ";
    elements.push(span);
    elements.push(document.createTextNode(data.content));
    return elements;
  }
  /**
   * Render text with example references
   */
  renderWithReferences(text, data, context) {
    const elements = [];
    let lastIndex = 0;
    data.references.forEach((ref) => {
      var _a, _b;
      if (ref.startIndex > lastIndex) {
        elements.push(document.createTextNode(text.substring(lastIndex, ref.startIndex)));
      }
      const exampleNumber = (_a = context.getExampleNumber) == null ? void 0 : _a.call(context, ref.label);
      if (exampleNumber !== void 0) {
        const span = document.createElement("span");
        span.className = CSS_CLASSES.EXAMPLE_REF;
        span.textContent = `(${exampleNumber})`;
        const tooltipText = (_b = context.getExampleContent) == null ? void 0 : _b.call(context, ref.label);
        if (tooltipText) {
          (0, import_obsidian6.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
        }
        elements.push(span);
      } else {
        elements.push(document.createTextNode(ref.fullMatch));
      }
      lastIndex = ref.endIndex;
    });
    if (lastIndex < text.length) {
      elements.push(document.createTextNode(text.substring(lastIndex)));
    }
    return elements;
  }
  /**
   * Create a line break element
   */
  createLineBreak() {
    return document.createElement("br");
  }
  /**
   * Create a newline text node
   */
  createNewline() {
    return document.createTextNode("\n");
  }
};

// src/state/PluginStateManager.ts
var PluginStateManager = class {
  constructor() {
    // Document-specific counters
    this.documentCounters = /* @__PURE__ */ new Map();
    // View state tracking per leaf
    this.viewStates = /* @__PURE__ */ new Map();
    // Mode change listeners
    this.modeChangeListeners = /* @__PURE__ */ new Set();
    // Track processed elements to prevent duplicate counter increments
    this.processedElements = /* @__PURE__ */ new WeakMap();
    // Track which documents need element reprocessing
    this.documentsNeedingReprocess = /* @__PURE__ */ new Set();
  }
  /**
   * Get or create counters for a document
   */
  getDocumentCounters(docPath) {
    if (!this.documentCounters.has(docPath)) {
      this.documentCounters.set(docPath, this.createEmptyCounters());
    }
    return this.documentCounters.get(docPath);
  }
  /**
   * Reset counters for a specific document
   */
  resetDocumentCounters(docPath) {
    if (this.documentCounters.has(docPath)) {
      const counters = this.documentCounters.get(docPath);
      counters.exampleCounter = 0;
      counters.exampleMap.clear();
      counters.exampleContent.clear();
      counters.hashCounter = 0;
    }
    this.documentsNeedingReprocess.add(docPath);
  }
  /**
   * Clear counters for a document (remove from memory)
   */
  clearDocumentCounters(docPath) {
    this.documentCounters.delete(docPath);
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Update view state and detect mode/document changes
   */
  updateViewState(leaf) {
    var _a;
    const leafId = this.getLeafId(leaf);
    const view = leaf.view;
    const currentMode = this.detectViewMode(view);
    const currentPath = ((_a = view.file) == null ? void 0 : _a.path) || null;
    const previous = this.viewStates.get(leafId);
    const previousMode = (previous == null ? void 0 : previous.mode) || null;
    const previousPath = (previous == null ? void 0 : previous.filePath) || null;
    this.viewStates.set(leafId, {
      mode: currentMode,
      filePath: currentPath
    });
    const modeChanged = previousMode !== currentMode;
    const pathChanged = previousPath !== currentPath;
    if (modeChanged || pathChanged) {
      const event = {
        leafId,
        previousMode,
        currentMode,
        previousPath,
        currentPath
      };
      this.handleStateTransition(event);
      this.notifyModeChange(event);
      return event;
    }
    return null;
  }
  /**
   * Handle state transitions (e.g., reset counters)
   */
  handleStateTransition(event) {
    if (event.previousMode === "reading" && event.currentMode !== "reading") {
      if (event.previousPath) {
        this.resetDocumentCounters(event.previousPath);
      }
    }
    if (event.currentMode === "reading" && event.previousPath && event.currentPath && event.previousPath !== event.currentPath) {
      this.resetDocumentCounters(event.currentPath);
    }
    if (event.currentMode === "reading" && event.currentPath) {
      setTimeout(() => {
        this.clearReprocessFlag(event.currentPath);
      }, 100);
    }
  }
  /**
   * Register a mode change listener
   */
  onModeChange(callback) {
    this.modeChangeListeners.add(callback);
    return () => {
      this.modeChangeListeners.delete(callback);
    };
  }
  /**
   * Notify all mode change listeners
   */
  notifyModeChange(event) {
    this.modeChangeListeners.forEach((callback) => callback(event));
  }
  /**
   * Increment example counter for a document
   */
  incrementExampleCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleCounter++;
    return counters.exampleCounter;
  }
  /**
   * Increment hash counter for a document
   */
  incrementHashCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.hashCounter++;
    return counters.hashCounter;
  }
  /**
   * Store labeled example data
   */
  setLabeledExample(docPath, label, number, content) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleMap.set(label, number);
    if (content) {
      counters.exampleContent.set(label, content);
    }
  }
  /**
   * Get labeled example number
   */
  getLabeledExampleNumber(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleMap.get(label);
  }
  /**
   * Get labeled example content
   */
  getLabeledExampleContent(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleContent.get(label);
  }
  /**
   * Mark an element as processed to prevent duplicate processing
   */
  markElementProcessed(element, key, value) {
    if (!this.processedElements.has(element)) {
      this.processedElements.set(element, /* @__PURE__ */ new Map());
    }
    this.processedElements.get(element).set(key, value);
  }
  /**
   * Check if an element has been processed
   */
  isElementProcessed(element, key, docPath) {
    if (docPath && this.documentsNeedingReprocess.has(docPath)) {
      return false;
    }
    return this.processedElements.has(element) && this.processedElements.get(element).has(key);
  }
  /**
   * Clear reprocess flag for a document after processing
   */
  clearReprocessFlag(docPath) {
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Get processed element data
   */
  getProcessedElementData(element, key) {
    if (this.processedElements.has(element)) {
      return this.processedElements.get(element).get(key);
    }
    return void 0;
  }
  /**
   * Scan all leaves and update states
   * Returns true if any mode changes were detected
   */
  scanAllLeaves(leaves) {
    var _a;
    let anyChanges = false;
    for (const leaf of leaves) {
      if (((_a = leaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
        const event = this.updateViewState(leaf);
        if (event) {
          anyChanges = true;
        }
      }
    }
    return anyChanges;
  }
  /**
   * Clear all states (for plugin unload)
   */
  clearAllStates() {
    this.documentCounters.clear();
    this.viewStates.clear();
    this.modeChangeListeners.clear();
  }
  /**
   * Create empty counters object
   */
  createEmptyCounters() {
    return {
      exampleCounter: 0,
      exampleMap: /* @__PURE__ */ new Map(),
      exampleContent: /* @__PURE__ */ new Map(),
      hashCounter: 0
    };
  }
  /**
   * Detect the current view mode from a MarkdownView
   */
  detectViewMode(view) {
    const state = view.getState();
    if ((state == null ? void 0 : state.mode) === "preview") return "reading";
    if ((state == null ? void 0 : state.mode) === "source") {
      return state.source ? "source" : "live";
    }
    return view.getMode() === "preview" ? "reading" : "live";
  }
  /**
   * Get a stable ID for a leaf
   */
  getLeafId(leaf) {
    var _a, _b;
    if ("id" in leaf && leaf.id) {
      return leaf.id;
    }
    const view = leaf.view;
    return `${(_b = (_a = view == null ? void 0 : view.file) == null ? void 0 : _a.path) != null ? _b : "unknown"}::${Math.random()}`;
  }
};
var pluginStateManager = new PluginStateManager();

// src/parsers/customLabelListParser.ts
function processCustomLabelLists(element, context) {
  if (!element.textContent || !element.textContent.includes("{::")) {
    return;
  }
  const paragraphs = element.querySelectorAll("p");
  paragraphs.forEach((p) => {
    processElement(p);
  });
  const listItems = element.querySelectorAll("li");
  listItems.forEach((li) => {
    processElement(li);
    if (li.querySelector(`.${CSS_CLASSES.PANDOC_LIST_MARKER}`)) {
      li.classList.add("pandoc-custom-label-item");
    }
  });
}
function processTextNode(node, container) {
  const text = node.textContent || "";
  const listMatch = text.match(ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT);
  if (listMatch) {
    const indent = listMatch[1];
    const label = listMatch[3];
    const space = listMatch[4];
    const rest = listMatch[5];
    if (indent) {
      container.appendChild(document.createTextNode(indent));
    }
    const markerSpan = document.createElement("span");
    markerSpan.className = CSS_CLASSES.PANDOC_LIST_MARKER;
    markerSpan.textContent = `(${label})`;
    container.appendChild(markerSpan);
    container.appendChild(document.createTextNode(space));
    processReferencesInText(rest, container);
  } else {
    processReferencesInText(text, container);
  }
}
function processReferencesInText(text, container) {
  const refPattern = ListPatterns.CUSTOM_LABEL_REFERENCE;
  let lastIndex = 0;
  let match;
  while ((match = refPattern.exec(text)) !== null) {
    if (match.index > lastIndex) {
      container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
    }
    const refSpan = document.createElement("span");
    refSpan.className = CSS_CLASSES.EXAMPLE_REF;
    refSpan.setAttribute("data-custom-label-ref", match[1]);
    refSpan.textContent = `(${match[1]})`;
    container.appendChild(refSpan);
    lastIndex = refPattern.lastIndex;
  }
  if (lastIndex < text.length) {
    container.appendChild(document.createTextNode(text.substring(lastIndex)));
  }
}
function processElement(elem) {
  if (elem.querySelector("code, pre") || elem.closest("code, pre")) {
    return;
  }
  if (!elem.textContent || !elem.textContent.includes("{::")) {
    return;
  }
  const newContainer = document.createElement("div");
  const childNodes = Array.from(elem.childNodes);
  for (const node of childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent || "";
      const lines = text.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (i > 0) {
          newContainer.appendChild(document.createTextNode("\n"));
        }
        if (lines[i]) {
          processTextNode({ textContent: lines[i] }, newContainer);
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
      newContainer.appendChild(node.cloneNode(true));
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const elemNode = node;
      if (elemNode.textContent && elemNode.textContent.includes("{::")) {
        const clonedElem = elemNode.cloneNode(false);
        const tempContainer = document.createElement("div");
        Array.from(elemNode.childNodes).forEach((child) => {
          tempContainer.appendChild(child.cloneNode(true));
        });
        processElement(tempContainer);
        while (tempContainer.firstChild) {
          clonedElem.appendChild(tempContainer.firstChild);
        }
        newContainer.appendChild(clonedElem);
      } else {
        newContainer.appendChild(node.cloneNode(true));
      }
    } else {
      newContainer.appendChild(node.cloneNode(true));
    }
  }
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
  while (newContainer.firstChild) {
    elem.appendChild(newContainer.firstChild);
  }
}

// src/pandocValidator.ts
function isStrictPandocFormatting(context, strictMode) {
  if (!strictMode) {
    return true;
  }
  const { lines, currentLine } = context;
  const line = lines[currentLine];
  const isPartOfListBlock = currentLine > 0 && isListItem(lines[currentLine - 1], false);
  if (currentLine > 0 && !isPartOfListBlock) {
    const prevLine = lines[currentLine - 1];
    if (prevLine.trim() !== "") {
      return false;
    }
  }
  const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
  if (capitalLetterMatch && capitalLetterMatch[3] === ".") {
    if (capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      return false;
    }
  }
  let isLastItemInList = true;
  if (currentLine < lines.length - 1) {
    const nextLine = lines[currentLine + 1];
    const nextIsListItem = isListItem(nextLine, false);
    if (!nextIsListItem && nextLine.trim() !== "") {
      return false;
    }
    if (nextIsListItem) {
      isLastItemInList = false;
    }
  }
  return true;
}
function isListItem(line, includeCustomLabels = false) {
  if (ListPatterns.FANCY_LIST_WITH_NUMBERS.test(line) || ListPatterns.STANDARD_ORDERED_LIST.test(line) || ListPatterns.UNORDERED_LIST.test(line) || ListPatterns.isExampleList(line) || ListPatterns.isDefinitionMarker(line)) {
    return true;
  }
  if (includeCustomLabels && ListPatterns.isCustomLabelList(line)) {
    return true;
  }
  return false;
}
function formatToPandocStandard(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const result = [];
  let inListBlock = false;
  let lastWasEmpty = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList && !inListBlock) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      inListBlock = true;
    }
    if (!isCurrentLineList && !isEmpty && inListBlock) {
      if (!lastWasEmpty) {
        result.push("");
      }
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (result.length > 0 && !lastWasEmpty && i > 0) {
        result.push("");
      }
      let formattedLine = line;
      result.push(formattedLine);
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        result.push("");
        lastWasEmpty = true;
      } else {
        lastWasEmpty = false;
      }
      continue;
    }
    const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
    if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      const formattedLine = line.replace(ListPatterns.CAPITAL_LETTER_REPLACE, "$1$2  ");
      result.push(formattedLine);
    } else {
      result.push(line);
    }
    lastWasEmpty = isEmpty;
  }
  const cleanedResult = [];
  let prevWasEmpty = false;
  for (const line of result) {
    if (line.trim() === "") {
      if (!prevWasEmpty) {
        cleanedResult.push(line);
        prevWasEmpty = true;
      }
    } else {
      cleanedResult.push(line);
      prevWasEmpty = false;
    }
  }
  return cleanedResult.join("\n");
}
function checkPandocFormatting(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const issues = [];
  let inListBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList) {
      if (!inListBlock && i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "List should have an empty line before it"
        });
      }
      const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
      if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
        issues.push({
          line: i + 1,
          message: "Capital letter list with period requires at least 2 spaces after marker"
        });
      }
      inListBlock = true;
    } else if (!isEmpty && inListBlock) {
      if (i > 0 && isListItem(lines[i - 1])) {
        issues.push({
          line: i,
          message: "List should have an empty line after it"
        });
      }
      inListBlock = false;
    } else if (isEmpty) {
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line before it"
        });
      }
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line after it"
        });
      }
    }
  }
  return issues;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context, config) {
  const docPath = context.sourcePath || "unknown";
  const parser = new ReadingModeParser();
  const renderer = new ReadingModeRenderer();
  const elementsToProcess = element.querySelectorAll("p, li");
  let validationLines = [];
  if (config.strictPandocMode) {
    const section = element.closest(".markdown-preview-section");
    const sectionInfo = getSectionInfo(section);
    if (sectionInfo == null ? void 0 : sectionInfo.text) {
      validationLines = sectionInfo.text.split("\n");
    }
  }
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    if (pluginStateManager.isElementProcessed(elem, "pandoc-processed", docPath)) {
      return;
    }
    processElementTextNodes(elem, parser, renderer, config, docPath, validationLines);
    pluginStateManager.markElementProcessed(elem, "pandoc-processed", true);
  });
  if (config.enableSuperSubscripts) {
    processSuperSub(element);
  }
  if (config.enableCustomLabelLists) {
    processCustomLabelLists(element, context);
  }
}
function processElementTextNodes(elem, parser, renderer, config, docPath, validationLines) {
  const walker = document.createTreeWalker(
    elem,
    NodeFilter.SHOW_TEXT,
    null
  );
  const nodesToProcess = [];
  while (walker.nextNode()) {
    nodesToProcess.push(walker.currentNode);
  }
  nodesToProcess.forEach((node) => {
    const parent = node.parentNode;
    if (!parent) return;
    if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
      return;
    }
    const text = node.textContent || "";
    if (!containsPandocSyntax(text, config)) {
      return;
    }
    const isInParagraph = parent.nodeName === "P";
    const lines = text.split("\n");
    const parsedLines = parser.parseLines(lines, isInParagraph);
    if (config.strictPandocMode) {
      parsedLines.forEach((parsedLine, index) => {
        if (parsedLine.type === "fancy" && validationLines.length > 0) {
          if (!validateListInStrictMode(lines[index], validationLines, config)) {
            parsedLine.type = "plain";
          }
        }
      });
    }
    const renderContext = {
      strictLineBreaks: config.strictLineBreaks,
      getExampleNumber: (label) => pluginStateManager.getLabeledExampleNumber(docPath, label),
      getExampleContent: (label) => pluginStateManager.getLabeledExampleContent(docPath, label)
    };
    const numberProvider = (type, index) => {
      var _a;
      const parsedLine = parsedLines[index];
      if (type === "hash") {
        return pluginStateManager.incrementHashCounter(docPath);
      }
      if (type === "example" && parsedLine.type === "example") {
        const metadata = parsedLine.metadata;
        const number = pluginStateManager.incrementExampleCounter(docPath);
        if (metadata.label) {
          pluginStateManager.setLabeledExample(
            docPath,
            metadata.label,
            number,
            (_a = metadata.content) == null ? void 0 : _a.trim()
          );
        }
        return number;
      }
      return 0;
    };
    const newElements = renderer.renderLines(parsedLines, renderContext, numberProvider);
    if (newElements.length > 0) {
      newElements.forEach((elem2) => {
        parent.insertBefore(elem2, node);
      });
      parent.removeChild(node);
    }
  });
}
function containsPandocSyntax(text, config) {
  const hasBasicSyntax = ListPatterns.isHashList(text) || ListPatterns.isFancyList(text) || ListPatterns.isExampleList(text) || ListPatterns.isDefinitionMarker(text) || ListPatterns.findExampleReferences(text).length > 0;
  const hasCustomLabelSyntax = (config == null ? void 0 : config.enableCustomLabelLists) && (ListPatterns.isCustomLabelList(text) || ListPatterns.findCustomLabelReferences(text).length > 0);
  return hasBasicSyntax || hasCustomLabelSyntax;
}
function validateListInStrictMode(line, documentLines, config) {
  let lineNum = -1;
  for (let i = 0; i < documentLines.length; i++) {
    if (documentLines[i].includes(line.trim())) {
      lineNum = i;
      break;
    }
  }
  if (lineNum >= 0) {
    const validationContext = {
      lines: documentLines,
      currentLine: lineNum
    };
    return isStrictPandocFormatting(validationContext, config.strictPandocMode);
  }
  return true;
}

// src/ExampleReferenceSuggestFixed.ts
var import_obsidian7 = require("obsidian");
var ExampleReferenceSuggestFixed = class extends import_obsidian7.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = ListPatterns.findExampleRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = ListPatterns.isExampleList(line);
      if (match) {
        const label = match[3];
        if (label) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!exampleData.has(label)) {
            exampleData.set(label, { number: counter, text });
          }
        }
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/customLabelReferenceSuggest.ts
var import_obsidian8 = require("obsidian");
var CustomLabelReferenceSuggest = class extends import_obsidian8.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    if (!this.plugin.settings.moreExtendedSyntax) return null;
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.includes("{::")) return null;
    const matches = ListPatterns.findCustomLabelRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterStart = line.substring(startIndex + 3);
    if (afterStart.includes("}")) return null;
    const query = afterStart;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const labelData = /* @__PURE__ */ new Map();
    for (const line of lines) {
      const match = ListPatterns.isCustomLabelList(line);
      if (match) {
        const label = match[3];
        if (label) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!labelData.has(label)) {
            labelData.set(label, text);
          }
        }
      }
    }
    const suggestions = [];
    for (const [label, text] of labelData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    title.setText(`::${suggestion.label}`);
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingBrace = afterCursor.startsWith("}");
    let replacement;
    if (hasClosingBrace) {
      replacement = `{::${suggestion.label}`;
    } else {
      replacement = `{::${suggestion.label}}`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingBrace) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/listAutocompletion.ts
var import_state2 = require("@codemirror/state");
function getNextLetter(letter) {
  if (letter === "Z" || letter === "z") {
    return null;
  }
  return String.fromCharCode(letter.charCodeAt(0) + 1);
}
function numberToLetter(num, isUpperCase) {
  const letter = String.fromCharCode("A".charCodeAt(0) + num - 1);
  return isUpperCase ? letter : letter.toLowerCase();
}
function romanToInt(roman) {
  const romanValues = {
    "i": 1,
    "iv": 4,
    "v": 5,
    "ix": 9,
    "x": 10,
    "xl": 40,
    "l": 50,
    "xc": 90,
    "c": 100,
    "cd": 400,
    "d": 500,
    "cm": 900,
    "m": 1e3,
    "I": 1,
    "IV": 4,
    "V": 5,
    "IX": 9,
    "X": 10,
    "XL": 40,
    "L": 50,
    "XC": 90,
    "C": 100,
    "CD": 400,
    "D": 500,
    "CM": 900,
    "M": 1e3
  };
  let value = 0;
  let i = 0;
  const normalizedRoman = roman.toLowerCase();
  while (i < normalizedRoman.length) {
    if (i + 1 < normalizedRoman.length && romanValues[normalizedRoman.substring(i, i + 2)]) {
      value += romanValues[normalizedRoman.substring(i, i + 2)];
      i += 2;
    } else {
      value += romanValues[normalizedRoman[i]] || 0;
      i++;
    }
  }
  return value;
}
function intToRoman(num, isUpperCase) {
  const intToRomanUpper = [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ];
  const intToRomanLower = [
    [1e3, "m"],
    [900, "cm"],
    [500, "d"],
    [400, "cd"],
    [100, "c"],
    [90, "xc"],
    [50, "l"],
    [40, "xl"],
    [10, "x"],
    [9, "ix"],
    [5, "v"],
    [4, "iv"],
    [1, "i"]
  ];
  let result = "";
  const table = isUpperCase ? intToRomanUpper : intToRomanLower;
  for (const [value, sym] of table) {
    while (num >= value) {
      result += sym;
      num -= value;
    }
  }
  return result;
}
function getNextRoman(roman) {
  const value = romanToInt(roman);
  const isUpperCase = roman[0] === roman[0].toUpperCase();
  return intToRoman(value + 1, isUpperCase);
}
function getNextListMarker(currentLine, allLines, currentLineIndex) {
  const hashMatch = ListPatterns.isHashList(currentLine);
  if (hashMatch) {
    return { marker: "#.", indent: hashMatch[1], spaces: hashMatch[3] };
  }
  const customLabelMatch = ListPatterns.isCustomLabelList(currentLine);
  if (customLabelMatch) {
    const indent = customLabelMatch[1];
    const spaces = customLabelMatch[4];
    return { marker: "{::}", indent, spaces };
  }
  const listMatch = currentLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
  if (listMatch) {
    const indent = listMatch[1];
    const marker = listMatch[2];
    const punctuation = listMatch[3];
    const spaces = listMatch[4];
    let isRoman = false;
    if (marker.length > 1 && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
      isRoman = true;
    } else if (marker.length === 1 && allLines && currentLineIndex !== void 0) {
      if (marker.match(ListPatterns.SINGLE_I)) {
        isRoman = true;
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
          const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.match(ListPatterns.SINGLE_H)) {
              isRoman = false;
              break;
            } else if (prevMarker.length > 1 && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = false;
              break;
            }
          }
        }
      } else {
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
          const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.length > 1 && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = false;
              break;
            } else if (prevMarker.match(ListPatterns.SINGLE_AB)) {
              isRoman = false;
              break;
            }
          }
        }
      }
    }
    if (isRoman) {
      if (marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
        const nextRoman = getNextRoman(marker);
        return { marker: `${nextRoman}${punctuation}`, indent, spaces };
      }
    } else {
      const nextLetter = getNextLetter(marker);
      if (nextLetter) {
        return { marker: `${nextLetter}${punctuation}`, indent, spaces };
      }
      return null;
    }
  }
  let exampleMatch = currentLine.match(ListPatterns.EXAMPLE_LIST);
  if (exampleMatch) {
    const indent = exampleMatch[1];
    const spaces = exampleMatch[4];
    return { marker: "(@)", indent, spaces };
  }
  const altMatch = currentLine.match(ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE);
  if (altMatch && currentLine.length > altMatch[0].length) {
    const indent = altMatch[1];
    const spaces = altMatch[3] || " ";
    return { marker: "(@)", indent, spaces };
  }
  const definitionMatch = currentLine.match(ListPatterns.DEFINITION_MARKER);
  if (definitionMatch) {
    const indent = definitionMatch[1];
    const marker = definitionMatch[2];
    const spaces = definitionMatch[3];
    return { marker, indent, spaces };
  }
  return null;
}
function renumberListItems(view, insertedLineNum) {
  const state = view.state;
  const doc = state.doc;
  const allLines = doc.toString().split("\n");
  let blockStart = insertedLineNum;
  let blockEnd = insertedLineNum;
  const insertedLine = allLines[insertedLineNum];
  const insertedIndentMatch = insertedLine.match(ListPatterns.INDENT_ONLY);
  const insertedIndent = insertedIndentMatch ? insertedIndentMatch[1] : "";
  for (let i = insertedLineNum - 1; i >= 0; i--) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockStart = i;
    }
  }
  for (let i = insertedLineNum + 1; i < allLines.length; i++) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockEnd = i;
    }
  }
  const listItems = [];
  for (let i = blockStart; i <= blockEnd; i++) {
    const line = allLines[i];
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT);
    if (listMatch && listMatch[1] === insertedIndent) {
      const marker = listMatch[2];
      const punctuation = listMatch[3];
      const spaces = listMatch[4];
      const content = listMatch[5];
      let isRoman = false;
      let isAlpha = false;
      if (marker === "#") {
      } else if (marker.match(ListPatterns.ALPHABETIC_CHARS)) {
        if (marker.length > 1 && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
          isRoman = true;
        } else if (marker.length === 1 && marker.match(ListPatterns.SINGLE_ROMAN_CHAR)) {
          if (i === blockStart) {
            isRoman = marker.match(ListPatterns.SINGLE_I) !== null;
            if (!isRoman) {
              isAlpha = true;
            }
          } else {
            isRoman = listItems.length > 0 && listItems[0].isRoman;
            isAlpha = listItems.length > 0 && listItems[0].isAlpha;
          }
        } else {
          isAlpha = true;
        }
      }
      listItems.push({
        lineNum: i,
        marker,
        punctuation,
        spaces,
        content,
        isRoman,
        isAlpha
      });
    }
  }
  if (listItems.length > 1) {
    const changes = [];
    let currentValue = 1;
    const firstItem = listItems[0];
    for (let i = 0; i < listItems.length; i++) {
      const item = listItems[i];
      let newMarker;
      if (item.marker === "#") {
        newMarker = "#";
      } else if (item.isRoman) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = intToRoman(i + 1, isUpperCase);
      } else if (item.isAlpha) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = numberToLetter(i + 1, isUpperCase);
      } else {
        newMarker = item.marker;
      }
      const newLine = `${insertedIndent}${newMarker}${item.punctuation}${item.spaces}${item.content}`;
      const oldLine = allLines[item.lineNum];
      if (newLine !== oldLine) {
        const lineStartPos = doc.line(item.lineNum + 1).from;
        const lineEndPos = doc.line(item.lineNum + 1).to;
        changes.push({
          from: lineStartPos,
          to: lineEndPos,
          insert: newLine
        });
      }
    }
    if (changes.length > 0) {
      const transaction = state.update({ changes });
      view.dispatch(transaction);
    }
  }
}
function isEmptyListItem(line) {
  if (line.match(ListPatterns.EMPTY_HASH_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_FANCY_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL)) return true;
  if (line.match(ListPatterns.EMPTY_DEFINITION_LIST)) return true;
  return false;
}
function createListAutocompletionKeymap(settings) {
  const handleListEnter = {
    key: "Enter",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const isEmptyExampleList = lineText.match(ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL);
      if (isEmptyExampleList) {
        const beforeCursor = state.doc.sliceString(line.from, selection.from);
        const afterCursor = state.doc.sliceString(selection.from, line.to);
        if (beforeCursor.endsWith("(@") && afterCursor.startsWith(")")) {
          const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
          const indent = indentMatch ? indentMatch[1] : "";
          const changes = {
            from: line.from,
            to: line.to,
            insert: indent
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + indent.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      const isEmptyCustomLabelList = lineText.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL);
      if (isEmptyCustomLabelList) {
        const beforeCursor = state.doc.sliceString(line.from, selection.from);
        const afterCursor = state.doc.sliceString(selection.from, line.to);
        if (beforeCursor.endsWith("{::") && afterCursor.startsWith("}")) {
          const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
          const indent = indentMatch ? indentMatch[1] : "";
          const changes = {
            from: line.from,
            to: line.to,
            insert: indent
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + indent.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      const isListItem2 = lineText.match(ListPatterns.ANY_LIST_MARKER);
      if (!isListItem2) {
        if (selection.from !== line.to || selection.from !== selection.to) {
          return false;
        }
      } else {
        const distanceFromEnd = line.to - selection.from;
        if (distanceFromEnd > 2 || selection.from !== selection.to) {
          return false;
        }
      }
      if (lineText.match(ListPatterns.NUMBERED_LIST_WITH_SPACE)) {
        return false;
      }
      if (isEmptyListItem(lineText)) {
        const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
        if (indentMatch && indentMatch[1].length >= INDENTATION.TAB_SIZE) {
          const currentIndent = indentMatch[1];
          let newIndent = "";
          if (currentIndent.startsWith(INDENTATION.FOUR_SPACES)) {
            newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
          } else if (currentIndent.startsWith(INDENTATION.TAB)) {
            newIndent = currentIndent.substring(1);
          } else {
            newIndent = currentIndent.substring(Math.min(INDENTATION.TAB_SIZE, currentIndent.length));
          }
          let previousMarker = null;
          for (let i = line.number - 1; i >= 1; i--) {
            const prevLine = state.doc.line(i);
            const prevText = prevLine.text;
            const prevIndentMatch = prevText.match(ListPatterns.INDENT_ONLY);
            if (prevIndentMatch && prevIndentMatch[1] === newIndent) {
              const allLines2 = state.doc.toString().split("\n");
              const markerInfo2 = getNextListMarker(prevText, allLines2, i - 1);
              if (markerInfo2) {
                previousMarker = markerInfo2;
                break;
              }
            }
          }
          if (previousMarker && newIndent.length > 0) {
            const spaces = previousMarker.spaces || " ";
            const newLine = `${newIndent}${previousMarker.marker}${spaces}`;
            const changes2 = {
              from: line.from,
              to: line.to,
              insert: newLine
            };
            const transaction2 = state.update({
              changes: changes2,
              selection: import_state2.EditorSelection.cursor(line.from + newLine.length)
            });
            view.dispatch(transaction2);
            return true;
          }
        }
        const changes = {
          from: line.from,
          to: line.to,
          insert: ""
        };
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from)
        });
        view.dispatch(transaction);
        return true;
      }
      const allLines = state.doc.toString().split("\n");
      const currentLineIndex = line.number - 1;
      const markerInfo = getNextListMarker(lineText, allLines, currentLineIndex);
      if (markerInfo) {
        const spaces = markerInfo.spaces || " ";
        const newLine = `
${markerInfo.indent}${markerInfo.marker}${spaces}`;
        const insertPos = selection.from === line.to ? selection.from : line.to;
        const changes = {
          from: insertPos,
          to: insertPos,
          insert: newLine
        };
        const cursorOffset = markerInfo.marker === "(@)" ? newLine.length - spaces.length - 1 : markerInfo.marker === "{::}" ? newLine.length - spaces.length - 1 : newLine.length;
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(insertPos + cursorOffset)
        });
        view.dispatch(transaction);
        if (settings.autoRenumberLists && markerInfo.marker !== "(@)" && markerInfo.marker !== "{::}" && markerInfo.marker !== "#." && !markerInfo.marker.match(ListPatterns.DEFINITION_MARKER_ONLY)) {
          const newLineNum = line.number;
          setTimeout(() => {
            renumberListItems(view, newLineNum);
          }, 0);
        }
        return true;
      }
      return false;
    }
  };
  const handleListTab = {
    key: "Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_SPACE);
      if (listMatch) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        if (selection.from === line.from + markerEnd && selection.to === selection.from) {
          const newIndent = currentIndent + INDENTATION.FOUR_SPACES;
          const newLine = newIndent + marker + space + lineText.substring(markerEnd);
          const changes = {
            from: line.from,
            to: line.to,
            insert: newLine
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + newIndent.length + marker.length + space.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      return false;
    }
  };
  const handleListShiftTab = {
    key: "Shift-Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE);
      if (listMatch && listMatch[1].length > 0) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        let newIndent = "";
        if (currentIndent.startsWith("    ")) {
          newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
        } else if (currentIndent.startsWith("	")) {
          newIndent = currentIndent.substring(1);
        } else {
          newIndent = currentIndent.substring(Math.min(4, currentIndent.length));
        }
        const newLine = newIndent + marker + space + lineText.substring(markerEnd);
        const changes = {
          from: line.from,
          to: line.to,
          insert: newLine
        };
        const oldCursorOffset = selection.from - line.from;
        const indentDiff = currentIndent.length - newIndent.length;
        const newCursorOffset = Math.max(newIndent.length + marker.length + space.length, oldCursorOffset - indentDiff);
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from + newCursorOffset)
        });
        view.dispatch(transaction);
        return true;
      }
      return false;
    }
  };
  return [
    handleListEnter,
    handleListTab,
    handleListShiftTab
  ];
}

// src/main.ts
var PandocExtendedMarkdownPlugin = class extends import_obsidian9.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PandocExtendedMarkdownSettingTab(this.app, this));
    this.registerExtensions();
    this.registerPostProcessor();
    this.setupModeChangeDetection();
    this.suggester = new ExampleReferenceSuggestFixed(this);
    this.registerEditorSuggest(this.suggester);
    this.customLabelSuggester = new CustomLabelReferenceSuggest(this);
    this.registerEditorSuggest(this.customLabelSuggester);
    this.registerCommands();
  }
  registerExtensions() {
    this.registerEditorExtension(pandocExtendedMarkdownExtension(() => this.settings));
    this.registerEditorExtension(import_state3.Prec.highest(import_view11.keymap.of(createListAutocompletionKeymap(this.settings))));
  }
  registerPostProcessor() {
    this.registerMarkdownPostProcessor((element, context) => {
      const config = createProcessorConfig(
        { strictLineBreaks: this.app.vault.getConfig("strictLineBreaks") },
        this.settings
      );
      processReadingMode(element, context, config);
    });
  }
  setupModeChangeDetection() {
    const updateStates = () => {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      const hadChanges = pluginStateManager.scanAllLeaves(leaves);
      if (hadChanges) {
        setTimeout(() => {
          this.app.workspace.iterateCodeMirrors((cm) => {
            if (cm.dispatch) {
              cm.dispatch({ effects: [] });
            }
          });
        }, 10);
      }
    };
    updateStates();
    this.registerEvent(this.app.workspace.on("layout-change", updateStates));
    this.registerEvent(this.app.workspace.on("active-leaf-change", updateStates));
    this.registerEvent(this.app.workspace.on("file-open", updateStates));
  }
  registerCommands() {
    this.addCommand({
      id: COMMANDS.CHECK_PANDOC,
      name: "Check pandoc formatting",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const issues = checkPandocFormatting(content, this.settings.moreExtendedSyntax);
        if (issues.length === 0) {
          new import_obsidian9.Notice(MESSAGES.PANDOC_COMPLIANT);
        } else {
          const issueList = issues.map(
            (issue) => `Line ${issue.line}: ${issue.message}`
          ).join("\n");
          new import_obsidian9.Notice(`${MESSAGES.FORMATTING_ISSUES(issues.length)}:
${issueList}`, UI_CONSTANTS.NOTICE_DURATION_MS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.FORMAT_PANDOC,
      name: "Format document to pandoc standard",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const formatted = formatToPandocStandard(content, this.settings.moreExtendedSyntax);
        if (content !== formatted) {
          editor.setValue(formatted);
          new import_obsidian9.Notice(MESSAGES.FORMAT_SUCCESS);
        } else {
          new import_obsidian9.Notice(MESSAGES.FORMAT_ALREADY_COMPLIANT);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_BOLD,
      name: "Toggle definition list bold style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionBoldStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian9.Notice(MESSAGES.TOGGLE_BOLD_SUCCESS);
        } else {
          new import_obsidian9.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_UNDERLINE,
      name: "Toggle definition list underline style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionUnderlineStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian9.Notice(MESSAGES.TOGGLE_UNDERLINE_SUCCESS);
        } else {
          new import_obsidian9.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
  }
  onunload() {
    pluginStateManager.clearAllStates();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isDefinitionTerm(lines, index) {
    if (index + 1 >= lines.length) {
      return false;
    }
    const nextLine = lines[index + 1].trim();
    if (ListPatterns.isDefinitionMarker(nextLine)) {
      return true;
    }
    if (nextLine === "" && index + 2 < lines.length) {
      const lineAfterEmpty = lines[index + 2].trim();
      return ListPatterns.isDefinitionMarker(lineAfterEmpty) !== null;
    }
    return false;
  }
  identifyDefinitionTerms(lines) {
    const definitionTerms = [];
    let anyHasBold = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasBold = ListPatterns.BOLD_TEXT.test(trimmedLine);
        definitionTerms.push({ index: i, hasBold });
        if (hasBold) {
          anyHasBold = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasBold };
  }
  identifyDefinitionTermsWithUnderline(lines) {
    const definitionTerms = [];
    let anyHasUnderline = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasUnderline = ListPatterns.UNDERLINE_SPAN.test(trimmedLine);
        definitionTerms.push({ index: i, hasUnderline });
        if (hasUnderline) {
          anyHasUnderline = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasUnderline };
  }
  toggleDefinitionBoldStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasBold } = this.identifyDefinitionTerms(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasBold) {
        const match = trimmedLine.match(ListPatterns.BOLD_TEXT);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.BOLD_TEXT.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + "**" + trimmedLine + "**";
        }
      }
    }
    return modifiedLines.join("\n");
  }
  toggleDefinitionUnderlineStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasUnderline } = this.identifyDefinitionTermsWithUnderline(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasUnderline) {
        const match = trimmedLine.match(ListPatterns.UNDERLINE_SPAN);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.UNDERLINE_SPAN.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + '<span class="underline">' + trimmedLine + "</span>";
        }
      }
    }
    return modifiedLines.join("\n");
  }
};
var main_default = PandocExtendedMarkdownPlugin;
