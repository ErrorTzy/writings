/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PandocExtendedMarkdownPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");
var import_state3 = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// src/decorations/pandocListsExtension.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian = require("obsidian");

// src/constants.ts
var INDENTATION = {
  TAB_SIZE: 4,
  MIN_INDENT: 0,
  MAX_INDENT: 40,
  SINGLE_SPACE: 1,
  DOUBLE_SPACE: 2,
  TAB: "	",
  FOUR_SPACES: "    "
};
var CSS_CLASSES = {
  // Fancy List Classes
  FANCY_LIST: "pandoc-list-fancy",
  FANCY_LIST_UPPER_ALPHA: "pandoc-list-upper-alpha",
  FANCY_LIST_LOWER_ALPHA: "pandoc-list-lower-alpha",
  FANCY_LIST_UPPER_ROMAN: "pandoc-list-upper-roman",
  FANCY_LIST_LOWER_ROMAN: "pandoc-list-lower-roman",
  FANCY_LIST_PAREN: "pandoc-list-paren",
  // Definition List Classes
  DEFINITION_LIST: "pandoc-definition-list",
  DEFINITION_TERM: "pandoc-definition-term",
  DEFINITION_DESC: "pandoc-list-definition-desc",
  DEFINITION_ITEMS: "pandoc-definition-items",
  // Example List Classes
  EXAMPLE_REF: "pandoc-example-reference",
  EXAMPLE_LIST: "pandoc-example-list",
  EXAMPLE_ITEM: "pandoc-example-item",
  // Superscript and Subscript Classes
  SUPERSCRIPT: "pandoc-superscript",
  SUBSCRIPT: "pandoc-subscript",
  // Suggestion Classes
  SUGGESTION_CONTENT: "pandoc-suggestion-content",
  SUGGESTION_TITLE: "pandoc-suggestion-title",
  SUGGESTION_PREVIEW: "pandoc-suggestion-preview",
  // CodeMirror Classes
  LIST_LINE: "HyperMD-list-line",
  LIST_LINE_1: "HyperMD-list-line-1",
  CM_LIST_1: "cm-list-1",
  CM_FORMATTING: "cm-formatting",
  CM_FORMATTING_LIST: "cm-formatting-list",
  CM_FORMATTING_LIST_OL: "cm-formatting-list-ol",
  LIST_NUMBER: "list-number",
  DEFINITION_TERM_DECORATION: "cm-pandoc-definition-term",
  DEFINITION_PARAGRAPH: "cm-pandoc-definition-paragraph",
  // Generic Classes
  PANDOC_LIST_MARKER: "pandoc-list-marker"
};
var MESSAGES = {
  // Success messages
  FORMAT_SUCCESS: "Document formatted to pandoc standard",
  FORMAT_ALREADY_COMPLIANT: "Document already follows pandoc standard",
  PANDOC_COMPLIANT: "Document follows pandoc formatting standards",
  TOGGLE_BOLD_SUCCESS: "Definition terms bold style toggled",
  // Error messages
  NO_DEFINITION_TERMS: "No definition terms found to toggle",
  // Formatting issue messages
  FORMATTING_ISSUES: (count) => `Found ${count} formatting issues`
};
var COMMANDS = {
  CHECK_PANDOC: "check-pandoc-formatting",
  FORMAT_PANDOC: "format-to-pandoc-standard",
  TOGGLE_DEFINITION_BOLD: "toggle-definition-bold-style"
};

// src/patterns.ts
var ListPatterns = class {
  /**
   * Get a cached RegExp pattern by name.
   * This allows for lazy compilation and caching of patterns.
   */
  static getPattern(name) {
    if (!this.compiledPatterns.has(name)) {
      const pattern = this[name];
      if (pattern instanceof RegExp) {
        this.compiledPatterns.set(name, new RegExp(pattern));
      }
    }
    return this.compiledPatterns.get(name) || this[name];
  }
  /**
   * Test if a line matches a hash list pattern.
   */
  static isHashList(line) {
    return line.match(this.HASH_LIST);
  }
  /**
   * Test if a line matches a fancy list pattern.
   */
  static isFancyList(line) {
    const match = line.match(this.FANCY_LIST);
    if (match && !line.match(this.NUMBERED_LIST)) {
      return match;
    }
    return null;
  }
  /**
   * Test if a line matches an example list pattern.
   */
  static isExampleList(line) {
    return line.match(this.EXAMPLE_LIST);
  }
  /**
   * Test if a line matches a definition marker pattern.
   */
  static isDefinitionMarker(line) {
    return line.match(this.DEFINITION_MARKER);
  }
  /**
   * Test if a line is indented (for definition list content).
   */
  static isIndentedContent(line) {
    return this.DEFINITION_INDENTED.test(line);
  }
  /**
   * Find all example references in a text.
   */
  static findExampleReferences(text) {
    const matches = [];
    const regex = new RegExp(this.EXAMPLE_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Check if a string is a roman numeral.
   */
  static isRomanNumeral(str) {
    return this.ROMAN_NUMERALS.test(str) || this.LOWER_ROMAN_NUMERALS.test(str);
  }
  /**
   * Check if a line is any type of list item.
   */
  static isListItem(line) {
    return !!(this.isHashList(line) || this.isFancyList(line) || this.isExampleList(line) || this.isDefinitionMarker(line) || line.match(this.UNORDERED_LIST) || line.match(this.NUMBERED_LIST));
  }
  /**
   * Find all superscripts in a text.
   */
  static findSuperscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUPERSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Find all subscripts in a text.
   */
  static findSubscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUBSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
};
// Base patterns as static readonly properties
ListPatterns.HASH_LIST = /^(\s*)(#\.)(\s+)/;
ListPatterns.FANCY_LIST = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/;
ListPatterns.EXAMPLE_LIST = /^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/;
ListPatterns.EXAMPLE_REFERENCE = /\(@([a-zA-Z0-9_-]+)\)/g;
ListPatterns.DEFINITION_MARKER = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_MARKER_WITH_INDENT = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_INDENTED = /^(    |\t)/;
ListPatterns.NUMBERED_LIST = /^(\s*)([0-9]+[.)])/;
ListPatterns.UNORDERED_LIST = /^(\s*)[-*+]\s+/;
ListPatterns.CAPITAL_LETTER_LIST = /^(\s*)([A-Z])(\.)(\s+)/;
ListPatterns.ROMAN_NUMERALS = /^[IVXLCDM]+$/;
ListPatterns.LOWER_ROMAN_NUMERALS = /^[ivxlcdm]+$/;
// Superscript and subscript patterns
// Matches ^text^ for superscript and ~text~ for subscript
// Text can contain escaped spaces (\ ) but not unescaped spaces
ListPatterns.SUPERSCRIPT = /\^([^\^\s]|\\[ ])+?\^/g;
ListPatterns.SUBSCRIPT = /~([^~\s]|\\[ ])+?~/g;
// Cache for compiled patterns
ListPatterns.compiledPatterns = /* @__PURE__ */ new Map();

// src/decorations/pandocListsExtension.ts
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type, view, pos) {
    super();
    this.marker = marker;
    this.type = type;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = this.marker;
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.view.dispatch({
          selection: { anchor: this.pos }
        });
        this.view.focus();
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.marker === this.marker && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, view, pos) {
    super();
    this.number = number;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.number}) `;
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.view.dispatch({
          selection: { anchor: this.pos }
        });
        this.view.focus();
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var DefinitionBulletWidget = class extends import_view.WidgetType {
  constructor(view, pos) {
    super();
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-list-1 pandoc-list-marker";
    span.textContent = "\u2022 ";
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.view.dispatch({
          selection: { anchor: this.pos }
        });
        this.view.focus();
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, view, pos) {
    super();
    this.number = number;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `${this.number}. `;
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.view.dispatch({
          selection: { anchor: this.pos }
        });
        this.view.focus();
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var ExampleReferenceWidget = class extends import_view.WidgetType {
  constructor(number, tooltipText) {
    super();
    this.number = number;
    this.tooltipText = tooltipText;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "pandoc-example-reference";
    span.textContent = `(${this.number})`;
    if (this.tooltipText) {
      (0, import_obsidian.setTooltip)(span, this.tooltipText, { delay: 300 });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.tooltipText === this.tooltipText;
  }
};
var SuperscriptWidget = class extends import_view.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sup = document.createElement("sup");
    sup.className = CSS_CLASSES.SUPERSCRIPT;
    sup.textContent = this.content;
    return sup;
  }
  eq(other) {
    return other.content === this.content;
  }
};
var SubscriptWidget = class extends import_view.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sub = document.createElement("sub");
    sub.className = CSS_CLASSES.SUBSCRIPT;
    sub.textContent = this.content;
    return sub;
  }
  eq(other) {
    return other.content === this.content;
  }
};
var pandocListsPlugin = (getSettings) => import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.exampleLabels = /* @__PURE__ */ new Map();
      this.exampleContent = /* @__PURE__ */ new Map();
      this.exampleLineNumbers = /* @__PURE__ */ new Map();
      this.scanExampleLabels(view);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.selectionSet) {
        if (update.docChanged) {
          this.scanExampleLabels(update.view);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    isListItemForValidation(line) {
      return !!(ListPatterns.isHashList(line) || // Hash auto-numbering
      ListPatterns.isFancyList(line) || // Fancy lists
      ListPatterns.isExampleList(line) || // Example lists
      ListPatterns.isDefinitionMarker(line) || // Definition lists
      line.match(ListPatterns.UNORDERED_LIST) || // Unordered lists
      line.match(ListPatterns.NUMBERED_LIST));
    }
    scanExampleLabels(view) {
      this.exampleLabels.clear();
      this.exampleContent.clear();
      this.exampleLineNumbers.clear();
      let counter = 1;
      const docText = view.state.doc.toString();
      const lines = docText.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const match = line.match(/^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/);
        if (match) {
          const label = match[2];
          const content = match[3].trim();
          if (!this.exampleLabels.has(label)) {
            this.exampleLabels.set(label, counter);
            if (content) {
              this.exampleContent.set(label, content);
            }
          }
          this.exampleLineNumbers.set(i + 1, counter);
          counter++;
        } else {
          const unlabeledMatch = line.match(/^(\s*)\(@\)\s+/);
          if (unlabeledMatch) {
            this.exampleLineNumbers.set(i + 1, counter);
            counter++;
          }
        }
      }
    }
    validateListBlocks(lines, settings) {
      const invalidListBlocks = /* @__PURE__ */ new Set();
      if (!settings.strictPandocMode) {
        return invalidListBlocks;
      }
      let listBlockStart = -1;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isCurrentList = this.isListItemForValidation(line);
        const prevIsListOrEmpty = i > 0 && (this.isListItemForValidation(lines[i - 1]) || lines[i - 1].trim() === "");
        const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && !lines[i - 1].match(/^\s*[~:]\s+/) && !lines[i - 1].match(/^(    |\t)/) && line.match(/^\s*[~:]\s+/);
        if (isCurrentList && listBlockStart === -1) {
          listBlockStart = i;
          if (i > 0 && lines[i - 1].trim() !== "" && !prevIsDefinitionTerm) {
            for (let j = i; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
              invalidListBlocks.add(j);
            }
          }
        } else if (!isCurrentList && listBlockStart !== -1) {
          if (line.trim() !== "") {
            for (let j = listBlockStart; j < i; j++) {
              invalidListBlocks.add(j);
            }
          }
          listBlockStart = -1;
        }
        if (isCurrentList) {
          const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
          if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
            for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
              invalidListBlocks.add(j);
            }
            for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
              invalidListBlocks.add(j);
            }
          }
        }
      }
      return invalidListBlocks;
    }
    processHashList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings, hashCounter) {
      const decorations = [];
      const hashMatch = lineText.match(/^(\s*)(#\.)(\s+)/);
      if (!hashMatch) return null;
      if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
        return null;
      }
      const indent = hashMatch[1];
      const marker = hashMatch[2];
      const space = hashMatch[3];
      const markerStart = line.from + indent.length;
      const markerEnd = line.from + indent.length + marker.length + space.length;
      const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
      decorations.push({
        from: line.from,
        to: line.from,
        decoration: import_view.Decoration.line({
          class: "HyperMD-list-line HyperMD-list-line-1",
          attributes: {
            style: "text-indent: -29px; padding-inline-start: 29px;"
          }
        })
      });
      if (!cursorInMarker) {
        decorations.push({
          from: markerStart,
          to: markerEnd,
          decoration: import_view.Decoration.replace({
            widget: new HashListMarkerWidget(hashCounter.value, view, markerStart)
          })
        });
      }
      decorations.push({
        from: line.from + indent.length + marker.length + space.length,
        to: line.to,
        decoration: import_view.Decoration.mark({
          class: "cm-list-1"
        })
      });
      hashCounter.value++;
      return decorations;
    }
    processFancyList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings) {
      const decorations = [];
      const fancyMatch = lineText.match(/^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/);
      if (!fancyMatch || lineText.match(/^(\s*)([0-9]+[.)])/)) return null;
      if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
        return null;
      }
      const indent = fancyMatch[1];
      const marker = fancyMatch[2];
      const markerWithSpace = marker + fancyMatch[5];
      const markerStart = line.from + indent.length;
      const markerEnd = line.from + indent.length + markerWithSpace.length;
      const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
      decorations.push({
        from: line.from,
        to: line.from,
        decoration: import_view.Decoration.line({
          class: "HyperMD-list-line HyperMD-list-line-1",
          attributes: {
            style: `text-indent: -${markerWithSpace.length * 7}px; padding-inline-start: ${markerWithSpace.length * 7}px;`
          }
        })
      });
      if (!cursorInMarker) {
        decorations.push({
          from: markerStart,
          to: markerEnd,
          decoration: import_view.Decoration.replace({
            widget: new FancyListMarkerWidget(markerWithSpace, "fancy", view, markerStart),
            inclusive: false
          })
        });
      }
      decorations.push({
        from: line.from + indent.length + markerWithSpace.length,
        to: line.to,
        decoration: import_view.Decoration.mark({
          class: "cm-list-1"
        })
      });
      return decorations;
    }
    processExampleList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings) {
      const decorations = [];
      const exampleMatch = lineText.match(/^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/);
      if (!exampleMatch) return null;
      if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
        return null;
      }
      const indent = exampleMatch[1];
      const fullMarker = exampleMatch[2];
      const label = exampleMatch[3];
      const space = exampleMatch[4];
      const markerStart = line.from + indent.length;
      const markerEnd = line.from + indent.length + fullMarker.length + space.length;
      const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
      let exampleNumber = 1;
      if (label && this.exampleLabels.has(label)) {
        exampleNumber = this.exampleLabels.get(label);
      } else if (this.exampleLineNumbers.has(line.number)) {
        exampleNumber = this.exampleLineNumbers.get(line.number);
      }
      decorations.push({
        from: line.from,
        to: line.from,
        decoration: import_view.Decoration.line({
          class: "HyperMD-list-line HyperMD-list-line-1",
          attributes: {
            style: "text-indent: -35px; padding-inline-start: 35px;"
          }
        })
      });
      if (!cursorInMarker) {
        decorations.push({
          from: markerStart,
          to: markerEnd,
          decoration: import_view.Decoration.replace({
            widget: new ExampleListMarkerWidget(exampleNumber, view, markerStart)
          })
        });
      }
      decorations.push({
        from: line.from + indent.length + fullMarker.length + space.length,
        to: line.to,
        decoration: import_view.Decoration.mark({
          class: "cm-list-1"
        })
      });
      return decorations;
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const isLivePreview = view.state.field(import_obsidian.editorLivePreviewField);
      if (!isLivePreview) {
        return builder.finish();
      }
      const settings = getSettings();
      const lines = view.state.doc.toString().split("\n");
      const selection = view.state.selection.main;
      const cursorPos = selection.head;
      const decorations = [];
      const hashCounter = { value: 1 };
      const invalidListBlocks = this.validateListBlocks(lines, settings);
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        const lineText = line.text;
        const validationContext = {
          lines,
          currentLine: lineNum - 1
          // 0-based index
        };
        const hashDecorations = this.processHashList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings, hashCounter);
        if (hashDecorations) {
          decorations.push(...hashDecorations);
          continue;
        }
        const fancyDecorations = this.processFancyList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings);
        if (fancyDecorations) {
          decorations.push(...fancyDecorations);
          continue;
        }
        const exampleDecorations = this.processExampleList(line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings);
        if (exampleDecorations) {
          decorations.push(...exampleDecorations);
          continue;
        }
        const defItemMatch = lineText.match(/^(\s*)([~:])(\s+)/);
        if (defItemMatch) {
          if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
            continue;
          }
          const indent = defItemMatch[1];
          const marker = defItemMatch[2];
          const space = defItemMatch[3];
          const markerStart = line.from + indent.length;
          const markerEnd = line.from + indent.length + marker.length + space.length;
          const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
          if (!cursorInMarker) {
            decorations.push({
              from: markerStart,
              to: markerEnd,
              decoration: import_view.Decoration.replace({
                widget: new DefinitionBulletWidget(view, markerStart)
              })
            });
          }
        }
        const indentMatch = lineText.match(/^(    |\t)(.*)$/);
        if (indentMatch) {
          let inDefinitionContext = false;
          for (let checkLine = lineNum - 1; checkLine >= 1; checkLine--) {
            const prevLine = view.state.doc.line(checkLine);
            const prevText = prevLine.text;
            if (prevText.match(/^\s*[~:]\s+/)) {
              inDefinitionContext = true;
              break;
            }
            if (prevText.trim() && !prevText.match(/^(    |\t)/) && !prevText.match(/^\s*[~:]\s+/)) {
              break;
            }
          }
          if (inDefinitionContext) {
            const content = indentMatch[2];
            if (content && content.trim()) {
              decorations.push({
                from: line.from,
                to: line.from,
                decoration: import_view.Decoration.line({
                  class: "cm-pandoc-definition-paragraph",
                  attributes: {
                    "data-definition-content": "true"
                  }
                })
              });
              decorations.push({
                from: line.from,
                to: line.to,
                decoration: import_view.Decoration.mark({
                  class: "pandoc-definition-content-text"
                })
              });
            }
            continue;
          }
        }
        if (lineText.trim() && !lineText.match(/^\s*[~:]\s*/) && !indentMatch && !defItemMatch) {
          let isDefinitionTerm = false;
          let checkOffset = 1;
          if (line.number + 1 <= view.state.doc.lines) {
            const nextLine = view.state.doc.line(line.number + 1);
            const nextText = nextLine.text;
            if (nextText.match(/^\s*[~:]\s+/)) {
              isDefinitionTerm = true;
            } else if (nextText.trim() === "" && line.number + 2 <= view.state.doc.lines) {
              const lineAfterEmpty = view.state.doc.line(line.number + 2);
              if (lineAfterEmpty.text.match(/^\s*[~:]\s+/)) {
                isDefinitionTerm = true;
              }
            }
          }
          if (isDefinitionTerm) {
            decorations.push({
              from: line.from,
              to: line.to,
              decoration: import_view.Decoration.mark({
                class: "cm-strong cm-pandoc-definition-term"
              })
            });
          }
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let match;
        while ((match = refRegex.exec(lineText)) !== null) {
          const label = match[1];
          if (this.exampleLabels.has(label)) {
            const refStart = line.from + match.index;
            const refEnd = line.from + match.index + match[0].length;
            const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
            if (!cursorInRef) {
              const number = this.exampleLabels.get(label);
              const tooltipText = this.exampleContent.get(label);
              decorations.push({
                from: refStart,
                to: refEnd,
                decoration: import_view.Decoration.replace({
                  widget: new ExampleReferenceWidget(number, tooltipText)
                })
              });
            }
          }
        }
        const superscripts = ListPatterns.findSuperscripts(lineText);
        for (const supMatch of superscripts) {
          const supStart = line.from + supMatch.index;
          const supEnd = line.from + supMatch.index + supMatch[0].length;
          const cursorInSup = cursorPos >= supStart && cursorPos <= supEnd;
          if (!cursorInSup) {
            const content = supMatch[0].slice(1, -1).replace(/\\[ ]/g, " ");
            decorations.push({
              from: supStart,
              to: supEnd,
              decoration: import_view.Decoration.replace({
                widget: new SuperscriptWidget(content)
              })
            });
          }
        }
        const subscripts = ListPatterns.findSubscripts(lineText);
        for (const subMatch of subscripts) {
          const subStart = line.from + subMatch.index;
          const subEnd = line.from + subMatch.index + subMatch[0].length;
          const cursorInSub = cursorPos >= subStart && cursorPos <= subEnd;
          if (!cursorInSub) {
            const content = subMatch[0].slice(1, -1).replace(/\\[ ]/g, " ");
            decorations.push({
              from: subStart,
              to: subEnd,
              decoration: import_view.Decoration.replace({
                widget: new SubscriptWidget(content)
              })
            });
          }
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocListsExtension(getSettings) {
  return [
    pandocListsPlugin(getSettings),
    import_view.EditorView.baseTheme({
      ".cm-pandoc-definition-term": {
        textDecoration: "underline"
      },
      ".cm-pandoc-definition-paragraph": {
        // Don't add extra padding - indentation is already handled by spaces/tabs
        textIndent: "0 !important"
      },
      ".cm-pandoc-definition-paragraph .cm-hmd-indented-code": {
        background: "transparent !important",
        border: "none !important",
        borderRadius: "0 !important",
        padding: "0 !important",
        color: "inherit !important",
        fontFamily: "inherit !important",
        fontSize: "inherit !important"
      },
      ".pandoc-definition-content-text": {
        background: "transparent !important",
        border: "none !important",
        padding: "0 !important",
        color: "inherit !important",
        fontFamily: "inherit !important"
      },
      ".cm-pandoc-definition-paragraph .cm-indent": {
        // Keep indent visible for proper cursor positioning
        opacity: "1"
      },
      ".pandoc-example-reference": {
        color: "var(--text-accent)",
        cursor: "pointer"
      },
      ".pandoc-example-reference:hover": {
        textDecoration: "underline"
      },
      ".pandoc-superscript": {
        verticalAlign: "super",
        fontSize: "0.85em"
      },
      ".pandoc-subscript": {
        verticalAlign: "sub",
        fontSize: "0.85em"
      }
    })
  ];
}

// src/types/obsidian-extended.ts
function isMarkdownPreviewSection(element) {
  return element !== null && element.classList.contains("markdown-preview-section");
}
function getSectionInfo(element) {
  if (!isMarkdownPreviewSection(element)) {
    return null;
  }
  if (typeof element.getSection === "function") {
    try {
      return element.getSection();
    } catch (error) {
      console.warn("[PandocExtendedMarkdown] Failed to get section info:", error);
      return null;
    }
  }
  return null;
}

// src/parsers/fancyListParser.ts
var ROMAN_UPPER = /^[IVXLCDM]+$/;
var ROMAN_LOWER = /^[ivxlcdm]+$/;
var ALPHA_UPPER = /^[A-Z]+$/;
var ALPHA_LOWER = /^[a-z]+$/;
var DECIMAL = /^[0-9]+$/;
function parseFancyListMarker(line) {
  const match = ListPatterns.isFancyList(line);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (value === "#") {
    type = "hash";
  } else if (DECIMAL.test(value)) {
    return null;
  } else if (ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
var import_obsidian2 = require("obsidian");
function parseExampleListMarker(line) {
  const match = ListPatterns.isExampleList(line);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3]
  };
}

// src/parsers/superSubParser.ts
function extractContent(match, delimiter) {
  const content = match.slice(1, -1);
  return content.replace(/\\[ ]/g, " ");
}
function findSuperSubInText(text) {
  const matches = [];
  const superscripts = ListPatterns.findSuperscripts(text);
  superscripts.forEach((match) => {
    matches.push({
      index: match.index,
      length: match[0].length,
      content: extractContent(match[0], "^"),
      type: "superscript"
    });
  });
  const subscripts = ListPatterns.findSubscripts(text);
  subscripts.forEach((match) => {
    matches.push({
      index: match.index,
      length: match[0].length,
      content: extractContent(match[0], "~"),
      type: "subscript"
    });
  });
  matches.sort((a, b) => a.index - b.index);
  return matches;
}
function processSuperSub(element) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (parent && (parent.classList.contains(CSS_CLASSES.SUPERSCRIPT) || parent.classList.contains(CSS_CLASSES.SUBSCRIPT))) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );
  const nodesToReplace = [];
  while (walker.nextNode()) {
    const node = walker.currentNode;
    const text = node.textContent || "";
    const matches = findSuperSubInText(text);
    if (matches.length > 0) {
      nodesToReplace.push({ node, matches });
    }
  }
  nodesToReplace.forEach(({ node, matches }) => {
    const parent = node.parentNode;
    if (!parent) return;
    let lastIndex = 0;
    const fragments = [];
    matches.forEach((match) => {
      if (match.index > lastIndex) {
        fragments.push(node.textContent.substring(lastIndex, match.index));
      }
      const elem = match.type === "superscript" ? document.createElement("sup") : document.createElement("sub");
      elem.className = match.type === "superscript" ? CSS_CLASSES.SUPERSCRIPT : CSS_CLASSES.SUBSCRIPT;
      elem.textContent = match.content;
      fragments.push(elem);
      lastIndex = match.index + match.length;
    });
    if (lastIndex < node.textContent.length) {
      fragments.push(node.textContent.substring(lastIndex));
    }
    fragments.forEach((fragment) => {
      if (typeof fragment === "string") {
        parent.insertBefore(document.createTextNode(fragment), node);
      } else {
        parent.insertBefore(fragment, node);
      }
    });
    parent.removeChild(node);
  });
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(/^([^\n:~]+)$/);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(ListPatterns.NUMBERED_LIST)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = ListPatterns.isDefinitionMarker(line);
  if (defMatch) {
    const content = line.substring(defMatch[0].length);
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content
    };
  }
  return null;
}

// src/pandocValidator.ts
function isStrictPandocList(context, strictMode) {
  if (!strictMode) {
    return true;
  }
  const { lines, currentLine } = context;
  const line = lines[currentLine];
  const isPartOfListBlock = currentLine > 0 && isListItem(lines[currentLine - 1]);
  if (currentLine > 0 && !isPartOfListBlock) {
    const prevLine = lines[currentLine - 1];
    if (prevLine.trim() !== "") {
      return false;
    }
  }
  const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
  if (capitalLetterMatch && capitalLetterMatch[3] === ".") {
    if (capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      return false;
    }
  }
  let isLastItemInList = true;
  if (currentLine < lines.length - 1) {
    const nextLine = lines[currentLine + 1];
    const nextIsListItem = isListItem(nextLine);
    if (!nextIsListItem && nextLine.trim() !== "") {
      return false;
    }
    if (nextIsListItem) {
      isLastItemInList = false;
    }
  }
  return true;
}
function isListItem(line) {
  const patterns = [
    /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|[0-9]+|#)([.)]))(\s+)/,
    // Fancy lists
    /^(\s*)\d+\.\s+/,
    // Standard ordered lists (1. 2. 3. etc.)
    /^(\s*)[-*+]\s+/,
    // Unordered lists
    /^(\s*)\(@([a-zA-Z0-9_-]*)\)\s+/,
    // Example lists
    /^(\s*)[~:]\s+/
    // Definition lists
  ];
  return patterns.some((pattern) => pattern.test(line));
}
function formatToPandocStandard(content) {
  const lines = content.split("\n");
  const result = [];
  let inListBlock = false;
  let lastWasEmpty = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line);
    const isCurrentLineHeading = line.match(/^#{1,6}\s+/) !== null;
    const isEmpty = line.trim() === "";
    if (isCurrentLineList && !inListBlock) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      inListBlock = true;
    }
    if (!isCurrentLineList && !isEmpty && inListBlock) {
      if (!lastWasEmpty) {
        result.push("");
      }
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      let formattedLine = line;
      result.push(formattedLine);
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        result.push("");
        lastWasEmpty = true;
      } else {
        lastWasEmpty = false;
      }
      continue;
    }
    const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
    if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      const formattedLine = line.replace(/^(\s*)([A-Z]\.)(\s+)/, "$1$2  ");
      result.push(formattedLine);
    } else {
      result.push(line);
    }
    lastWasEmpty = isEmpty;
  }
  const cleanedResult = [];
  let prevWasEmpty = false;
  for (const line of result) {
    if (line.trim() === "") {
      if (!prevWasEmpty) {
        cleanedResult.push(line);
        prevWasEmpty = true;
      }
    } else {
      cleanedResult.push(line);
      prevWasEmpty = false;
    }
  }
  return cleanedResult.join("\n");
}
function checkPandocFormatting(content) {
  const lines = content.split("\n");
  const issues = [];
  let inListBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line);
    const isCurrentLineHeading = line.match(/^#{1,6}\s+/) !== null;
    const isEmpty = line.trim() === "";
    if (isCurrentLineList) {
      if (!inListBlock && i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "List should have an empty line before it"
        });
      }
      const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
      if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
        issues.push({
          line: i + 1,
          message: "Capital letter list with period requires at least 2 spaces after marker"
        });
      }
      inListBlock = true;
    } else if (!isEmpty && inListBlock) {
      if (i > 0 && isListItem(lines[i - 1])) {
        issues.push({
          line: i,
          message: "List should have an empty line after it"
        });
      }
      inListBlock = false;
    } else if (isEmpty) {
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line before it"
        });
      }
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line after it"
        });
      }
    }
  }
  return issues;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context, settings) {
  const elementsToProcess = element.querySelectorAll("p, li");
  const section = element.closest(".markdown-preview-section");
  const sectionInfo = getSectionInfo(section);
  let fullText = "";
  let lines = [];
  if (sectionInfo == null ? void 0 : sectionInfo.text) {
    fullText = sectionInfo.text;
    lines = fullText.split("\n");
  } else {
    fullText = element.textContent || "";
    lines = fullText.split("\n");
  }
  const exampleMap = /* @__PURE__ */ new Map();
  let exampleCounter = 1;
  elementsToProcess.forEach((elem) => {
    const text = elem.textContent || "";
    const lines2 = text.split("\n");
    lines2.forEach((line) => {
      const exampleInfo = parseExampleListMarker(line);
      if (exampleInfo) {
        if (exampleInfo.label && !exampleMap.has(exampleInfo.label)) {
          exampleMap.set(exampleInfo.label, exampleCounter);
          exampleCounter++;
        } else if (!exampleInfo.label) {
          exampleCounter++;
        }
      }
    });
  });
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    const walker = document.createTreeWalker(
      elem,
      NodeFilter.SHOW_TEXT,
      null
    );
    const nodesToProcess = [];
    while (walker.nextNode()) {
      nodesToProcess.push(walker.currentNode);
    }
    nodesToProcess.forEach((node) => {
      const parent = node.parentNode;
      if (!parent) return;
      if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
        return;
      }
      const text = node.textContent || "";
      const hasCustomSyntax = ListPatterns.isFancyList(text) || ListPatterns.isExampleList(text) || ListPatterns.isDefinitionMarker(text) || ListPatterns.findExampleReferences(text).length > 0;
      if (!hasCustomSyntax) {
        return;
      }
      const lines2 = text.split("\n");
      const newElements = [];
      lines2.forEach((line, lineIndex) => {
        if (lineIndex > 0) {
          newElements.push(document.createTextNode("\n"));
        }
        let isDefinitionTerm = false;
        if (lineIndex < lines2.length - 1) {
          const nextLine = lines2[lineIndex + 1];
          if (nextLine && ListPatterns.isDefinitionMarker(nextLine)) {
            isDefinitionTerm = true;
          }
        }
        const fancyMarker = parseFancyListMarker(line);
        if (fancyMarker) {
          if (settings.strictPandocMode && lines2.length > 0) {
            let lineNum = -1;
            for (let i = 0; i < lines2.length; i++) {
              if (lines2[i].includes(line.trim())) {
                lineNum = i;
                break;
              }
            }
            if (lineNum >= 0) {
              const validationContext = {
                lines: lines2,
                currentLine: lineNum
              };
              if (!isStrictPandocList(validationContext, settings.strictPandocMode)) {
                newElements.push(document.createTextNode(line));
                return;
              }
            }
          }
          const span = document.createElement("span");
          span.className = `${CSS_CLASSES.FANCY_LIST}-${fancyMarker.type}`;
          span.textContent = fancyMarker.marker + " ";
          newElements.push(span);
          const rest = line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const exampleMarker = parseExampleListMarker(line);
        if (exampleMarker) {
          let number = 1;
          if (exampleMarker.label && exampleMap.has(exampleMarker.label)) {
            number = exampleMap.get(exampleMarker.label);
          }
          const span = document.createElement("span");
          span.className = CSS_CLASSES.EXAMPLE_LIST;
          span.textContent = `(${number}) `;
          newElements.push(span);
          const rest = line.substring(exampleMarker.indent.length + exampleMarker.originalMarker.length + 1);
          if (rest) {
            newElements.push(document.createTextNode(rest));
          }
          return;
        }
        const defMarker = parseDefinitionListMarker(line);
        if (defMarker && defMarker.type === "definition") {
          const span = document.createElement("span");
          span.textContent = "\u2022 ";
          newElements.push(span);
          newElements.push(document.createTextNode(defMarker.content));
          return;
        } else if (isDefinitionTerm && line.trim() && !ListPatterns.isDefinitionMarker(line)) {
          const strong = document.createElement("strong");
          const u = document.createElement("u");
          u.textContent = line;
          strong.appendChild(u);
          newElements.push(strong);
          return;
        }
        const refRegex = /\(@([a-zA-Z0-9_-]+)\)/g;
        let lastIndex = 0;
        let match;
        let hasReferences = false;
        while ((match = refRegex.exec(line)) !== null) {
          hasReferences = true;
          if (match.index > lastIndex) {
            newElements.push(document.createTextNode(line.substring(lastIndex, match.index)));
          }
          const label = match[1];
          if (exampleMap.has(label)) {
            const span = document.createElement("span");
            span.className = CSS_CLASSES.EXAMPLE_REF;
            span.textContent = `(${exampleMap.get(label)})`;
            newElements.push(span);
          } else {
            newElements.push(document.createTextNode(match[0]));
          }
          lastIndex = match.index + match[0].length;
        }
        if (hasReferences && lastIndex < line.length) {
          newElements.push(document.createTextNode(line.substring(lastIndex)));
        } else if (!hasReferences) {
          newElements.push(document.createTextNode(line));
        }
      });
      if (newElements.length > 0) {
        newElements.forEach((elem2) => {
          parent.insertBefore(elem2, node);
        });
        parent.removeChild(node);
      }
    });
  });
  processSuperSub(element);
}

// src/ExampleReferenceSuggestFixed.ts
var import_obsidian3 = require("obsidian");
var ExampleReferenceSuggestFixed = class extends import_obsidian3.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = [...line.matchAll(/\(@/g)];
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = ListPatterns.isExampleList(line);
      if (match) {
        const label = match[1];
        const text = match[2].trim();
        if (!exampleData.has(label)) {
          exampleData.set(label, { number: counter, text });
        }
        counter++;
      } else if (ListPatterns.isExampleList(line)) {
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/settings.ts
var import_obsidian4 = require("obsidian");
var DEFAULT_SETTINGS = {
  strictPandocMode: false,
  autoRenumberLists: false
};
var PandocExtendedMarkdownSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Pandoc Extended Markdown Settings" });
    new import_obsidian4.Setting(containerEl).setName("Strict pandoc mode").setDesc("Enable strict pandoc formatting requirements. When enabled, lists must have empty lines before and after them, and capital letter lists require double spacing after markers.").addToggle((toggle) => toggle.setValue(this.plugin.settings.strictPandocMode).onChange(async (value) => {
      this.plugin.settings.strictPandocMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian4.Setting(containerEl).setName("Auto-renumber lists").setDesc("Automatically renumber all list items when inserting a new item. This ensures proper sequential ordering of fancy lists (A, B, C... or i, ii, iii...) when you add items in the middle of a list.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRenumberLists).onChange(async (value) => {
      this.plugin.settings.autoRenumberLists = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/listAutocompletion.ts
var import_state2 = require("@codemirror/state");
function getNextLetter(letter) {
  if (letter === "Z" || letter === "z") {
    return null;
  }
  return String.fromCharCode(letter.charCodeAt(0) + 1);
}
function numberToLetter(num, isUpperCase) {
  const letter = String.fromCharCode("A".charCodeAt(0) + num - 1);
  return isUpperCase ? letter : letter.toLowerCase();
}
function romanToInt(roman) {
  const romanValues = {
    "i": 1,
    "iv": 4,
    "v": 5,
    "ix": 9,
    "x": 10,
    "xl": 40,
    "l": 50,
    "xc": 90,
    "c": 100,
    "cd": 400,
    "d": 500,
    "cm": 900,
    "m": 1e3,
    "I": 1,
    "IV": 4,
    "V": 5,
    "IX": 9,
    "X": 10,
    "XL": 40,
    "L": 50,
    "XC": 90,
    "C": 100,
    "CD": 400,
    "D": 500,
    "CM": 900,
    "M": 1e3
  };
  let value = 0;
  let i = 0;
  const normalizedRoman = roman.toLowerCase();
  while (i < normalizedRoman.length) {
    if (i + 1 < normalizedRoman.length && romanValues[normalizedRoman.substring(i, i + 2)]) {
      value += romanValues[normalizedRoman.substring(i, i + 2)];
      i += 2;
    } else {
      value += romanValues[normalizedRoman[i]] || 0;
      i++;
    }
  }
  return value;
}
function intToRoman(num, isUpperCase) {
  const intToRomanUpper = [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ];
  const intToRomanLower = [
    [1e3, "m"],
    [900, "cm"],
    [500, "d"],
    [400, "cd"],
    [100, "c"],
    [90, "xc"],
    [50, "l"],
    [40, "xl"],
    [10, "x"],
    [9, "ix"],
    [5, "v"],
    [4, "iv"],
    [1, "i"]
  ];
  let result = "";
  const table = isUpperCase ? intToRomanUpper : intToRomanLower;
  for (const [value, sym] of table) {
    while (num >= value) {
      result += sym;
      num -= value;
    }
  }
  return result;
}
function getNextRoman(roman) {
  const value = romanToInt(roman);
  const isUpperCase = roman[0] === roman[0].toUpperCase();
  return intToRoman(value + 1, isUpperCase);
}
function getNextListMarker(currentLine, allLines, currentLineIndex) {
  const hashMatch = ListPatterns.isHashList(currentLine);
  if (hashMatch) {
    return { marker: "#.", indent: hashMatch[1], spaces: hashMatch[3] };
  }
  const listMatch = currentLine.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/);
  if (listMatch) {
    const indent = listMatch[1];
    const marker = listMatch[2];
    const punctuation = listMatch[3];
    const spaces = listMatch[4];
    let isRoman = false;
    if (marker.length > 1 && marker.match(/^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i)) {
      isRoman = true;
    } else if (marker.length === 1 && allLines && currentLineIndex !== void 0) {
      if (marker.match(/^[Ii]$/)) {
        isRoman = true;
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/)) break;
          const prevMatch = prevLine.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.match(/^[Hh]$/)) {
              isRoman = false;
              break;
            } else if (prevMarker.length > 1 && prevMarker.match(/^[ivxlcdmIVXLCDM]+$/i)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(/^[ivxlcdmIVXLCDM]+$/i)) {
              isRoman = false;
              break;
            }
          }
        }
      } else {
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/)) break;
          const prevMatch = prevLine.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.length > 1 && prevMarker.match(/^[ivxlcdmIVXLCDM]+$/i)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(/^[ivxlcdmIVXLCDM]+$/i)) {
              isRoman = false;
              break;
            } else if (prevMarker.match(/^[ABab]$/)) {
              isRoman = false;
              break;
            }
          }
        }
      }
    }
    if (isRoman) {
      if (marker.match(/^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i)) {
        const nextRoman = getNextRoman(marker);
        return { marker: `${nextRoman}${punctuation}`, indent, spaces };
      }
    } else {
      const nextLetter = getNextLetter(marker);
      if (nextLetter) {
        return { marker: `${nextLetter}${punctuation}`, indent, spaces };
      }
      return null;
    }
  }
  const exampleMatch = currentLine.match(/^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s+)/);
  if (exampleMatch) {
    const indent = exampleMatch[1];
    const spaces = exampleMatch[3];
    return { marker: "(@)", indent, spaces };
  }
  const definitionMatch = currentLine.match(/^(\s*)([~:])(\s+)/);
  if (definitionMatch) {
    const indent = definitionMatch[1];
    const marker = definitionMatch[2];
    const spaces = definitionMatch[3];
    return { marker, indent, spaces };
  }
  return null;
}
function renumberListItems(view, insertedLineNum) {
  const state = view.state;
  const doc = state.doc;
  const allLines = doc.toString().split("\n");
  let blockStart = insertedLineNum;
  let blockEnd = insertedLineNum;
  const insertedLine = allLines[insertedLineNum];
  const insertedIndentMatch = insertedLine.match(/^(\s*)/);
  const insertedIndent = insertedIndentMatch ? insertedIndentMatch[1] : "";
  for (let i = insertedLineNum - 1; i >= 0; i--) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)/);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockStart = i;
    }
  }
  for (let i = insertedLineNum + 1; i < allLines.length; i++) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)/);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockEnd = i;
    }
  }
  const listItems = [];
  for (let i = blockStart; i <= blockEnd; i++) {
    const line = allLines[i];
    const listMatch = line.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)(.*)$/);
    if (listMatch && listMatch[1] === insertedIndent) {
      const marker = listMatch[2];
      const punctuation = listMatch[3];
      const spaces = listMatch[4];
      const content = listMatch[5];
      let isRoman = false;
      let isAlpha = false;
      if (marker === "#") {
      } else if (marker.match(/^[A-Za-z]+$/)) {
        if (marker.length > 1 && marker.match(/^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i)) {
          isRoman = true;
        } else if (marker.length === 1 && marker.match(/^[IVXLCDM]$/i)) {
          if (i === blockStart) {
            isRoman = marker.match(/^[Ii]$/) !== null;
            if (!isRoman) {
              isAlpha = true;
            }
          } else {
            isRoman = listItems.length > 0 && listItems[0].isRoman;
            isAlpha = listItems.length > 0 && listItems[0].isAlpha;
          }
        } else {
          isAlpha = true;
        }
      }
      listItems.push({
        lineNum: i,
        marker,
        punctuation,
        spaces,
        content,
        isRoman,
        isAlpha
      });
    }
  }
  if (listItems.length > 1) {
    const changes = [];
    let currentValue = 1;
    const firstItem = listItems[0];
    for (let i = 0; i < listItems.length; i++) {
      const item = listItems[i];
      let newMarker;
      if (item.marker === "#") {
        newMarker = "#";
      } else if (item.isRoman) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = intToRoman(i + 1, isUpperCase);
      } else if (item.isAlpha) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = numberToLetter(i + 1, isUpperCase);
      } else {
        newMarker = item.marker;
      }
      const newLine = `${insertedIndent}${newMarker}${item.punctuation}${item.spaces}${item.content}`;
      const oldLine = allLines[item.lineNum];
      if (newLine !== oldLine) {
        const lineStartPos = doc.line(item.lineNum + 1).from;
        const lineEndPos = doc.line(item.lineNum + 1).to;
        changes.push({
          from: lineStartPos,
          to: lineEndPos,
          insert: newLine
        });
      }
    }
    if (changes.length > 0) {
      const transaction = state.update({ changes });
      view.dispatch(transaction);
    }
  }
}
function isEmptyListItem(line) {
  if (line.match(/^(\s*)(#\.)(\s*)$/)) return true;
  if (line.match(/^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s*)$/)) return true;
  if (line.match(/^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)$/)) return true;
  if (line.match(/^(\s*)([~:])(\s*)$/)) return true;
  return false;
}
function createListAutocompletionKeymap(settings) {
  const handleListEnter = {
    key: "Enter",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      if (selection.from !== line.to || selection.from !== selection.to) {
        return false;
      }
      const lineText = line.text;
      if (lineText.match(/^\s*\d+[.)]\s/)) {
        return false;
      }
      if (isEmptyListItem(lineText)) {
        const indentMatch = lineText.match(/^(\s+)/);
        if (indentMatch && indentMatch[1].length >= INDENTATION.TAB_SIZE) {
          const currentIndent = indentMatch[1];
          let newIndent = "";
          if (currentIndent.startsWith(INDENTATION.FOUR_SPACES)) {
            newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
          } else if (currentIndent.startsWith(INDENTATION.TAB)) {
            newIndent = currentIndent.substring(1);
          } else {
            newIndent = currentIndent.substring(Math.min(INDENTATION.TAB_SIZE, currentIndent.length));
          }
          let previousMarker = null;
          for (let i = line.number - 1; i >= 1; i--) {
            const prevLine = state.doc.line(i);
            const prevText = prevLine.text;
            const prevIndentMatch = prevText.match(/^(\s*)/);
            if (prevIndentMatch && prevIndentMatch[1] === newIndent) {
              const allLines2 = state.doc.toString().split("\n");
              const markerInfo2 = getNextListMarker(prevText, allLines2, i - 1);
              if (markerInfo2) {
                previousMarker = markerInfo2;
                break;
              }
            }
          }
          if (previousMarker && newIndent.length > 0) {
            const spaces = previousMarker.spaces || " ";
            const newLine = `${newIndent}${previousMarker.marker}${spaces}`;
            const changes2 = {
              from: line.from,
              to: line.to,
              insert: newLine
            };
            const transaction2 = state.update({
              changes: changes2,
              selection: import_state2.EditorSelection.cursor(line.from + newLine.length)
            });
            view.dispatch(transaction2);
            return true;
          }
        }
        const changes = {
          from: line.from,
          to: line.to,
          insert: ""
        };
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from)
        });
        view.dispatch(transaction);
        return true;
      }
      const allLines = state.doc.toString().split("\n");
      const currentLineIndex = line.number - 1;
      const markerInfo = getNextListMarker(lineText, allLines, currentLineIndex);
      if (markerInfo) {
        const spaces = markerInfo.spaces || " ";
        const newLine = `
${markerInfo.indent}${markerInfo.marker}${spaces}`;
        const changes = {
          from: selection.from,
          to: selection.to,
          insert: newLine
        };
        const cursorOffset = markerInfo.marker === "(@)" ? newLine.length - spaces.length - 1 : newLine.length;
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(selection.from + cursorOffset)
        });
        view.dispatch(transaction);
        if (settings.autoRenumberLists && markerInfo.marker !== "(@)" && markerInfo.marker !== "#." && !markerInfo.marker.match(/^[~:]$/)) {
          const newLineNum = line.number;
          setTimeout(() => {
            renumberListItems(view, newLineNum);
          }, 0);
        }
        return true;
      }
      return false;
    }
  };
  const handleListTab = {
    key: "Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(/^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|@\([a-zA-Z0-9_-]*\)|[~:])(\s+)/);
      if (listMatch) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        if (selection.from === line.from + markerEnd && selection.to === selection.from) {
          const newIndent = currentIndent + INDENTATION.FOUR_SPACES;
          const newLine = newIndent + marker + space + lineText.substring(markerEnd);
          const changes = {
            from: line.from,
            to: line.to,
            insert: newLine
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + newIndent.length + marker.length + space.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      return false;
    }
  };
  const handleListShiftTab = {
    key: "Shift-Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(/^(\s+)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|@\([a-zA-Z0-9_-]*\)|[~:])(\s+)/);
      if (listMatch && listMatch[1].length > 0) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        let newIndent = "";
        if (currentIndent.startsWith("    ")) {
          newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
        } else if (currentIndent.startsWith("	")) {
          newIndent = currentIndent.substring(1);
        } else {
          newIndent = currentIndent.substring(Math.min(4, currentIndent.length));
        }
        const newLine = newIndent + marker + space + lineText.substring(markerEnd);
        const changes = {
          from: line.from,
          to: line.to,
          insert: newLine
        };
        const oldCursorOffset = selection.from - line.from;
        const indentDiff = currentIndent.length - newIndent.length;
        const newCursorOffset = Math.max(newIndent.length + marker.length + space.length, oldCursorOffset - indentDiff);
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from + newCursorOffset)
        });
        view.dispatch(transaction);
        return true;
      }
      return false;
    }
  };
  return [
    handleListEnter,
    handleListTab,
    handleListShiftTab
  ];
}

// src/main.ts
var PandocExtendedMarkdownPlugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PandocExtendedMarkdownSettingTab(this.app, this));
    this.registerEditorExtension(pandocListsExtension(() => this.settings));
    this.registerEditorExtension(import_state3.Prec.highest(import_view2.keymap.of(createListAutocompletionKeymap(this.settings))));
    this.registerMarkdownPostProcessor((element, context) => {
      processReadingMode(element, context, this.settings);
    });
    this.suggester = new ExampleReferenceSuggestFixed(this);
    this.registerEditorSuggest(this.suggester);
    this.addCommand({
      id: COMMANDS.CHECK_PANDOC,
      name: "Check pandoc formatting",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const issues = checkPandocFormatting(content);
        if (issues.length === 0) {
          new import_obsidian5.Notice(MESSAGES.PANDOC_COMPLIANT);
        } else {
          const issueList = issues.map(
            (issue) => `Line ${issue.line}: ${issue.message}`
          ).join("\n");
          new import_obsidian5.Notice(`${MESSAGES.FORMATTING_ISSUES(issues.length)}:
${issueList}`, 1e4);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.FORMAT_PANDOC,
      name: "Format document to pandoc standard",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const formatted = formatToPandocStandard(content);
        if (content !== formatted) {
          editor.setValue(formatted);
          new import_obsidian5.Notice(MESSAGES.FORMAT_SUCCESS);
        } else {
          new import_obsidian5.Notice(MESSAGES.FORMAT_ALREADY_COMPLIANT);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_BOLD,
      name: "Toggle definition list bold style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionBoldStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian5.Notice(MESSAGES.TOGGLE_BOLD_SUCCESS);
        } else {
          new import_obsidian5.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  toggleDefinitionBoldStyle(content) {
    var _a;
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const definitionTerms = [];
    let anyHasBold = false;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      let isDefinitionTerm = false;
      if (i + 1 < lines.length) {
        const nextLine = lines[i + 1].trim();
        if (ListPatterns.isDefinitionMarker(nextLine)) {
          isDefinitionTerm = true;
        } else if (nextLine === "" && i + 2 < lines.length) {
          const lineAfterEmpty = lines[i + 2].trim();
          if (ListPatterns.isDefinitionMarker(lineAfterEmpty)) {
            isDefinitionTerm = true;
          }
        }
      }
      if (isDefinitionTerm) {
        const boldRegex = /^\*\*(.+)\*\*$/;
        const hasBold = boldRegex.test(trimmedLine);
        definitionTerms.push({ index: i, hasBold });
        if (hasBold) {
          anyHasBold = true;
        }
      }
    }
    for (const term of definitionTerms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ((_a = line.match(/^(\s*)/)) == null ? void 0 : _a[1]) || "";
      const boldRegex = /^\*\*(.+)\*\*$/;
      if (anyHasBold) {
        const match = trimmedLine.match(boldRegex);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!boldRegex.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + "**" + trimmedLine + "**";
        }
      }
    }
    return modifiedLines.join("\n");
  }
};
