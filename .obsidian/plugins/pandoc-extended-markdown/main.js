/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  PandocExtendedMarkdownPlugin: () => PandocExtendedMarkdownPlugin,
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");
var import_state3 = require("@codemirror/state");
var import_view11 = require("@codemirror/view");

// src/settings.ts
var import_obsidian = require("obsidian");

// src/types/settingsTypes.ts
var DEFAULT_SETTINGS = {
  strictPandocMode: false,
  autoRenumberLists: false,
  moreExtendedSyntax: false
};

// src/settings.ts
var PandocExtendedMarkdownSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Strict Pandoc mode").setDesc("Enable strict pandoc formatting requirements. When enabled, lists must have empty lines before and after them, and capital letter lists require double spacing after markers.").addToggle((toggle) => toggle.setValue(this.plugin.settings.strictPandocMode).onChange(async (value) => {
      this.plugin.settings.strictPandocMode = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-renumber lists").setDesc("Automatically renumber all list items when inserting a new item. This ensures proper sequential ordering of fancy lists (A, B, C... or i, ii, iii...) when you add items in the middle of a list.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoRenumberLists).onChange(async (value) => {
      this.plugin.settings.autoRenumberLists = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom Label List").setDesc("Should use it together with CustomLabelList.lua to enhance pandoc output. Enables custom label lists using {::LABEL} syntax. When strict pandoc mode is enabled, custom label lists must be preceded and followed by blank lines.").addToggle((toggle) => toggle.setValue(this.plugin.settings.moreExtendedSyntax).onChange(async (value) => {
      this.plugin.settings.moreExtendedSyntax = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/types/processorConfig.ts
function createProcessorConfig(vaultConfig, pluginSettings) {
  var _a, _b, _c;
  const moreExtendedSyntax = (_a = pluginSettings.moreExtendedSyntax) != null ? _a : false;
  return {
    strictLineBreaks: (_b = vaultConfig.strictLineBreaks) != null ? _b : false,
    strictPandocMode: (_c = pluginSettings.strictPandocMode) != null ? _c : false,
    moreExtendedSyntax,
    enableHashLists: true,
    enableFancyLists: true,
    enableExampleLists: true,
    enableDefinitionLists: true,
    enableSuperSubscripts: true,
    enableCustomLabelLists: moreExtendedSyntax
  };
}

// src/constants.ts
var INDENTATION = {
  TAB_SIZE: 4,
  MIN_INDENT: 0,
  MAX_INDENT: 40,
  SINGLE_SPACE: 1,
  DOUBLE_SPACE: 2,
  TAB: "	",
  FOUR_SPACES: "    "
};
var CSS_CLASSES = {
  // Fancy List Classes
  FANCY_LIST: "pandoc-list-fancy",
  FANCY_LIST_UPPER_ALPHA: "pandoc-list-upper-alpha",
  FANCY_LIST_LOWER_ALPHA: "pandoc-list-lower-alpha",
  FANCY_LIST_UPPER_ROMAN: "pandoc-list-upper-roman",
  FANCY_LIST_LOWER_ROMAN: "pandoc-list-lower-roman",
  FANCY_LIST_PAREN: "pandoc-list-paren",
  // Definition List Classes
  DEFINITION_LIST: "pandoc-definition-list",
  DEFINITION_TERM: "pandoc-definition-term",
  DEFINITION_DESC: "pandoc-list-definition-desc",
  DEFINITION_ITEMS: "pandoc-definition-items",
  DEFINITION_CONTENT_TEXT: "pandoc-definition-content-text",
  // Example List Classes
  EXAMPLE_REF: "pandoc-example-reference",
  EXAMPLE_LIST: "pandoc-example-list",
  EXAMPLE_ITEM: "pandoc-example-item",
  DUPLICATE_MARKERS: "pandoc-duplicate-markers",
  // Superscript and Subscript Classes
  SUPERSCRIPT: "pandoc-superscript",
  SUBSCRIPT: "pandoc-subscript",
  // Suggestion Classes
  SUGGESTION_CONTENT: "pandoc-suggestion-content",
  SUGGESTION_TITLE: "pandoc-suggestion-title",
  SUGGESTION_PREVIEW: "pandoc-suggestion-preview",
  SUGGESTION_NUMBER: "pandoc-suggestion-number",
  SUGGESTION_PLACEHOLDER: "pandoc-suggestion-placeholder",
  // CodeMirror Classes
  LIST_LINE: "HyperMD-list-line",
  LIST_LINE_1: "HyperMD-list-line-1",
  CM_LIST_1: "cm-list-1",
  CM_FORMATTING: "cm-formatting",
  CM_FORMATTING_LIST: "cm-formatting-list",
  CM_FORMATTING_LIST_OL: "cm-formatting-list-ol",
  LIST_NUMBER: "list-number",
  DEFINITION_TERM_DECORATION: "cm-pandoc-definition-term",
  DEFINITION_PARAGRAPH: "cm-pandoc-definition-paragraph",
  // Generic Classes
  PANDOC_LIST_MARKER: "pandoc-list-marker",
  PANDOC_LIST_LINE_INDENT: "pandoc-list-line-indent",
  // Custom Label Classes
  CUSTOM_LABEL_PROCESSED: "pandoc-custom-label-processed",
  CUSTOM_LABEL_ITEM: "pandoc-custom-label-item",
  CUSTOM_LABEL_REFERENCE_PROCESSED: "pandoc-custom-label-reference-processed",
  CUSTOM_LABEL_REF_CLICKABLE: "pandoc-custom-label-ref-clickable",
  CUSTOM_LABEL_PLACEHOLDER: "pandoc-custom-label-placeholder",
  INLINE_PLACEHOLDER_NUMBER: "pandoc-inline-placeholder-number",
  // Custom Label View Classes
  CUSTOM_LABEL_VIEW_CONTAINER: "custom-label-view-container",
  CUSTOM_LABEL_VIEW_HEADER: "custom-label-view-header",
  CUSTOM_LABEL_VIEW_HEADER_LABEL: "custom-label-view-header-label",
  CUSTOM_LABEL_VIEW_HEADER_CONTENT: "custom-label-view-header-content",
  CUSTOM_LABEL_VIEW_ROW: "custom-label-view-row",
  CUSTOM_LABEL_VIEW_LABEL: "custom-label-view-label",
  CUSTOM_LABEL_VIEW_CONTENT: "custom-label-view-content",
  CUSTOM_LABEL_VIEW_EMPTY: "custom-label-view-empty",
  CUSTOM_LABEL_HOVER_PREVIEW: "custom-label-hover-preview",
  CUSTOM_LABEL_HIGHLIGHT: "custom-label-highlight",
  // Hover popover styles
  HOVER_POPOVER: "pandoc-hover-popover",
  HOVER_POPOVER_LABEL: "pandoc-hover-popover-label",
  HOVER_POPOVER_CONTENT: "pandoc-hover-popover-content"
};
var DECORATION_STYLES = {
  HASH_LIST_INDENT: 29,
  EXAMPLE_LIST_INDENT: 35,
  FANCY_LIST_INDENT_MULTIPLIER: 7,
  LINE_TRUNCATION_LIMIT: 100,
  TOOLTIP_DELAY_MS: 300,
  CUSTOM_LABEL_PREFIX_LENGTH: 3
  // Length of "{::" prefix
};
var MESSAGES = {
  // Success messages
  FORMAT_SUCCESS: "Document formatted to pandoc standard",
  FORMAT_ALREADY_COMPLIANT: "Document already follows pandoc standard",
  PANDOC_COMPLIANT: "Document follows pandoc formatting standards",
  TOGGLE_BOLD_SUCCESS: "Definition terms bold style toggled",
  TOGGLE_UNDERLINE_SUCCESS: "Definition terms underline style toggled",
  LABEL_COPIED: "Label copied to clipboard",
  // Error messages
  NO_DEFINITION_TERMS: "No definition terms found to toggle",
  // View messages
  NO_ACTIVE_FILE: "No active file",
  NO_CUSTOM_LABELS: "No custom labels found",
  CUSTOM_LABELS_VIEW_TITLE: "Custom Labels",
  // Formatting issue messages
  FORMATTING_ISSUES: (count) => `Found ${count} formatting issues`
};
var COMMANDS = {
  CHECK_PANDOC: "check-pandoc-formatting",
  FORMAT_PANDOC: "format-to-pandoc-standard",
  TOGGLE_DEFINITION_BOLD: "toggle-definition-bold-style",
  TOGGLE_DEFINITION_UNDERLINE: "toggle-definition-underline-style",
  OPEN_CUSTOM_LABEL_VIEW: "open-custom-label-view"
};
var UI_CONSTANTS = {
  NOTICE_DURATION_MS: 1e4,
  STATE_TRANSITION_DELAY_MS: 100,
  // Custom Label View
  LABEL_MAX_LENGTH: 6,
  LABEL_TRUNCATION_LENGTH: 5,
  // Length before adding ellipsis
  CONTENT_MAX_LENGTH: 51,
  CONTENT_TRUNCATION_LENGTH: 50,
  // Length before adding ellipsis
  CONTENT_TRUNCATE_LINES: 3,
  UPDATE_DEBOUNCE_MS: 300,
  SELECTION_CLEAR_DELAY_MS: 300,
  SELECTION_FADE_DELAY_MS: 100,
  HIGHLIGHT_DURATION_MS: 2e3,
  MAX_HOVER_WIDTH: "400px",
  MAX_HOVER_HEIGHT: "300px",
  HOVER_PADDING: "8px 12px",
  HOVER_Z_INDEX: "1000"
};
var DOM_ATTRIBUTES = {
  CONTENT_EDITABLE_FALSE: "false"
};
var MATH_SYMBOLS = {
  // LaTeX to Unicode mappings for math rendering
  LATEX_TO_UNICODE: {
    "\\therefore": "\u2234",
    "\\because": "\u2235",
    "\\alpha": "\u03B1",
    "\\beta": "\u03B2",
    "\\gamma": "\u03B3",
    "\\delta": "\u03B4",
    "\\epsilon": "\u03B5",
    "\\theta": "\u03B8",
    "\\lambda": "\u03BB",
    "\\mu": "\u03BC",
    "\\pi": "\u03C0",
    "\\sigma": "\u03C3",
    "\\phi": "\u03C6",
    "\\psi": "\u03C8",
    "\\omega": "\u03C9",
    "\\infty": "\u221E",
    "\\pm": "\xB1",
    "\\times": "\xD7",
    "\\div": "\xF7",
    "\\neq": "\u2260",
    "\\leq": "\u2264",
    "\\geq": "\u2265",
    "\\approx": "\u2248",
    "\\subset": "\u2282",
    "\\supset": "\u2283",
    "\\cup": "\u222A",
    "\\cap": "\u2229",
    "\\in": "\u2208",
    "\\notin": "\u2209",
    "\\exists": "\u2203",
    "\\forall": "\u2200",
    "\\land": "\u2227",
    "\\lor": "\u2228",
    "\\neg": "\xAC",
    "\\rightarrow": "\u2192",
    "\\leftarrow": "\u2190",
    "\\leftrightarrow": "\u2194",
    "\\Rightarrow": "\u21D2",
    "\\Leftarrow": "\u21D0",
    "\\Leftrightarrow": "\u21D4"
  }
};
var ICONS = {
  CUSTOM_LABEL_SVG: `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">
        <text x="50" y="50" 
              text-anchor="middle" 
              dominant-baseline="central" 
              font-family="monospace" 
              font-size="36" 
              font-weight="bold" 
              fill="currentColor">
            {::}
        </text>
    </svg>`,
  CUSTOM_LABEL_ID: "custom-label-list"
};

// src/patterns.ts
var ListPatterns = class {
  // Note: Patterns are already compiled as static readonly RegExp objects,
  // providing optimal performance without needing additional caching.
  /**
   * Test if a line matches a hash list pattern.
   */
  static isHashList(line) {
    return line.match(this.HASH_LIST);
  }
  /**
   * Test if a line matches a fancy list pattern.
   */
  static isFancyList(line) {
    const match = line.match(this.FANCY_LIST);
    if (match && !line.match(this.NUMBERED_LIST)) {
      return match;
    }
    return null;
  }
  /**
   * Test if a line matches an example list pattern.
   */
  static isExampleList(line) {
    return line.match(this.EXAMPLE_LIST);
  }
  /**
   * Test if a line matches a definition marker pattern.
   */
  static isDefinitionMarker(line) {
    return line.match(this.DEFINITION_MARKER);
  }
  /**
   * Test if a line is indented (for definition list content).
   */
  static isIndentedContent(line) {
    return this.DEFINITION_INDENTED.test(line);
  }
  /**
   * Find all example references in a text.
   */
  static findExampleReferences(text) {
    const matches = [];
    const regex = new RegExp(this.EXAMPLE_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Check if a string is a roman numeral.
   */
  static isRomanNumeral(str) {
    return this.ROMAN_NUMERALS.test(str) || this.LOWER_ROMAN_NUMERALS.test(str);
  }
  /**
   * Check if a line is any type of list item.
   */
  static isListItem(line) {
    return !!(this.isHashList(line) || this.isFancyList(line) || this.isExampleList(line) || this.isDefinitionMarker(line) || line.match(this.UNORDERED_LIST) || line.match(this.NUMBERED_LIST));
  }
  /**
   * Find all superscripts in a text.
   */
  static findSuperscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUPERSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Find all subscripts in a text.
   */
  static findSubscripts(text) {
    const matches = [];
    const regex = new RegExp(this.SUBSCRIPT.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line matches a custom label list pattern.
   */
  static isCustomLabelList(line) {
    return line.match(this.CUSTOM_LABEL_LIST);
  }
  /**
   * Test if a label is valid for custom label lists.
   */
  static isValidCustomLabel(label) {
    return this.VALID_CUSTOM_LABEL.test(label);
  }
  /**
   * Find all custom label references in a text.
   */
  static findCustomLabelReferences(text) {
    const matches = [];
    const regex = new RegExp(this.CUSTOM_LABEL_REFERENCE.source, "g");
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match);
    }
    return matches;
  }
  /**
   * Test if a line is a heading.
   */
  static isHeading(line) {
    return this.HEADING.test(line);
  }
  /**
   * Test if text might be a definition term (not a marker or indented).
   */
  static isDefinitionTerm(line) {
    const trimmed = line.trim();
    return trimmed !== "" && !this.isDefinitionMarker(trimmed) && !this.isIndentedContent(line);
  }
  /**
   * Extract letter and delimiter from a fancy list marker.
   */
  static extractLetterMarker(marker) {
    return marker.match(/^([A-Za-z]+)([.)])$/);
  }
  /**
   * Extract roman numeral and delimiter from a fancy list marker.
   */
  static extractRomanMarker(marker) {
    return marker.match(/^([ivxlcdmIVXLCDM]+)([.)])$/);
  }
  /**
   * Check if text starts with a formatting marker.
   */
  static startsWithFormatting(text) {
    return /^(\*\*|__|\*|_|`)/.test(text);
  }
  /**
   * Get indent from a line.
   */
  static getIndent(line) {
    const match = line.match(this.INDENT_ONLY);
    return match ? match[1] : "";
  }
  /**
   * Replace escaped spaces with regular spaces.
   */
  static unescapeSpaces(text) {
    return text.replace(this.ESCAPED_SPACE, " ");
  }
  /**
   * Find all example reference starts in text.
   */
  static findExampleRefStarts(text) {
    return [...text.matchAll(this.EXAMPLE_REF_START)];
  }
  /**
   * Find all custom label reference starts in text.
   */
  static findCustomLabelRefStarts(text) {
    return [...text.matchAll(this.CUSTOM_LABEL_REF_START)];
  }
  /**
   * Split text by inline formatting markers.
   */
  static splitByInlineFormatting(text) {
    return text.split(this.INLINE_FORMATTING_SPLIT);
  }
};
// Base patterns as static readonly properties
ListPatterns.HASH_LIST = /^(\s*)(#\.)(\s+)/;
ListPatterns.FANCY_LIST = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+)([.)]))(\s+)/;
ListPatterns.EXAMPLE_LIST = /^(\s*)(\(@([a-zA-Z0-9_-]*)\))(\s+)/;
ListPatterns.EXAMPLE_LIST_WITH_CONTENT = /^(\s*)\(@([a-zA-Z0-9_-]+)\)\s+(.*)$/;
ListPatterns.EXAMPLE_REFERENCE = /\(@([a-zA-Z0-9_-]+)\)/g;
ListPatterns.DEFINITION_MARKER = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_MARKER_WITH_INDENT = /^(\s*)([~:])(\s+)/;
ListPatterns.DEFINITION_INDENTED = /^(    |\t)/;
ListPatterns.DEFINITION_INDENTED_WITH_CONTENT = /^(    |\t)(.*)$/;
ListPatterns.DEFINITION_TERM_PATTERN = /^([^\n:~]+)$/;
ListPatterns.NUMBERED_LIST = /^(\s*)([0-9]+[.)])/;
ListPatterns.UNORDERED_LIST = /^(\s*)[-*+]\s+/;
ListPatterns.CAPITAL_LETTER_LIST = /^(\s*)([A-Z])(\.)(\s+)/;
// Additional list patterns for validation
ListPatterns.STANDARD_ORDERED_LIST = /^(\s*)\d+\.\s+/;
ListPatterns.CAPITAL_LETTER_REPLACE = /^(\s*)([A-Z]\.)(\s+)/;
ListPatterns.UNLABELED_EXAMPLE_LIST = /^(\s*)\(@\)\s+/;
// Combined fancy list pattern for validation (includes numbers)
ListPatterns.FANCY_LIST_WITH_NUMBERS = /^(\s*)(([A-Z]+|[a-z]+|[IVXLCDM]+|[ivxlcdm]+|[0-9]+|#)([.)]))(\s+)/;
ListPatterns.ROMAN_NUMERALS = /^[IVXLCDM]+$/;
ListPatterns.LOWER_ROMAN_NUMERALS = /^[ivxlcdm]+$/;
// Character type patterns for fancy list parsing
ListPatterns.ROMAN_UPPER = /^[IVXLCDM]+$/;
ListPatterns.ROMAN_LOWER = /^[ivxlcdm]+$/;
ListPatterns.ALPHA_UPPER = /^[A-Z]+$/;
ListPatterns.ALPHA_LOWER = /^[a-z]+$/;
ListPatterns.DECIMAL = /^[0-9]+$/;
// Autocompletion patterns
ListPatterns.LETTER_OR_ROMAN_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s+)(.*)$/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)/;
ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+|#)([.)])(\s+)(.*)$/;
ListPatterns.VALID_ROMAN_NUMERAL = /^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$/i;
ListPatterns.SINGLE_I = /^[Ii]$/;
ListPatterns.SINGLE_H = /^[Hh]$/;
ListPatterns.SINGLE_AB = /^[ABab]$/;
ListPatterns.SINGLE_ROMAN_CHAR = /^[IVXLCDM]$/i;
ListPatterns.ANY_ROMAN_CHARS = /^[ivxlcdmIVXLCDM]+$/i;
ListPatterns.ALPHABETIC_CHARS = /^[A-Za-z]+$/;
ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)/;
ListPatterns.NUMBERED_LIST_WITH_SPACE = /^\s*\d+[.)]\s/;
ListPatterns.DEFINITION_MARKER_ONLY = /^[~:]$/;
// Empty list item patterns
ListPatterns.EMPTY_HASH_LIST = /^(\s*)(#\.)(\s*)$/;
ListPatterns.EMPTY_FANCY_LIST = /^(\s*)([A-Za-z]+|[ivxlcdmIVXLCDM]+)([.)])(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST = /^(\s*)\(@([a-zA-Z0-9_-]*)\)(\s*)$/;
ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL = /^(\s*)\(@\)(\s*)$/;
ListPatterns.EMPTY_DEFINITION_LIST = /^(\s*)([~:])(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST = /^(\s*)(\{::([a-zA-Z][a-zA-Z0-9_']*)*\})(\s*)$/;
ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL = /^(\s*)(\{::\})(\s*)$/;
// Complex list patterns for autocompletion
ListPatterns.ANY_LIST_MARKER = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})/;
ListPatterns.ANY_LIST_MARKER_WITH_SPACE = /^(\s*)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE = /^(\s+)(#\.|[A-Za-z]+[.)]|[ivxlcdmIVXLCDM]+[.)]|\(@[a-zA-Z0-9_-]*\)|[~:]|\{::[a-zA-Z][a-zA-Z0-9_']*\})(\s+)/;
// Indentation patterns
ListPatterns.INDENT_ONLY = /^(\s*)/;
// Text formatting patterns
ListPatterns.BOLD_TEXT = /^\*\*(.+)\*\*$/;
ListPatterns.UNDERLINE_SPAN = /^<span class="underline">(.+)<\/span>$/;
// Inline formatting patterns for parsing
ListPatterns.INLINE_FORMATTING_SPLIT = /(__(.+?)__|\*\*(.+?)\*\*|_(.+?)_|\*(.+?)\*|`(.+?)`)/g;
// Escaped space pattern
ListPatterns.ESCAPED_SPACE = /\\[ ]/g;
// Example reference start pattern (for autocomplete)
ListPatterns.EXAMPLE_REF_START = /\(@/g;
// Custom label reference start pattern (for autocomplete)
ListPatterns.CUSTOM_LABEL_REF_START = /\{::/g;
// Heading patterns
ListPatterns.HEADING = /^#{1,6}\s+/;
ListPatterns.HEADING_WITH_CONTENT = /^(#{1,6})\s+(.*)$/;
// Superscript and subscript patterns
// Matches ^text^ for superscript and ~text~ for subscript
// Text can contain escaped spaces (\ ) but not unescaped spaces
ListPatterns.SUPERSCRIPT = /\^([^\^\s]|\\[ ])+?\^/g;
ListPatterns.SUBSCRIPT = /~([^~\s]|\\[ ])+?~/g;
// Custom label list patterns for More Extended Syntax
// Matches {::LABEL} at start of line with required space after
// Now supports placeholders like {::P(#first)} or pure placeholders like {::(#name)}
ListPatterns.CUSTOM_LABEL_LIST = /^(\s*)(\{::([^}]+)\})(\s+)/;
ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT = /^(\s*)(\{::([^}]+)\})(\s+)(.*)$/;
// Reference to custom label anywhere in text
ListPatterns.CUSTOM_LABEL_REFERENCE = /\{::([^}]+)\}/g;
// Valid label pattern (for validation) - now accepts any non-empty content
ListPatterns.VALID_CUSTOM_LABEL = /^[^}]+$/;
// Simple valid label pattern for validation
ListPatterns.VALID_CUSTOM_LABEL_SIMPLE = /^[a-zA-Z][a-zA-Z0-9_']*$/;
// Placeholder pattern for auto-numbering
ListPatterns.PLACEHOLDER_PATTERN = /\(#([^)]+)\)/g;
// Pure expression pattern for validation
ListPatterns.PURE_EXPRESSION_PATTERN = /^[A-Za-z]?[\s+\-*/,()'\d]*$/;

// src/decorations/pandocExtendedMarkdownExtension.ts
var import_state = require("@codemirror/state");
var import_view10 = require("@codemirror/view");
var import_obsidian5 = require("obsidian");

// src/decorations/validators/listBlockValidator.ts
var ListBlockValidator = class {
  static isListItemForValidation(line) {
    return !!(ListPatterns.isHashList(line) || // Hash auto-numbering
    ListPatterns.isFancyList(line) || // Fancy lists
    ListPatterns.isExampleList(line) || // Example lists
    ListPatterns.isDefinitionMarker(line) || // Definition lists
    line.match(ListPatterns.UNORDERED_LIST) || // Unordered lists
    line.match(ListPatterns.NUMBERED_LIST));
  }
  static validateListBlocks(lines, settings) {
    const invalidListBlocks = /* @__PURE__ */ new Set();
    if (!settings.strictPandocMode) {
      return invalidListBlocks;
    }
    let listBlockStart = -1;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isCurrentList = this.isListItemForValidation(line);
      const prevIsListOrEmpty = i > 0 && (this.isListItemForValidation(lines[i - 1]) || lines[i - 1].trim() === "");
      const prevIsDefinitionTerm = i > 0 && lines[i - 1].trim() && !ListPatterns.isDefinitionMarker(lines[i - 1]) && !ListPatterns.isIndentedContent(lines[i - 1]) && ListPatterns.isDefinitionMarker(line);
      if (isCurrentList && listBlockStart === -1) {
        listBlockStart = i;
        if (i > 0 && lines[i - 1].trim() !== "" && !prevIsDefinitionTerm) {
          for (let j = i; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
            invalidListBlocks.add(j);
          }
        }
      } else if (!isCurrentList && listBlockStart !== -1) {
        if (line.trim() !== "") {
          for (let j = listBlockStart; j < i; j++) {
            invalidListBlocks.add(j);
          }
        }
        listBlockStart = -1;
      }
      if (isCurrentList) {
        const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
        if (capitalLetterMatch && capitalLetterMatch[4].length < 2) {
          for (let j = i; j >= 0 && this.isListItemForValidation(lines[j]); j--) {
            invalidListBlocks.add(j);
          }
          for (let j = i + 1; j < lines.length && this.isListItemForValidation(lines[j]); j++) {
            invalidListBlocks.add(j);
          }
        }
      }
    }
    return invalidListBlocks;
  }
};

// src/decorations/scanners/exampleScanner.ts
function scanExampleLabels(view, settings) {
  const result = {
    exampleLabels: /* @__PURE__ */ new Map(),
    exampleContent: /* @__PURE__ */ new Map(),
    exampleLineNumbers: /* @__PURE__ */ new Map(),
    duplicateLabels: /* @__PURE__ */ new Map(),
    duplicateLabelContent: /* @__PURE__ */ new Map()
  };
  let counter = 1;
  const docText = view.state.doc.toString();
  const lines = docText.split("\n");
  const invalidListBlocks = settings.strictPandocMode ? ListBlockValidator.validateListBlocks(lines, settings) : /* @__PURE__ */ new Set();
  for (let i = 0; i < lines.length; i++) {
    if (settings.strictPandocMode && invalidListBlocks.has(i)) {
      continue;
    }
    const line = lines[i];
    const match = line.match(ListPatterns.EXAMPLE_LIST_WITH_CONTENT);
    if (match) {
      const label = match[2];
      const content = match[3].trim();
      if (!result.exampleLabels.has(label)) {
        result.exampleLabels.set(label, counter);
        if (content) {
          result.exampleContent.set(label, content);
        }
        result.duplicateLabels.set(label, i + 1);
        result.duplicateLabelContent.set(label, line);
      }
      result.exampleLineNumbers.set(i + 1, counter);
      counter++;
    } else {
      const unlabeledMatch = line.match(ListPatterns.UNLABELED_EXAMPLE_LIST);
      if (unlabeledMatch) {
        result.exampleLineNumbers.set(i + 1, counter);
        counter++;
      }
    }
  }
  return result;
}

// src/utils/placeholderProcessor.ts
var PlaceholderContext = class {
  constructor() {
    this.placeholderMap = /* @__PURE__ */ new Map();
    this.nextNumber = 1;
    this.processedLabels = /* @__PURE__ */ new Map();
    this.definedLabels = /* @__PURE__ */ new Set();
  }
  // Track which labels are actually defined
  /**
   * Process a label with placeholders, maintaining consistent numbering.
   * 
   * @param rawLabel - The raw label with placeholders
   * @returns The processed label with numbers
   */
  processLabel(rawLabel) {
    if (this.processedLabels.has(rawLabel)) {
      return this.processedLabels.get(rawLabel);
    }
    const processedLabel = rawLabel.replace(ListPatterns.PLACEHOLDER_PATTERN, (match, name) => {
      if (!this.placeholderMap.has(name)) {
        this.placeholderMap.set(name, this.nextNumber++);
      }
      return this.placeholderMap.get(name).toString();
    });
    this.processedLabels.set(rawLabel, processedLabel);
    this.definedLabels.add(processedLabel);
    return processedLabel;
  }
  /**
   * Get the number assigned to a placeholder name.
   * 
   * @param name - The placeholder name
   * @returns The assigned number, or null if not found
   */
  getPlaceholderNumber(name) {
    return this.placeholderMap.get(name) || null;
  }
  /**
   * Get the processed version of a label without modifying state.
   * Used for references to existing labels.
   * 
   * A label reference is valid if:
   * 1. It doesn't contain placeholders and has been defined before, OR
   * 2. It contains placeholders that have all appeared in previous list labels
   * 
   * @param rawLabel - The raw label to look up
   * @returns The processed label if valid, null if invalid
   */
  getProcessedLabel(rawLabel) {
    if (this.processedLabels.has(rawLabel)) {
      return this.processedLabels.get(rawLabel);
    }
    let allPlaceholdersKnown = true;
    const matches = [...rawLabel.matchAll(ListPatterns.PLACEHOLDER_PATTERN)];
    for (const match of matches) {
      if (!this.placeholderMap.has(match[1])) {
        allPlaceholdersKnown = false;
        break;
      }
    }
    if (!allPlaceholdersKnown && matches.length > 0) {
      return null;
    }
    const processedLabel = rawLabel.replace(ListPatterns.PLACEHOLDER_PATTERN, (match, name) => {
      var _a;
      return ((_a = this.placeholderMap.get(name)) == null ? void 0 : _a.toString()) || match;
    });
    if (this.isPureExpression(rawLabel) && allPlaceholdersKnown) {
      return processedLabel;
    }
    const baseProcessedLabel = this.getBaseLabel(processedLabel);
    for (const definedLabel of this.definedLabels) {
      if (definedLabel.startsWith(baseProcessedLabel)) {
        return processedLabel;
      }
    }
    if (!this.definedLabels.has(processedLabel)) {
      return null;
    }
    return processedLabel;
  }
  /**
   * Check if a label is a pure expression (contains only placeholders and operators).
   * Pure expressions like "(#a)+(#b)" or "P(#a),(#b)" are valid references without needing to be defined.
   * 
   * @param label - The label to check
   * @returns true if the label is a pure expression
   */
  isPureExpression(label) {
    const withoutPlaceholders = label.replace(ListPatterns.PLACEHOLDER_PATTERN, "");
    return ListPatterns.PURE_EXPRESSION_PATTERN.test(withoutPlaceholders);
  }
  /**
   * Get the base label without trailing primes or other modifiers.
   * Used to match variations like "P1'" against defined labels like "P1'''".
   * 
   * @param label - The label to extract base from
   * @returns The base label without trailing primes
   */
  getBaseLabel(label) {
    return label.replace(/'+$/, "");
  }
  /**
   * Reset the context for a new document.
   */
  reset() {
    this.placeholderMap.clear();
    this.processedLabels.clear();
    this.definedLabels.clear();
    this.nextNumber = 1;
  }
  /**
   * Get the current placeholder mappings for debugging.
   */
  getPlaceholderMappings() {
    return new Map(this.placeholderMap);
  }
  /**
   * Check if a label is defined.
   */
  isLabelDefined(processedLabel) {
    return this.definedLabels.has(processedLabel);
  }
};

// src/decorations/scanners/customLabelScanner.ts
function collectPlaceholders(doc) {
  const placeholdersInOrder = [];
  const seenPlaceholders = /* @__PURE__ */ new Set();
  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i);
    const lineText = line.text;
    const match = ListPatterns.isCustomLabelList(lineText);
    if (match) {
      const rawLabel = match[3];
      const matches = [...rawLabel.matchAll(ListPatterns.PLACEHOLDER_PATTERN)];
      for (const m of matches) {
        const placeholder = m[1];
        if (!seenPlaceholders.has(placeholder)) {
          placeholdersInOrder.push(placeholder);
          seenPlaceholders.add(placeholder);
        }
      }
    }
  }
  return placeholdersInOrder;
}
function shouldResetContext(placeholdersInOrder, existingMappings) {
  if (placeholdersInOrder.length !== existingMappings.size) {
    return true;
  }
  for (let i = 0; i < placeholdersInOrder.length; i++) {
    const placeholder = placeholdersInOrder[i];
    const expectedNumber = i + 1;
    const actualNumber = existingMappings.get(placeholder);
    if (actualNumber !== expectedNumber) {
      return true;
    }
  }
  return false;
}
function scanCustomLabels(doc, settings, placeholderContext) {
  const customLabels = /* @__PURE__ */ new Map();
  const rawToProcessed = /* @__PURE__ */ new Map();
  const duplicateLabels = /* @__PURE__ */ new Set();
  const duplicateLineInfo = /* @__PURE__ */ new Map();
  const seenLabels = /* @__PURE__ */ new Map();
  const context = placeholderContext || new PlaceholderContext();
  if (!settings.moreExtendedSyntax) {
    return { customLabels, rawToProcessed, duplicateLabels, duplicateLineInfo, placeholderContext: context };
  }
  const placeholdersInOrder = collectPlaceholders(doc);
  const existingMappings = context.getPlaceholderMappings();
  if (shouldResetContext(placeholdersInOrder, existingMappings)) {
    context.reset();
  }
  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i);
    const lineText = line.text;
    const match = ListPatterns.isCustomLabelList(lineText);
    if (match) {
      const rawLabel = match[3];
      const processedLabel = context.processLabel(rawLabel);
      rawToProcessed.set(rawLabel, processedLabel);
      const contentStart = match[0].length;
      const content = lineText.substring(contentStart).trim();
      if (seenLabels.has(processedLabel)) {
        duplicateLabels.add(processedLabel);
        if (!duplicateLineInfo.has(processedLabel)) {
          const firstOccurrence = seenLabels.get(processedLabel);
          duplicateLineInfo.set(processedLabel, {
            firstLine: firstOccurrence.line,
            firstContent: firstOccurrence.content
          });
        }
      } else {
        seenLabels.set(processedLabel, {
          line: i,
          // line number (1-based)
          content
        });
        if (content) {
          customLabels.set(processedLabel, content);
        }
      }
    }
  }
  return { customLabels, rawToProcessed, duplicateLabels, duplicateLineInfo, placeholderContext: context };
}
function validateCustomLabelBlocks(doc, settings) {
  const invalidLines = /* @__PURE__ */ new Set();
  if (!settings.moreExtendedSyntax || !settings.strictPandocMode) {
    return invalidLines;
  }
  const blocks = [];
  let inBlock = false;
  let blockStart = -1;
  let blockValid = true;
  for (let i = 1; i <= doc.lines; i++) {
    const line = doc.line(i);
    const lineText = line.text;
    const isCustomLabel = ListPatterns.isCustomLabelList(lineText);
    if (isCustomLabel) {
      if (!inBlock) {
        inBlock = true;
        blockStart = i;
        blockValid = true;
        if (i > 1) {
          const prevLine = doc.line(i - 1);
          if (prevLine.text.trim() !== "") {
            blockValid = false;
          }
        }
      }
    } else if (inBlock) {
      const blockEnd = i - 1;
      if (line.text.trim() !== "") {
        blockValid = false;
      }
      blocks.push({ start: blockStart, end: blockEnd, valid: blockValid });
      inBlock = false;
    }
  }
  if (inBlock) {
    blocks.push({ start: blockStart, end: doc.lines, valid: blockValid });
  }
  for (const block of blocks) {
    if (!block.valid) {
      for (let i = block.start; i <= block.end; i++) {
        invalidLines.add(i - 1);
      }
    }
  }
  return invalidLines;
}

// src/state/pluginStateManager.ts
var PluginStateManager = class {
  constructor() {
    // Document-specific counters
    this.documentCounters = /* @__PURE__ */ new Map();
    // View state tracking per leaf
    this.viewStates = /* @__PURE__ */ new Map();
    // Mode change listeners
    this.modeChangeListeners = /* @__PURE__ */ new Set();
    // Track processed elements to prevent duplicate counter increments
    this.processedElements = /* @__PURE__ */ new WeakMap();
    // Track which documents need element reprocessing
    this.documentsNeedingReprocess = /* @__PURE__ */ new Set();
  }
  /**
   * Get or create counters for a document
   */
  getDocumentCounters(docPath) {
    if (!this.documentCounters.has(docPath)) {
      this.documentCounters.set(docPath, this.createEmptyCounters());
    }
    return this.documentCounters.get(docPath);
  }
  /**
   * Reset counters for a specific document
   */
  resetDocumentCounters(docPath) {
    if (this.documentCounters.has(docPath)) {
      const counters = this.documentCounters.get(docPath);
      counters.exampleCounter = 0;
      counters.exampleMap.clear();
      counters.exampleContent.clear();
      counters.hashCounter = 0;
      counters.placeholderContext.reset();
    }
    this.documentsNeedingReprocess.add(docPath);
  }
  /**
   * Clear counters for a document (remove from memory)
   */
  clearDocumentCounters(docPath) {
    this.documentCounters.delete(docPath);
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Update view state and detect mode/document changes
   */
  updateViewState(leaf) {
    var _a;
    const leafId = this.getLeafId(leaf);
    const view = leaf.view;
    const currentMode = this.detectViewMode(view);
    const currentPath = ((_a = view.file) == null ? void 0 : _a.path) || null;
    const previous = this.viewStates.get(leafId);
    const previousMode = (previous == null ? void 0 : previous.mode) || null;
    const previousPath = (previous == null ? void 0 : previous.filePath) || null;
    this.viewStates.set(leafId, {
      mode: currentMode,
      filePath: currentPath
    });
    const modeChanged = previousMode !== currentMode;
    const pathChanged = previousPath !== currentPath;
    if (modeChanged || pathChanged) {
      const event = {
        leafId,
        previousMode,
        currentMode,
        previousPath,
        currentPath
      };
      this.handleStateTransition(event);
      this.notifyModeChange(event);
      return event;
    }
    return null;
  }
  /**
   * Handle state transitions (e.g., reset counters)
   */
  handleStateTransition(event) {
    if (event.previousMode === "reading" && event.currentMode !== "reading") {
      if (event.previousPath) {
        if (this.documentCounters.has(event.previousPath)) {
          const counters = this.documentCounters.get(event.previousPath);
          counters.exampleCounter = 0;
          counters.exampleMap.clear();
          counters.exampleContent.clear();
          counters.hashCounter = 0;
        }
        this.documentsNeedingReprocess.add(event.previousPath);
      }
    }
    if (event.previousPath && event.currentPath && event.previousPath !== event.currentPath) {
      this.resetDocumentCounters(event.currentPath);
    }
    if (event.currentMode === "reading" && event.currentPath) {
      setTimeout(() => {
        this.clearReprocessFlag(event.currentPath);
      }, UI_CONSTANTS.STATE_TRANSITION_DELAY_MS);
    }
  }
  /**
   * Register a mode change listener
   */
  onModeChange(callback) {
    this.modeChangeListeners.add(callback);
    return () => {
      this.modeChangeListeners.delete(callback);
    };
  }
  /**
   * Notify all mode change listeners
   */
  notifyModeChange(event) {
    this.modeChangeListeners.forEach((callback) => callback(event));
  }
  /**
   * Increment example counter for a document
   */
  incrementExampleCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleCounter++;
    return counters.exampleCounter;
  }
  /**
   * Increment hash counter for a document
   */
  incrementHashCounter(docPath) {
    const counters = this.getDocumentCounters(docPath);
    counters.hashCounter++;
    return counters.hashCounter;
  }
  /**
   * Store labeled example data
   */
  setLabeledExample(docPath, label, number, content) {
    const counters = this.getDocumentCounters(docPath);
    counters.exampleMap.set(label, number);
    if (content) {
      counters.exampleContent.set(label, content);
    }
  }
  /**
   * Get labeled example number
   */
  getLabeledExampleNumber(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleMap.get(label);
  }
  /**
   * Get labeled example content
   */
  getLabeledExampleContent(docPath, label) {
    const counters = this.getDocumentCounters(docPath);
    return counters.exampleContent.get(label);
  }
  /**
   * Mark an element as processed to prevent duplicate processing
   */
  markElementProcessed(element, key, value) {
    if (!this.processedElements.has(element)) {
      this.processedElements.set(element, /* @__PURE__ */ new Map());
    }
    this.processedElements.get(element).set(key, value);
  }
  /**
   * Check if an element has been processed
   */
  isElementProcessed(element, key, docPath) {
    if (docPath && this.documentsNeedingReprocess.has(docPath)) {
      return false;
    }
    return this.processedElements.has(element) && this.processedElements.get(element).has(key);
  }
  /**
   * Clear reprocess flag for a document after processing
   */
  clearReprocessFlag(docPath) {
    this.documentsNeedingReprocess.delete(docPath);
  }
  /**
   * Get processed element data
   */
  getProcessedElementData(element, key) {
    if (this.processedElements.has(element)) {
      return this.processedElements.get(element).get(key);
    }
    return void 0;
  }
  /**
   * Scan all leaves and update states
   * Returns true if any mode changes were detected
   */
  scanAllLeaves(leaves) {
    var _a;
    let anyChanges = false;
    for (const leaf of leaves) {
      if (((_a = leaf.view) == null ? void 0 : _a.getViewType()) === "markdown") {
        const event = this.updateViewState(leaf);
        if (event) {
          anyChanges = true;
        }
      }
    }
    return anyChanges;
  }
  /**
   * Clear all states (for plugin unload)
   */
  clearAllStates() {
    this.documentCounters.clear();
    this.viewStates.clear();
    this.modeChangeListeners.clear();
  }
  /**
   * Create empty counters object
   */
  createEmptyCounters() {
    return {
      exampleCounter: 0,
      exampleMap: /* @__PURE__ */ new Map(),
      exampleContent: /* @__PURE__ */ new Map(),
      hashCounter: 0,
      placeholderContext: new PlaceholderContext()
    };
  }
  /**
   * Detect the current view mode from a MarkdownView
   */
  detectViewMode(view) {
    const state = view.getState();
    if ((state == null ? void 0 : state.mode) === "preview") return "reading";
    if ((state == null ? void 0 : state.mode) === "source") {
      return state.source ? "source" : "live";
    }
    return view.getMode() === "preview" ? "reading" : "live";
  }
  /**
   * Get a stable ID for a leaf
   */
  getLeafId(leaf) {
    var _a, _b;
    if ("id" in leaf && leaf.id) {
      return leaf.id;
    }
    const view = leaf.view;
    return `${(_b = (_a = view == null ? void 0 : view.file) == null ? void 0 : _a.path) != null ? _b : "unknown"}::${Math.random()}`;
  }
};
var pluginStateManager = new PluginStateManager();

// src/decorations/processors/listProcessors.ts
var import_view6 = require("@codemirror/view");

// src/decorations/widgets/listWidgets.ts
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var FancyListMarkerWidget = class extends import_view.WidgetType {
  constructor(marker, type, view, pos) {
    super();
    this.marker = marker;
    this.type = type;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = this.marker + " ";
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.marker === this.marker && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var HashListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, view, pos) {
    super();
    this.number = number;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `${this.number}. `;
    span.appendChild(innerSpan);
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var ExampleListMarkerWidget = class extends import_view.WidgetType {
  constructor(number, label, view, pos) {
    super();
    this.number = number;
    this.label = label;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER} ${CSS_CLASSES.EXAMPLE_REF}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.number}) `;
    span.appendChild(innerSpan);
    const tooltipText = this.label ? `@${this.label}` : "@";
    (0, import_obsidian2.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.number === this.number && other.label === this.label && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};
var DuplicateExampleLabelWidget = class extends import_view.WidgetType {
  constructor(label, originalLine, originalLineContent, view, pos) {
    super();
    this.label = label;
    this.originalLine = originalLine;
    this.originalLineContent = originalLineContent;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.DUPLICATE_MARKERS;
    span.textContent = `(@${this.label})`;
    let lineContent = this.originalLineContent.trim();
    if (lineContent.length > DECORATION_STYLES.LINE_TRUNCATION_LIMIT) {
      lineContent = lineContent.substring(0, DECORATION_STYLES.LINE_TRUNCATION_LIMIT) + "...";
    }
    const tooltipText = `Duplicate index at line ${this.originalLine}: ${lineContent}`;
    (0, import_obsidian2.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.originalLine === this.originalLine && other.originalLineContent === this.originalLineContent && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};

// src/decorations/widgets/definitionWidget.ts
var import_view2 = require("@codemirror/view");
var DefinitionBulletWidget = class extends import_view2.WidgetType {
  constructor(view, pos) {
    super();
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = "cm-formatting cm-formatting-list cm-list-1 pandoc-list-marker";
    span.textContent = "\u2022 ";
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};

// src/decorations/widgets/referenceWidget.ts
var import_view3 = require("@codemirror/view");
var import_obsidian3 = require("obsidian");
var ExampleReferenceWidget = class extends import_view3.WidgetType {
  constructor(number, tooltipText) {
    super();
    this.number = number;
    this.tooltipText = tooltipText;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_REF;
    span.textContent = `(${this.number})`;
    if (this.tooltipText) {
      (0, import_obsidian3.setTooltip)(span, this.tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    }
    return span;
  }
  // Make the widget editable - allow all editing events to pass through
  ignoreEvent() {
    return false;
  }
  eq(other) {
    return other.number === this.number && other.tooltipText === this.tooltipText;
  }
};

// src/decorations/widgets/formatWidgets.ts
var import_view4 = require("@codemirror/view");
var SuperscriptWidget = class extends import_view4.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sup = document.createElement("sup");
    sup.className = CSS_CLASSES.SUPERSCRIPT;
    sup.textContent = this.content;
    return sup;
  }
  eq(other) {
    return other.content === this.content;
  }
  ignoreEvent() {
    return false;
  }
};
var SubscriptWidget = class extends import_view4.WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM() {
    const sub = document.createElement("sub");
    sub.className = CSS_CLASSES.SUBSCRIPT;
    sub.textContent = this.content;
    return sub;
  }
  eq(other) {
    return other.content === this.content;
  }
  ignoreEvent() {
    return false;
  }
};

// src/decorations/widgets/customLabelWidget.ts
var import_view5 = require("@codemirror/view");
var import_obsidian4 = require("obsidian");
var CustomLabelMarkerWidget = class extends import_view5.WidgetType {
  constructor(label, view, position) {
    super();
    this.label = label;
    this.view = view;
    this.position = position;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CM_FORMATTING_LIST_OL} ${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.PANDOC_LIST_MARKER}`;
    const innerSpan = document.createElement("span");
    innerSpan.className = "list-number";
    innerSpan.textContent = `(${this.label}) `;
    span.appendChild(innerSpan);
    if (this.view && this.position !== void 0) {
      span.classList.add(CSS_CLASSES.CUSTOM_LABEL_REF_CLICKABLE);
      span.addEventListener("click", () => {
        if (this.view && this.position !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.position }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.position === this.position;
  }
  ignoreEvent() {
    return false;
  }
  destroy() {
    this.controller.abort();
  }
};
var CustomLabelInlineNumberWidget = class extends import_view5.WidgetType {
  constructor(number, view) {
    super();
    this.number = number;
    this.view = view;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.INLINE_PLACEHOLDER_NUMBER;
    span.textContent = this.number;
    span.contentEditable = DOM_ATTRIBUTES.CONTENT_EDITABLE_FALSE;
    return span;
  }
  eq(other) {
    return other.number === this.number;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown" && event.type !== "mouseup" && event.type !== "click";
  }
};
var CustomLabelReferenceWidget = class extends import_view5.WidgetType {
  constructor(label, content, view, position) {
    super();
    this.label = label;
    this.content = content;
    this.view = view;
    this.position = position;
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_REF;
    span.setAttribute("data-custom-label-ref", this.label);
    span.textContent = `(${this.label})`;
    if (this.content) {
      span.setAttribute("title", this.content);
    }
    return span;
  }
  eq(other) {
    return other.label === this.label && other.content === this.content && other.position === this.position;
  }
  ignoreEvent() {
    return false;
  }
};
var DuplicateCustomLabelWidget = class extends import_view5.WidgetType {
  /**
   * @param rawLabel - The raw label text (e.g., "P(#a)")
   * @param originalLine - Line number of the first occurrence
   * @param originalLineContent - Content of the first occurrence line
   * @param view - Optional editor view for cursor positioning
   * @param pos - Optional position for cursor placement
   */
  constructor(rawLabel, originalLine, originalLineContent, view, pos) {
    super();
    this.rawLabel = rawLabel;
    this.originalLine = originalLine;
    this.originalLineContent = originalLineContent;
    this.view = view;
    this.pos = pos;
    this.controller = new AbortController();
  }
  toDOM() {
    const span = document.createElement("span");
    span.className = CSS_CLASSES.DUPLICATE_MARKERS;
    span.textContent = `{::${this.rawLabel}}`;
    let lineContent = this.originalLineContent.trim();
    if (lineContent.length > DECORATION_STYLES.LINE_TRUNCATION_LIMIT) {
      lineContent = lineContent.substring(0, DECORATION_STYLES.LINE_TRUNCATION_LIMIT) + "...";
    }
    const tooltipText = `Duplicate label at line ${this.originalLine}: ${lineContent}`;
    (0, import_obsidian4.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
    if (this.view && this.pos !== void 0) {
      span.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.view && this.pos !== void 0) {
          this.view.dispatch({
            selection: { anchor: this.pos }
          });
          this.view.focus();
        }
      }, { signal: this.controller.signal });
    }
    return span;
  }
  eq(other) {
    return other.rawLabel === this.rawLabel && other.originalLine === this.originalLine && other.originalLineContent === this.originalLineContent && other.pos === this.pos;
  }
  ignoreEvent(event) {
    return event.type !== "mousedown";
  }
  destroy() {
    this.controller.abort();
  }
};

// src/decorations/processors/listProcessors.ts
function processHashList(context, hashCounter) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const hashMatch = ListPatterns.isHashList(lineText);
  if (!hashMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = hashMatch[1];
  const marker = hashMatch[2];
  const space = hashMatch[3];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view6.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view6.Decoration.replace({
        widget: new HashListMarkerWidget(hashCounter.value, view, markerStart)
      })
    });
  }
  decorations.push({
    from: line.from + indent.length + marker.length + space.length,
    to: line.to,
    decoration: import_view6.Decoration.mark({
      class: "cm-list-1"
    })
  });
  hashCounter.value++;
  return decorations;
}
function processFancyList(context) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const fancyMatch = ListPatterns.isFancyList(lineText);
  if (!fancyMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = fancyMatch[1];
  const marker = fancyMatch[2];
  const space = fancyMatch[5];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  let listClass = CSS_CLASSES.FANCY_LIST_UPPER_ALPHA;
  const letterMatch = ListPatterns.extractLetterMarker(marker);
  const romanMatch = ListPatterns.extractRomanMarker(marker);
  if (letterMatch) {
    const letter = letterMatch[1];
    if (letter[0] === letter[0].toLowerCase()) {
      listClass = CSS_CLASSES.FANCY_LIST_LOWER_ALPHA;
    }
  } else if (romanMatch) {
    const roman = romanMatch[1];
    if (roman[0] === roman[0].toLowerCase()) {
      listClass = CSS_CLASSES.FANCY_LIST_LOWER_ROMAN;
    } else {
      listClass = CSS_CLASSES.FANCY_LIST_UPPER_ROMAN;
    }
  }
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view6.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view6.Decoration.replace({
        widget: new FancyListMarkerWidget(marker, listClass, view, markerStart)
      })
    });
  }
  decorations.push({
    from: line.from + indent.length + marker.length + space.length,
    to: line.to,
    decoration: import_view6.Decoration.mark({
      class: "cm-list-1"
    })
  });
  return decorations;
}
function processExampleList(context) {
  const {
    line,
    lineNum,
    lineText,
    cursorPos,
    view,
    invalidListBlocks,
    settings,
    exampleLabels,
    exampleLineNumbers,
    duplicateLabels,
    duplicateLabelContent
  } = context;
  const decorations = [];
  const exampleMatch = ListPatterns.isExampleList(lineText);
  if (!exampleMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = exampleMatch[1];
  const fullMarker = exampleMatch[2];
  const label = exampleMatch[3] || "";
  const space = exampleMatch[4];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + fullMarker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  const exampleNumber = (exampleLineNumbers == null ? void 0 : exampleLineNumbers.get(lineNum)) || 1;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view6.Decoration.line({
      class: "HyperMD-list-line HyperMD-list-line-1 pandoc-list-line"
    })
  });
  const isDuplicate = label && (duplicateLabels == null ? void 0 : duplicateLabels.has(label)) && duplicateLabels.get(label) !== lineNum;
  if (!cursorInMarker) {
    if (isDuplicate && duplicateLabels && duplicateLabelContent) {
      const originalLine = duplicateLabels.get(label);
      const originalContent = duplicateLabelContent.get(label);
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view6.Decoration.replace({
          widget: new DuplicateExampleLabelWidget(label, originalLine, originalContent, view, markerStart)
        })
      });
    } else {
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view6.Decoration.replace({
          widget: new ExampleListMarkerWidget(exampleNumber, label || void 0, view, markerStart)
        })
      });
    }
  }
  decorations.push({
    from: line.from + indent.length + fullMarker.length + space.length,
    to: line.to,
    decoration: import_view6.Decoration.mark({
      class: CSS_CLASSES.EXAMPLE_ITEM
    })
  });
  return decorations;
}

// src/decorations/processors/definitionProcessor.ts
var import_view7 = require("@codemirror/view");
function processDefinitionItem(context) {
  const { line, lineNum, lineText, cursorPos, view, invalidListBlocks, settings } = context;
  const decorations = [];
  const defItemMatch = ListPatterns.isDefinitionMarker(lineText);
  if (!defItemMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = defItemMatch[1];
  const marker = defItemMatch[2];
  const space = defItemMatch[3];
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + marker.length + space.length;
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  if (!cursorInMarker) {
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view7.Decoration.replace({
        widget: new DefinitionBulletWidget(view, markerStart)
      })
    });
  }
  return decorations;
}
function processDefinitionTerm(context) {
  const { line, lineText, view } = context;
  const decorations = [];
  if (!lineText.trim() || ListPatterns.isDefinitionMarker(lineText) || ListPatterns.isIndentedContent(lineText)) {
    return null;
  }
  let isDefinitionTerm = false;
  if (line.number < view.state.doc.lines) {
    const nextLine = view.state.doc.line(line.number + 1);
    const nextText = nextLine.text;
    if (ListPatterns.isDefinitionMarker(nextText)) {
      isDefinitionTerm = true;
    } else if (nextText.trim() === "" && line.number + 1 < view.state.doc.lines) {
      const lineAfterEmpty = view.state.doc.line(line.number + 2);
      if (ListPatterns.isDefinitionMarker(lineAfterEmpty.text)) {
        isDefinitionTerm = true;
      }
    }
  }
  if (isDefinitionTerm) {
    decorations.push({
      from: line.from,
      to: line.to,
      decoration: import_view7.Decoration.mark({
        class: "cm-strong cm-pandoc-definition-term"
      })
    });
    return decorations;
  }
  return null;
}
function processDefinitionParagraph(context) {
  const { line, lineNum, lineText, view } = context;
  const decorations = [];
  const indentMatch = ListPatterns.isIndentedContent(lineText) ? lineText.match(ListPatterns.DEFINITION_INDENTED_WITH_CONTENT) : null;
  if (!indentMatch) return null;
  let inDefinitionContext = false;
  for (let checkLine = lineNum - 1; checkLine >= 1; checkLine--) {
    const prevLine = view.state.doc.line(checkLine);
    const prevText = prevLine.text;
    if (ListPatterns.isDefinitionMarker(prevText)) {
      inDefinitionContext = true;
      break;
    }
    if (prevText.trim() && !ListPatterns.isIndentedContent(prevText) && !ListPatterns.isDefinitionMarker(prevText)) {
      break;
    }
  }
  if (!inDefinitionContext) return null;
  const content = indentMatch[2];
  if (content && content.trim()) {
    decorations.push({
      from: line.from,
      to: line.from,
      decoration: import_view7.Decoration.line({
        class: "cm-pandoc-definition-paragraph",
        attributes: {
          "data-definition-content": "true"
        }
      })
    });
    decorations.push({
      from: line.from,
      to: line.to,
      decoration: import_view7.Decoration.mark({
        class: CSS_CLASSES.DEFINITION_CONTENT_TEXT
      })
    });
  }
  return decorations;
}

// src/decorations/processors/inlineFormatProcessor.ts
var import_view8 = require("@codemirror/view");
function processExampleReferences(context) {
  const { line, lineText, cursorPos, exampleLabels, exampleContent } = context;
  const decorations = [];
  if (!exampleLabels) return decorations;
  const refRegex = ListPatterns.EXAMPLE_REFERENCE;
  let match;
  while ((match = refRegex.exec(lineText)) !== null) {
    const label = match[1];
    if (exampleLabels.has(label)) {
      const refStart = line.from + match.index;
      const refEnd = line.from + match.index + match[0].length;
      const cursorInRef = cursorPos >= refStart && cursorPos <= refEnd;
      if (!cursorInRef) {
        const number = exampleLabels.get(label);
        const tooltipText = exampleContent == null ? void 0 : exampleContent.get(label);
        decorations.push({
          from: refStart,
          to: refEnd,
          decoration: import_view8.Decoration.replace({
            widget: new ExampleReferenceWidget(number, tooltipText),
            inclusive: false
          })
        });
      }
    }
  }
  return decorations;
}
function processSuperscripts(context) {
  const { line, lineText, cursorPos } = context;
  const decorations = [];
  const superscripts = ListPatterns.findSuperscripts(lineText);
  for (const supMatch of superscripts) {
    const supStart = line.from + supMatch.index;
    const supEnd = line.from + supMatch.index + supMatch[0].length;
    const cursorInSup = cursorPos >= supStart && cursorPos <= supEnd;
    if (!cursorInSup) {
      const content = ListPatterns.unescapeSpaces(supMatch[0].slice(1, -1));
      decorations.push({
        from: supStart,
        to: supEnd,
        decoration: import_view8.Decoration.replace({
          widget: new SuperscriptWidget(content)
        })
      });
    }
  }
  return decorations;
}
function processSubscripts(context) {
  const { line, lineText, cursorPos } = context;
  const decorations = [];
  const subscripts = ListPatterns.findSubscripts(lineText);
  for (const subMatch of subscripts) {
    const subStart = line.from + subMatch.index;
    const subEnd = line.from + subMatch.index + subMatch[0].length;
    const cursorInSub = cursorPos >= subStart && cursorPos <= subEnd;
    if (!cursorInSub) {
      const content = ListPatterns.unescapeSpaces(subMatch[0].slice(1, -1));
      decorations.push({
        from: subStart,
        to: subEnd,
        decoration: import_view8.Decoration.replace({
          widget: new SubscriptWidget(content)
        })
      });
    }
  }
  return decorations;
}

// src/decorations/processors/customLabelProcessor.ts
var import_view9 = require("@codemirror/view");
function processCustomLabelList(context) {
  const {
    line,
    lineNum,
    lineText,
    cursorPos,
    view,
    invalidListBlocks,
    settings,
    customLabels,
    rawToProcessed,
    duplicateLabels,
    duplicateLineInfo,
    placeholderContext
  } = context;
  if (!settings.moreExtendedSyntax) {
    return null;
  }
  const decorations = [];
  const customLabelMatch = ListPatterns.isCustomLabelList(lineText);
  if (!customLabelMatch) return null;
  if (settings.strictPandocMode && invalidListBlocks.has(lineNum - 1)) {
    return null;
  }
  const indent = customLabelMatch[1];
  const fullMarker = customLabelMatch[2];
  const rawLabel = customLabelMatch[3];
  const space = customLabelMatch[4];
  const processedLabel = (rawToProcessed == null ? void 0 : rawToProcessed.get(rawLabel)) || rawLabel;
  const markerStart = line.from + indent.length;
  const markerEnd = line.from + indent.length + fullMarker.length + space.length;
  const placeholderMatches = [...rawLabel.matchAll(/\(#([^)]+)\)/g)];
  const placeholderRanges = [];
  for (const match of placeholderMatches) {
    if (match.index !== void 0) {
      const placeholderStart = markerStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH + match.index;
      const placeholderEnd = placeholderStart + match[0].length;
      placeholderRanges.push({
        start: placeholderStart,
        end: placeholderEnd,
        name: match[1]
      });
    }
  }
  const cursorInMarker = cursorPos >= markerStart && cursorPos < markerEnd;
  let cursorPlaceholderIndex = -1;
  for (let i = 0; i < placeholderRanges.length; i++) {
    if (cursorPos >= placeholderRanges[i].start && cursorPos < placeholderRanges[i].end) {
      cursorPlaceholderIndex = i;
      break;
    }
  }
  const cursorInPlaceholder = cursorPlaceholderIndex !== -1;
  decorations.push({
    from: line.from,
    to: line.from,
    decoration: import_view9.Decoration.line({
      class: `${CSS_CLASSES.LIST_LINE} ${CSS_CLASSES.LIST_LINE_1} ${CSS_CLASSES.PANDOC_LIST_LINE_INDENT}`
    })
  });
  const isDuplicate = duplicateLabels == null ? void 0 : duplicateLabels.has(processedLabel);
  const duplicateInfo = duplicateLineInfo == null ? void 0 : duplicateLineInfo.get(processedLabel);
  const isFirstOccurrence = duplicateInfo && duplicateInfo.firstLine === lineNum;
  if (!cursorInMarker) {
    if (isDuplicate && !isFirstOccurrence && duplicateInfo) {
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view9.Decoration.replace({
          widget: new DuplicateCustomLabelWidget(
            rawLabel,
            duplicateInfo.firstLine,
            duplicateInfo.firstContent,
            view,
            markerStart
          ),
          inclusive: false
        })
      });
    } else {
      decorations.push({
        from: markerStart,
        to: markerEnd,
        decoration: import_view9.Decoration.replace({
          widget: new CustomLabelMarkerWidget(processedLabel, view, markerStart),
          inclusive: false
        })
      });
    }
  } else if (cursorInMarker && placeholderRanges.length > 0) {
    for (let i = 0; i < placeholderRanges.length; i++) {
      if (i !== cursorPlaceholderIndex) {
        const range = placeholderRanges[i];
        const placeholderNumber = placeholderContext == null ? void 0 : placeholderContext.getPlaceholderNumber(range.name);
        if (placeholderNumber !== null && placeholderNumber !== void 0) {
          decorations.push({
            from: range.start,
            to: range.end,
            decoration: import_view9.Decoration.replace({
              widget: new CustomLabelInlineNumberWidget(placeholderNumber.toString(), view),
              inclusive: false,
              block: false
            })
          });
        }
      }
    }
    decorations.push({
      from: markerStart,
      to: markerEnd,
      decoration: import_view9.Decoration.mark({
        class: `${CSS_CLASSES.CM_FORMATTING} ${CSS_CLASSES.CM_FORMATTING_LIST} ${CSS_CLASSES.CUSTOM_LABEL_PROCESSED}`
      })
    });
  }
  const contentStart = line.from + indent.length + fullMarker.length + space.length;
  decorations.push({
    from: contentStart,
    to: line.to,
    decoration: import_view9.Decoration.mark({
      class: `${CSS_CLASSES.CM_LIST_1} ${CSS_CLASSES.CUSTOM_LABEL_ITEM}`
    })
  });
  const contentText = lineText.substring(indent.length + fullMarker.length + space.length);
  if (contentText) {
    const contentRefs = processCustomLabelReferences(
      contentText,
      contentStart,
      customLabels || /* @__PURE__ */ new Map(),
      view,
      cursorPos,
      settings,
      true,
      rawToProcessed,
      placeholderContext
    );
    decorations.push(...contentRefs);
  }
  return decorations;
}
function processCustomLabelReferences(text, from, customLabels, view, cursorPos, settings, isValidLine = true, rawToProcessed, placeholderContext) {
  const decorations = [];
  if (!settings.moreExtendedSyntax) {
    return decorations;
  }
  if (!isValidLine && ListPatterns.isCustomLabelList(text)) {
    return decorations;
  }
  const matches = ListPatterns.findCustomLabelReferences(text);
  matches.forEach((match) => {
    const fullMatch = match[0];
    const rawLabel = match[1];
    let processedLabel = rawToProcessed == null ? void 0 : rawToProcessed.get(rawLabel);
    if (!processedLabel && rawLabel.includes("(#") && placeholderContext) {
      const result = placeholderContext.getProcessedLabel(rawLabel);
      if (result !== null) {
        processedLabel = result;
      }
    }
    if (!processedLabel) {
      processedLabel = rawLabel;
    }
    const matchStart = from + (match.index || 0);
    const matchEnd = matchStart + match[0].length;
    const placeholderMatches = [...rawLabel.matchAll(/\(#([^)]+)\)/g)];
    const placeholderRanges = [];
    for (const phMatch of placeholderMatches) {
      if (phMatch.index !== void 0) {
        const placeholderStart = matchStart + DECORATION_STYLES.CUSTOM_LABEL_PREFIX_LENGTH + phMatch.index;
        const placeholderEnd = placeholderStart + phMatch[0].length;
        placeholderRanges.push({
          start: placeholderStart,
          end: placeholderEnd,
          name: phMatch[1]
        });
      }
    }
    const cursorInReference = cursorPos >= matchStart && cursorPos < matchEnd;
    let cursorPlaceholderIndex = -1;
    for (let i = 0; i < placeholderRanges.length; i++) {
      if (cursorPos >= placeholderRanges[i].start && cursorPos < placeholderRanges[i].end) {
        cursorPlaceholderIndex = i;
        break;
      }
    }
    const cursorInPlaceholder = cursorPlaceholderIndex !== -1;
    let isValid = false;
    let content;
    if (customLabels.has(processedLabel)) {
      isValid = true;
      content = customLabels.get(processedLabel);
    } else if (placeholderContext) {
      const validatedLabel = placeholderContext.getProcessedLabel(rawLabel);
      if (validatedLabel !== null) {
        isValid = true;
        processedLabel = validatedLabel;
        const baseLabel = processedLabel.replace(/'+$/, "");
        for (const [label, labelContent] of customLabels) {
          if (label.startsWith(baseLabel)) {
            content = labelContent;
            break;
          }
        }
      }
    }
    if (isValid) {
      if (!cursorInReference) {
        decorations.push({
          from: matchStart,
          to: matchEnd,
          decoration: import_view9.Decoration.replace({
            widget: new CustomLabelReferenceWidget(processedLabel, content, view, matchStart),
            inclusive: false
          })
        });
      } else if (cursorInReference && placeholderRanges.length > 0) {
        for (let i = 0; i < placeholderRanges.length; i++) {
          if (i !== cursorPlaceholderIndex) {
            const range = placeholderRanges[i];
            const placeholderNumber = placeholderContext == null ? void 0 : placeholderContext.getPlaceholderNumber(range.name);
            if (placeholderNumber !== null && placeholderNumber !== void 0) {
              decorations.push({
                from: range.start,
                to: range.end,
                decoration: import_view9.Decoration.replace({
                  widget: new CustomLabelInlineNumberWidget(placeholderNumber.toString(), view),
                  inclusive: false,
                  block: false
                })
              });
            }
          }
        }
        decorations.push({
          from: matchStart,
          to: matchEnd,
          decoration: import_view9.Decoration.mark({
            class: CSS_CLASSES.CUSTOM_LABEL_REFERENCE_PROCESSED
          })
        });
      }
    }
  });
  return decorations;
}

// src/decorations/pandocExtendedMarkdownExtension.ts
var pandocExtendedMarkdownPlugin = (getSettings, getDocPath) => import_view10.ViewPlugin.fromClass(
  class PandocExtendedMarkdownView {
    constructor(view) {
      const settings = getSettings();
      const docPath = getDocPath();
      const placeholderContext = docPath ? pluginStateManager.getDocumentCounters(docPath).placeholderContext : void 0;
      this.scanResult = scanExampleLabels(view, settings);
      this.customLabelScanResult = scanCustomLabels(view.state.doc, settings, placeholderContext);
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      const prevLivePreview = update.startState.field(import_obsidian5.editorLivePreviewField);
      const currLivePreview = update.state.field(import_obsidian5.editorLivePreviewField);
      const livePreviewChanged = prevLivePreview !== currLivePreview;
      if (update.docChanged || update.viewportChanged || update.selectionSet || livePreviewChanged) {
        if (update.docChanged) {
          const settings = getSettings();
          const docPath = getDocPath();
          const placeholderContext = docPath ? pluginStateManager.getDocumentCounters(docPath).placeholderContext : void 0;
          this.scanResult = scanExampleLabels(update.view, settings);
          this.customLabelScanResult = scanCustomLabels(update.view.state.doc, settings, placeholderContext);
        }
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const builder = new import_state.RangeSetBuilder();
      const isLivePreview = view.state.field(import_obsidian5.editorLivePreviewField);
      if (!isLivePreview) {
        return builder.finish();
      }
      const settings = getSettings();
      const lines = view.state.doc.toString().split("\n");
      const selection = view.state.selection.main;
      const cursorPos = selection.head;
      const decorations = [];
      const hashCounter = { value: 1 };
      const invalidListBlocks = ListBlockValidator.validateListBlocks(lines, settings);
      const invalidCustomLabelBlocks = validateCustomLabelBlocks(view.state.doc, settings);
      for (let lineNum = 1; lineNum <= view.state.doc.lines; lineNum++) {
        const line = view.state.doc.line(lineNum);
        const lineText = line.text;
        const processorContext = {
          line,
          lineNum,
          lineText,
          cursorPos,
          view,
          invalidListBlocks,
          settings,
          exampleLabels: this.scanResult.exampleLabels,
          exampleLineNumbers: this.scanResult.exampleLineNumbers,
          duplicateLabels: this.scanResult.duplicateLabels,
          duplicateLabelContent: this.scanResult.duplicateLabelContent
        };
        const hashDecorations = processHashList(processorContext, hashCounter);
        if (hashDecorations) {
          decorations.push(...hashDecorations);
          continue;
        }
        const fancyDecorations = processFancyList(processorContext);
        if (fancyDecorations) {
          decorations.push(...fancyDecorations);
          continue;
        }
        const exampleDecorations = processExampleList(processorContext);
        if (exampleDecorations) {
          decorations.push(...exampleDecorations);
          continue;
        }
        if (settings.moreExtendedSyntax) {
          const customLabelContext = {
            line,
            lineNum,
            lineText,
            cursorPos,
            view,
            invalidListBlocks: invalidCustomLabelBlocks,
            settings,
            customLabels: this.customLabelScanResult.customLabels,
            rawToProcessed: this.customLabelScanResult.rawToProcessed,
            duplicateLabels: this.customLabelScanResult.duplicateLabels,
            duplicateLineInfo: this.customLabelScanResult.duplicateLineInfo,
            placeholderContext: this.customLabelScanResult.placeholderContext
          };
          const customLabelDecorations = processCustomLabelList(customLabelContext);
          if (customLabelDecorations) {
            decorations.push(...customLabelDecorations);
            continue;
          }
        }
        const definitionContext = {
          line,
          lineNum,
          lineText,
          cursorPos,
          view,
          invalidListBlocks,
          settings,
          lines
        };
        const defItemDecorations = processDefinitionItem(definitionContext);
        if (defItemDecorations) {
          decorations.push(...defItemDecorations);
        }
        const defParagraphDecorations = processDefinitionParagraph(definitionContext);
        if (defParagraphDecorations) {
          decorations.push(...defParagraphDecorations);
          continue;
        }
        const defTermDecorations = processDefinitionTerm(definitionContext);
        if (defTermDecorations) {
          decorations.push(...defTermDecorations);
        }
        const inlineContext = {
          line,
          lineText,
          cursorPos,
          exampleLabels: this.scanResult.exampleLabels,
          exampleContent: this.scanResult.exampleContent
        };
        decorations.push(...processExampleReferences(inlineContext));
        decorations.push(...processSuperscripts(inlineContext));
        decorations.push(...processSubscripts(inlineContext));
        if (settings.moreExtendedSyntax) {
          const isValidLine = !invalidCustomLabelBlocks.has(lineNum - 1);
          const customLabelRefs = processCustomLabelReferences(
            lineText,
            line.from,
            this.customLabelScanResult.customLabels,
            view,
            cursorPos,
            settings,
            isValidLine,
            this.customLabelScanResult.rawToProcessed,
            this.customLabelScanResult.placeholderContext
          );
          decorations.push(...customLabelRefs);
        }
      }
      decorations.sort((a, b) => a.from - b.from || a.to - b.to);
      for (const { from, to, decoration } of decorations) {
        builder.add(from, to, decoration);
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
function pandocExtendedMarkdownExtension(getSettings, getDocPath) {
  return pandocExtendedMarkdownPlugin(getSettings, getDocPath);
}

// src/types/obsidian-extended.ts
function isMarkdownPreviewSection(element) {
  return element !== null && element.classList.contains("markdown-preview-section");
}
function getSectionInfo(element) {
  if (!isMarkdownPreviewSection(element)) {
    return null;
  }
  if (typeof element.getSection === "function") {
    try {
      return element.getSection();
    } catch (error) {
      return null;
    }
  }
  return null;
}

// src/parsers/fancyListParser.ts
function parseFancyListMarker(line) {
  const hashMatch = ListPatterns.isHashList(line);
  if (hashMatch) {
    return {
      indent: hashMatch[1],
      marker: hashMatch[2],
      type: "hash",
      delimiter: ".",
      value: void 0
    };
  }
  const match = ListPatterns.isFancyList(line);
  if (!match) {
    return null;
  }
  const indent = match[1];
  const marker = match[2];
  const value = match[3];
  const delimiter = match[4];
  let type;
  if (ListPatterns.DECIMAL.test(value)) {
    return null;
  } else if (ListPatterns.ROMAN_UPPER.test(value)) {
    type = "upper-roman";
  } else if (ListPatterns.ROMAN_LOWER.test(value)) {
    type = "lower-roman";
  } else if (ListPatterns.ALPHA_UPPER.test(value)) {
    type = "upper-alpha";
  } else if (ListPatterns.ALPHA_LOWER.test(value)) {
    type = "lower-alpha";
  } else {
    return null;
  }
  return {
    indent,
    marker,
    type,
    delimiter,
    value: value === "#" ? void 0 : value
  };
}

// src/parsers/exampleListParser.ts
var import_obsidian6 = require("obsidian");
function parseExampleListMarker(line) {
  const match = ListPatterns.isExampleList(line);
  if (!match) {
    return null;
  }
  return {
    indent: match[1],
    originalMarker: match[2],
    label: match[3] || void 0
  };
}

// src/parsers/superSubParser.ts
function extractContent(match, delimiter) {
  const content = match.slice(1, -1);
  return ListPatterns.unescapeSpaces(content);
}
function findSuperSubInText(text) {
  const matches = [];
  const superscripts = ListPatterns.findSuperscripts(text);
  superscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "^"),
        type: "superscript"
      });
    }
  });
  const subscripts = ListPatterns.findSubscripts(text);
  subscripts.forEach((match) => {
    if (match.index !== void 0) {
      matches.push({
        index: match.index,
        length: match[0].length,
        content: extractContent(match[0], "~"),
        type: "subscript"
      });
    }
  });
  matches.sort((a, b) => a.index - b.index);
  return matches;
}
function processSuperSub(element) {
  const walker = document.createTreeWalker(
    element,
    NodeFilter.SHOW_TEXT,
    {
      acceptNode: (node) => {
        const parent = node.parentElement;
        if (parent && (parent.classList.contains(CSS_CLASSES.SUPERSCRIPT) || parent.classList.contains(CSS_CLASSES.SUBSCRIPT))) {
          return NodeFilter.FILTER_REJECT;
        }
        return NodeFilter.FILTER_ACCEPT;
      }
    }
  );
  const nodesToReplace = [];
  while (walker.nextNode()) {
    const node = walker.currentNode;
    const text = node.textContent || "";
    const matches = findSuperSubInText(text);
    if (matches.length > 0) {
      nodesToReplace.push({ node, matches });
    }
  }
  nodesToReplace.forEach(({ node, matches }) => {
    const parent = node.parentNode;
    if (!parent) return;
    let lastIndex = 0;
    const fragments = [];
    matches.forEach((match) => {
      if (match.index > lastIndex) {
        fragments.push(node.textContent.substring(lastIndex, match.index));
      }
      const elem = match.type === "superscript" ? document.createElement("sup") : document.createElement("sub");
      elem.className = match.type === "superscript" ? CSS_CLASSES.SUPERSCRIPT : CSS_CLASSES.SUBSCRIPT;
      elem.textContent = match.content;
      fragments.push(elem);
      lastIndex = match.index + match.length;
    });
    if (lastIndex < node.textContent.length) {
      fragments.push(node.textContent.substring(lastIndex));
    }
    fragments.forEach((fragment) => {
      if (typeof fragment === "string") {
        parent.insertBefore(document.createTextNode(fragment), node);
      } else {
        parent.insertBefore(fragment, node);
      }
    });
    parent.removeChild(node);
  });
}

// src/parsers/definitionListParser.ts
function parseDefinitionListMarker(line) {
  const termMatch = line.match(ListPatterns.DEFINITION_TERM_PATTERN);
  if (termMatch && !line.includes("*") && !line.includes("-") && !line.match(ListPatterns.NUMBERED_LIST)) {
    const nextLineIndex = line.indexOf("\n");
    if (nextLineIndex === -1 || nextLineIndex === line.length - 1) {
      return {
        type: "term",
        indent: "",
        marker: "",
        content: termMatch[1].trim()
      };
    }
  }
  const defMatch = ListPatterns.isDefinitionMarker(line);
  if (defMatch) {
    const content = line.substring(defMatch[0].length);
    return {
      type: "definition",
      indent: defMatch[1],
      marker: defMatch[2],
      content
    };
  }
  return null;
}

// src/parsers/readingModeParser.ts
var ReadingModeParser = class {
  /**
   * Parse a single line and identify its type and data
   */
  parseLine(line, context) {
    const hashMatch = ListPatterns.isHashList(line);
    if (hashMatch) {
      return {
        type: "hash",
        content: line,
        metadata: {
          indent: hashMatch[1],
          marker: hashMatch[2],
          spacing: hashMatch[3],
          content: line.substring(hashMatch[1].length + hashMatch[2].length + hashMatch[3].length)
        }
      };
    }
    const fancyMarker = parseFancyListMarker(line);
    if (fancyMarker && fancyMarker.type !== "hash") {
      return {
        type: "fancy",
        content: line,
        metadata: {
          type: fancyMarker.type,
          marker: fancyMarker.marker,
          indent: fancyMarker.indent,
          content: line.substring(fancyMarker.indent.length + fancyMarker.marker.length + 1)
        }
      };
    }
    if (context == null ? void 0 : context.isInParagraph) {
      const exampleMarker = parseExampleListMarker(line);
      if (exampleMarker) {
        const contentStart = exampleMarker.indent.length + exampleMarker.originalMarker.length + 1;
        return {
          type: "example",
          content: line,
          metadata: {
            indent: exampleMarker.indent,
            originalMarker: exampleMarker.originalMarker,
            label: exampleMarker.label,
            content: line.substring(contentStart)
          }
        };
      }
    }
    const defMarker = parseDefinitionListMarker(line);
    if (defMarker && defMarker.type === "definition") {
      return {
        type: "definition-item",
        content: line,
        metadata: {
          content: defMarker.content
        }
      };
    }
    if ((context == null ? void 0 : context.nextLine) && ListPatterns.isDefinitionMarker(context.nextLine)) {
      return {
        type: "definition-term",
        content: line,
        metadata: {
          content: line.trim()
        }
      };
    }
    const references = this.findExampleReferences(line);
    if (references.length > 0) {
      return {
        type: "reference",
        content: line,
        metadata: {
          references
        }
      };
    }
    return {
      type: "plain",
      content: line
    };
  }
  /**
   * Parse multiple lines with context
   */
  parseLines(lines, isInParagraph = false) {
    return lines.map((line, index) => {
      const nextLine = index < lines.length - 1 ? lines[index + 1] : void 0;
      return this.parseLine(line, { nextLine, isInParagraph });
    });
  }
  /**
   * Find example references in text
   */
  findExampleReferences(text) {
    const references = [];
    const regex = ListPatterns.EXAMPLE_REFERENCE;
    let match;
    while ((match = regex.exec(text)) !== null) {
      references.push({
        fullMatch: match[0],
        label: match[1],
        startIndex: match.index,
        endIndex: match.index + match[0].length
      });
    }
    return references;
  }
  /**
   * Check if strict validation should be applied
   */
  shouldValidateStrict(parsedLine, lines, currentLineIndex) {
    if (parsedLine.type !== "fancy") {
      return false;
    }
    return true;
  }
};

// src/renderers/readingModeRenderer.ts
var import_obsidian7 = require("obsidian");
var ReadingModeRenderer = class {
  /**
   * Render a parsed line to DOM elements
   */
  renderLine(parsedLine, context, lineNumber) {
    switch (parsedLine.type) {
      case "hash":
        return this.renderHashList(parsedLine.metadata, lineNumber);
      case "fancy":
        return this.renderFancyList(parsedLine.metadata);
      case "example":
        return this.renderExampleList(parsedLine.metadata, lineNumber);
      case "definition-term":
        return this.renderDefinitionTerm(parsedLine.metadata);
      case "definition-item":
        return this.renderDefinitionItem(parsedLine.metadata);
      case "reference":
        return this.renderWithReferences(parsedLine.content, parsedLine.metadata, context);
      default:
        return [document.createTextNode(parsedLine.content)];
    }
  }
  /**
   * Render multiple parsed lines with line breaks
   */
  renderLines(parsedLines, context, numberProvider) {
    const elements = [];
    parsedLines.forEach((parsedLine, index) => {
      if (index > 0) {
        if (context.strictLineBreaks) {
          elements.push(document.createElement("br"));
        }
        elements.push(document.createTextNode("\n"));
      }
      let lineNumber;
      if (numberProvider) {
        if (parsedLine.type === "hash") {
          lineNumber = numberProvider("hash", index);
        } else if (parsedLine.type === "example") {
          lineNumber = numberProvider("example", index);
        }
      }
      const lineElements = this.renderLine(parsedLine, context, lineNumber);
      elements.push(...lineElements);
    });
    return elements;
  }
  /**
   * Render hash auto-numbering list
   */
  renderHashList(data, number) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-hash`;
    span.textContent = `${number || "#"}. `;
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render fancy list marker
   */
  renderFancyList(data) {
    const elements = [];
    const span = document.createElement("span");
    span.className = `${CSS_CLASSES.FANCY_LIST}-${data.type}`;
    span.textContent = data.marker + " ";
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render example list
   */
  renderExampleList(data, number) {
    const elements = [];
    const span = document.createElement("span");
    span.className = CSS_CLASSES.EXAMPLE_LIST;
    span.textContent = `(${number || "@"}) `;
    if (number) {
      span.dataset.exampleNumber = String(number);
    }
    elements.push(span);
    if (data.content) {
      elements.push(document.createTextNode(data.content));
    }
    return elements;
  }
  /**
   * Render definition term
   */
  renderDefinitionTerm(data) {
    const strong = document.createElement("strong");
    const u = document.createElement("u");
    u.textContent = data.content;
    strong.appendChild(u);
    return [strong];
  }
  /**
   * Render definition item
   */
  renderDefinitionItem(data) {
    const elements = [];
    const span = document.createElement("span");
    span.textContent = "\u2022 ";
    elements.push(span);
    elements.push(document.createTextNode(data.content));
    return elements;
  }
  /**
   * Render text with example references
   */
  renderWithReferences(text, data, context) {
    const elements = [];
    let lastIndex = 0;
    data.references.forEach((ref) => {
      var _a, _b;
      if (ref.startIndex > lastIndex) {
        elements.push(document.createTextNode(text.substring(lastIndex, ref.startIndex)));
      }
      const exampleNumber = (_a = context.getExampleNumber) == null ? void 0 : _a.call(context, ref.label);
      if (exampleNumber !== void 0) {
        const span = document.createElement("span");
        span.className = CSS_CLASSES.EXAMPLE_REF;
        span.textContent = `(${exampleNumber})`;
        const tooltipText = (_b = context.getExampleContent) == null ? void 0 : _b.call(context, ref.label);
        if (tooltipText) {
          (0, import_obsidian7.setTooltip)(span, tooltipText, { delay: DECORATION_STYLES.TOOLTIP_DELAY_MS });
        }
        elements.push(span);
      } else {
        elements.push(document.createTextNode(ref.fullMatch));
      }
      lastIndex = ref.endIndex;
    });
    if (lastIndex < text.length) {
      elements.push(document.createTextNode(text.substring(lastIndex)));
    }
    return elements;
  }
  /**
   * Create a line break element
   */
  createLineBreak() {
    return document.createElement("br");
  }
  /**
   * Create a newline text node
   */
  createNewline() {
    return document.createTextNode("\n");
  }
};

// src/parsers/customLabelListParser.ts
function processCustomLabelLists(element, context, placeholderContext) {
  if (!element.textContent || !element.textContent.includes("{::")) {
    return;
  }
  if (placeholderContext) {
    const allElements = element.querySelectorAll("p, li");
    allElements.forEach((elem) => {
      const text = elem.textContent || "";
      const lines = text.split("\n");
      for (const line of lines) {
        const listMatch = ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT.exec(line);
        if (listMatch) {
          const labelPart = listMatch[3];
          placeholderContext.processLabel(labelPart);
        }
      }
    });
  }
  const paragraphs = element.querySelectorAll("p");
  paragraphs.forEach((p) => {
    processElement(p, placeholderContext);
  });
  const listItems = element.querySelectorAll("li");
  listItems.forEach((li) => {
    processElement(li, placeholderContext);
    if (li.querySelector(`.${CSS_CLASSES.PANDOC_LIST_MARKER}`)) {
      li.classList.add("pandoc-custom-label-item");
    }
  });
}
function processTextNode(node, container, placeholderContext) {
  const text = node.textContent || "";
  const listMatch = text.match(ListPatterns.CUSTOM_LABEL_LIST_WITH_CONTENT);
  if (listMatch) {
    const indent = listMatch[1];
    const rawLabel = listMatch[3];
    const space = listMatch[4];
    const rest = listMatch[5];
    const processedLabel = placeholderContext ? placeholderContext.processLabel(rawLabel) : rawLabel;
    if (indent) {
      container.appendChild(document.createTextNode(indent));
    }
    const markerSpan = document.createElement("span");
    markerSpan.className = CSS_CLASSES.PANDOC_LIST_MARKER;
    markerSpan.textContent = `(${processedLabel})`;
    container.appendChild(markerSpan);
    container.appendChild(document.createTextNode(space));
    processReferencesInText(rest, container, placeholderContext);
  } else {
    processReferencesInText(text, container, placeholderContext);
  }
}
function processReferencesInText(text, container, placeholderContext) {
  const refPattern = ListPatterns.CUSTOM_LABEL_REFERENCE;
  let lastIndex = 0;
  let match;
  while ((match = refPattern.exec(text)) !== null) {
    if (match.index > lastIndex) {
      container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
    }
    const rawLabel = match[1];
    const processedLabel = placeholderContext ? placeholderContext.getProcessedLabel(rawLabel) : rawLabel;
    if (processedLabel === null) {
      container.appendChild(document.createTextNode(match[0]));
    } else {
      const refSpan = document.createElement("span");
      refSpan.className = CSS_CLASSES.EXAMPLE_REF;
      refSpan.setAttribute("data-custom-label-ref", processedLabel);
      refSpan.textContent = `(${processedLabel})`;
      container.appendChild(refSpan);
    }
    lastIndex = refPattern.lastIndex;
  }
  if (lastIndex < text.length) {
    container.appendChild(document.createTextNode(text.substring(lastIndex)));
  }
}
function processElement(elem, placeholderContext) {
  if (elem.querySelector("code, pre") || elem.closest("code, pre")) {
    return;
  }
  if (!elem.textContent || !elem.textContent.includes("{::")) {
    return;
  }
  const newContainer = document.createElement("div");
  const childNodes = Array.from(elem.childNodes);
  for (const node of childNodes) {
    if (node.nodeType === Node.TEXT_NODE) {
      const text = node.textContent || "";
      const lines = text.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (i > 0) {
          newContainer.appendChild(document.createTextNode("\n"));
        }
        if (lines[i]) {
          processTextNode({ textContent: lines[i] }, newContainer, placeholderContext);
        }
      }
    } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "BR") {
      newContainer.appendChild(node.cloneNode(true));
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const elemNode = node;
      if (elemNode.textContent && elemNode.textContent.includes("{::")) {
        const clonedElem = elemNode.cloneNode(false);
        const tempContainer = document.createElement("div");
        Array.from(elemNode.childNodes).forEach((child) => {
          tempContainer.appendChild(child.cloneNode(true));
        });
        processElement(tempContainer, placeholderContext);
        while (tempContainer.firstChild) {
          clonedElem.appendChild(tempContainer.firstChild);
        }
        newContainer.appendChild(clonedElem);
      } else {
        newContainer.appendChild(node.cloneNode(true));
      }
    } else {
      newContainer.appendChild(node.cloneNode(true));
    }
  }
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
  while (newContainer.firstChild) {
    elem.appendChild(newContainer.firstChild);
  }
}

// src/pandocValidator.ts
function isStrictPandocFormatting(context, strictMode) {
  if (!strictMode) {
    return true;
  }
  const { lines, currentLine } = context;
  const line = lines[currentLine];
  const isPartOfListBlock = currentLine > 0 && isListItem(lines[currentLine - 1], false);
  if (currentLine > 0 && !isPartOfListBlock) {
    const prevLine = lines[currentLine - 1];
    if (prevLine.trim() !== "") {
      return false;
    }
  }
  const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
  if (capitalLetterMatch && capitalLetterMatch[3] === ".") {
    if (capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      return false;
    }
  }
  let isLastItemInList = true;
  if (currentLine < lines.length - 1) {
    const nextLine = lines[currentLine + 1];
    const nextIsListItem = isListItem(nextLine, false);
    if (!nextIsListItem && nextLine.trim() !== "") {
      return false;
    }
    if (nextIsListItem) {
      isLastItemInList = false;
    }
  }
  return true;
}
function isListItem(line, includeCustomLabels = false) {
  if (ListPatterns.FANCY_LIST_WITH_NUMBERS.test(line) || ListPatterns.STANDARD_ORDERED_LIST.test(line) || ListPatterns.UNORDERED_LIST.test(line) || ListPatterns.isExampleList(line) || ListPatterns.isDefinitionMarker(line)) {
    return true;
  }
  if (includeCustomLabels && ListPatterns.isCustomLabelList(line)) {
    return true;
  }
  return false;
}
function formatToPandocStandard(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const result = [];
  let inListBlock = false;
  let lastWasEmpty = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList && !inListBlock) {
      if (result.length > 0 && !lastWasEmpty) {
        result.push("");
      }
      inListBlock = true;
    }
    if (!isCurrentLineList && !isEmpty && inListBlock) {
      if (!lastWasEmpty) {
        result.push("");
      }
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (result.length > 0 && !lastWasEmpty && i > 0) {
        result.push("");
      }
      let formattedLine = line;
      result.push(formattedLine);
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        result.push("");
        lastWasEmpty = true;
      } else {
        lastWasEmpty = false;
      }
      continue;
    }
    const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
    if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
      const formattedLine = line.replace(ListPatterns.CAPITAL_LETTER_REPLACE, "$1$2  ");
      result.push(formattedLine);
    } else {
      result.push(line);
    }
    lastWasEmpty = isEmpty;
  }
  const cleanedResult = [];
  let prevWasEmpty = false;
  for (const line of result) {
    if (line.trim() === "") {
      if (!prevWasEmpty) {
        cleanedResult.push(line);
        prevWasEmpty = true;
      }
    } else {
      cleanedResult.push(line);
      prevWasEmpty = false;
    }
  }
  return cleanedResult.join("\n");
}
function checkPandocFormatting(content, moreExtendedSyntax = false) {
  const lines = content.split("\n");
  const issues = [];
  let inListBlock = false;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const isCurrentLineList = isListItem(line, moreExtendedSyntax);
    const isCurrentLineHeading = ListPatterns.isHeading(line);
    const isEmpty = line.trim() === "";
    if (isCurrentLineList) {
      if (!inListBlock && i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "List should have an empty line before it"
        });
      }
      const capitalLetterMatch = line.match(ListPatterns.CAPITAL_LETTER_LIST);
      if (capitalLetterMatch && capitalLetterMatch[4].length < INDENTATION.DOUBLE_SPACE) {
        issues.push({
          line: i + 1,
          message: "Capital letter list with period requires at least 2 spaces after marker"
        });
      }
      inListBlock = true;
    } else if (!isEmpty && inListBlock) {
      if (i > 0 && isListItem(lines[i - 1])) {
        issues.push({
          line: i,
          message: "List should have an empty line after it"
        });
      }
      inListBlock = false;
    } else if (isEmpty) {
      inListBlock = false;
    }
    if (isCurrentLineHeading) {
      if (i > 0 && lines[i - 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line before it"
        });
      }
      if (i < lines.length - 1 && lines[i + 1].trim() !== "") {
        issues.push({
          line: i + 1,
          message: "Heading should have an empty line after it"
        });
      }
    }
  }
  return issues;
}

// src/parsers/readingModeProcessor.ts
function processReadingMode(element, context, config) {
  const docPath = context.sourcePath || "unknown";
  const parser = new ReadingModeParser();
  const renderer = new ReadingModeRenderer();
  const elementsToProcess = element.querySelectorAll("p, li");
  let validationLines = [];
  if (config.strictPandocMode) {
    const section = element.closest(".markdown-preview-section");
    const sectionInfo = getSectionInfo(section);
    if (sectionInfo == null ? void 0 : sectionInfo.text) {
      validationLines = sectionInfo.text.split("\n");
    }
  }
  elementsToProcess.forEach((elem) => {
    if (elem.closest("h1, h2, h3, h4, h5, h6")) {
      return;
    }
    if (pluginStateManager.isElementProcessed(elem, "pandoc-processed", docPath)) {
      return;
    }
    processElementTextNodes(elem, parser, renderer, config, docPath, validationLines);
    pluginStateManager.markElementProcessed(elem, "pandoc-processed", true);
  });
  if (config.enableSuperSubscripts) {
    processSuperSub(element);
  }
  if (config.enableCustomLabelLists) {
    const counters = pluginStateManager.getDocumentCounters(docPath);
    processCustomLabelLists(element, context, counters.placeholderContext);
  }
}
function processElementTextNodes(elem, parser, renderer, config, docPath, validationLines) {
  const walker = document.createTreeWalker(
    elem,
    NodeFilter.SHOW_TEXT,
    null
  );
  const nodesToProcess = [];
  while (walker.nextNode()) {
    nodesToProcess.push(walker.currentNode);
  }
  nodesToProcess.forEach((node) => {
    const parent = node.parentNode;
    if (!parent) return;
    if (parent.nodeName === "CODE" || parent.nodeName === "PRE") {
      return;
    }
    const text = node.textContent || "";
    if (!containsPandocSyntax(text, config)) {
      return;
    }
    const isInParagraph = parent.nodeName === "P";
    const lines = text.split("\n");
    const parsedLines = parser.parseLines(lines, isInParagraph);
    if (config.strictPandocMode) {
      parsedLines.forEach((parsedLine, index) => {
        if (parsedLine.type === "fancy" && validationLines.length > 0) {
          if (!validateListInStrictMode(lines[index], validationLines, config)) {
            parsedLine.type = "plain";
          }
        }
      });
    }
    const renderContext = {
      strictLineBreaks: config.strictLineBreaks,
      getExampleNumber: (label) => pluginStateManager.getLabeledExampleNumber(docPath, label),
      getExampleContent: (label) => pluginStateManager.getLabeledExampleContent(docPath, label)
    };
    const numberProvider = (type, index) => {
      var _a;
      const parsedLine = parsedLines[index];
      if (type === "hash") {
        return pluginStateManager.incrementHashCounter(docPath);
      }
      if (type === "example" && parsedLine.type === "example") {
        const metadata = parsedLine.metadata;
        const number = pluginStateManager.incrementExampleCounter(docPath);
        if (metadata.label) {
          pluginStateManager.setLabeledExample(
            docPath,
            metadata.label,
            number,
            (_a = metadata.content) == null ? void 0 : _a.trim()
          );
        }
        return number;
      }
      return 0;
    };
    const newElements = renderer.renderLines(parsedLines, renderContext, numberProvider);
    if (newElements.length > 0) {
      newElements.forEach((elem2) => {
        parent.insertBefore(elem2, node);
      });
      parent.removeChild(node);
    }
  });
}
function containsPandocSyntax(text, config) {
  const hasBasicSyntax = ListPatterns.isHashList(text) || ListPatterns.isFancyList(text) || ListPatterns.isExampleList(text) || ListPatterns.isDefinitionMarker(text) || ListPatterns.findExampleReferences(text).length > 0;
  const hasCustomLabelSyntax = (config == null ? void 0 : config.enableCustomLabelLists) && (ListPatterns.isCustomLabelList(text) || ListPatterns.findCustomLabelReferences(text).length > 0);
  return hasBasicSyntax || hasCustomLabelSyntax;
}
function validateListInStrictMode(line, documentLines, config) {
  let lineNum = -1;
  for (let i = 0; i < documentLines.length; i++) {
    if (documentLines[i].includes(line.trim())) {
      lineNum = i;
      break;
    }
  }
  if (lineNum >= 0) {
    const validationContext = {
      lines: documentLines,
      currentLine: lineNum
    };
    return isStrictPandocFormatting(validationContext, config.strictPandocMode);
  }
  return true;
}

// src/exampleReferenceSuggest.ts
var import_obsidian8 = require("obsidian");
var ExampleReferenceSuggest = class extends import_obsidian8.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.contains("(@")) return null;
    const matches = ListPatterns.findExampleRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterAt = line.substring(startIndex + 2);
    if (afterAt.contains(")")) return null;
    const query = afterAt;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  getSuggestions(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const lines = doc.split("\n");
    const exampleData = /* @__PURE__ */ new Map();
    let counter = 1;
    for (const line of lines) {
      const match = ListPatterns.isExampleList(line);
      if (match) {
        const label = match[3];
        if (label) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!exampleData.has(label)) {
            exampleData.set(label, { number: counter, text });
          }
        }
        counter++;
      }
    }
    const suggestions = [];
    for (const [label, data] of exampleData) {
      if (!query || label.toLowerCase().startsWith(query.toLowerCase())) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        suggestions.push({
          label,
          number: data.number,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  renderSuggestion(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    title.setText(`@${suggestion.label}`);
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  selectSuggestion(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingParen = afterCursor.startsWith(")");
    let replacement;
    if (hasClosingParen) {
      replacement = `(@${suggestion.label}`;
    } else {
      replacement = `(@${suggestion.label})`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingParen) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/customLabelReferenceSuggest.ts
var import_obsidian10 = require("obsidian");

// src/utils/errorHandler.ts
var import_obsidian9 = require("obsidian");
var PluginError = class extends Error {
  constructor(message, code, recoverable = true) {
    super(message);
    this.code = code;
    this.recoverable = recoverable;
    this.name = "PandocExtendedMarkdownPluginError";
  }
};
function withErrorBoundary(fn, fallback, context) {
  try {
    return fn();
  } catch (error) {
    handleError(error, context);
    return fallback;
  }
}
function handleError(error, context) {
  let message = "An unexpected error occurred";
  let showNotice = true;
  if (error instanceof PluginError) {
    message = error.message;
    showNotice = error.recoverable;
    if (!error.recoverable) {
      throw error;
    }
  } else if (error instanceof Error) {
    message = error.message;
  } else if (typeof error === "string") {
    message = error;
  }
  if (showNotice) {
    new import_obsidian9.Notice(`Pandoc Extended Markdown: ${context} failed. ${message}`);
  }
}

// src/customLabelReferenceSuggest.ts
var CustomLabelReferenceSuggest = class extends import_obsidian10.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    if (!this.plugin.settings.moreExtendedSyntax) return null;
    const line = editor.getLine(cursor.line).substring(0, cursor.ch);
    if (!line.includes("{::")) return null;
    const matches = ListPatterns.findCustomLabelRefStarts(line);
    if (matches.length === 0) return null;
    const lastMatch = matches[matches.length - 1];
    const startIndex = lastMatch.index;
    const afterStart = line.substring(startIndex + 3);
    if (afterStart.includes("}")) return null;
    const query = afterStart;
    return {
      start: {
        ch: startIndex,
        line: cursor.line
      },
      end: cursor,
      query
    };
  }
  /**
   * Scans the document for custom label definitions.
   * @returns Map of raw labels to their content
   */
  scanDocumentForLabels(doc) {
    const lines = doc.split("\n");
    const labelData = /* @__PURE__ */ new Map();
    for (const line of lines) {
      const match = ListPatterns.isCustomLabelList(line);
      if (match) {
        const rawLabel = match[3];
        if (rawLabel) {
          const markerEnd = match[0].length;
          const text = line.substring(markerEnd).trim();
          if (!labelData.has(rawLabel)) {
            labelData.set(rawLabel, { text, rawLabel });
          }
        }
      }
    }
    return labelData;
  }
  /**
   * Processes a label to extract placeholder information.
   */
  extractPlaceholderParts(rawLabel, placeholderContext) {
    const placeholderParts = [];
    const regex = /\(#([^)]+)\)/g;
    let match;
    while ((match = regex.exec(rawLabel)) !== null) {
      const placeholderName = match[1];
      const placeholderNumber = placeholderContext.getPlaceholderNumber(placeholderName);
      if (placeholderNumber !== null) {
        placeholderParts.push({
          original: match[0],
          replacement: placeholderNumber.toString(),
          index: match.index
        });
      }
    }
    return placeholderParts.length > 0 ? placeholderParts : null;
  }
  getSuggestions(context) {
    return withErrorBoundary(() => this.getSuggestionsInternal(context), [], "CustomLabelReferenceSuggest.getSuggestions");
  }
  getSuggestionsInternal(context) {
    const { query } = context;
    const doc = context.editor.getValue();
    const labelData = this.scanDocumentForLabels(doc);
    const placeholderContext = new PlaceholderContext();
    for (const [rawLabel] of labelData) {
      if (/\(#[^)]+\)/.test(rawLabel)) {
        placeholderContext.processLabel(rawLabel);
      }
    }
    const suggestions = [];
    for (const [rawLabel, data] of labelData) {
      let processedLabel = null;
      if (/\(#[^)]+\)/.test(rawLabel)) {
        processedLabel = placeholderContext.processLabel(rawLabel);
      }
      const matchesRaw = !query || rawLabel.toLowerCase().startsWith(query.toLowerCase());
      const matchesProcessed = processedLabel && (!query || processedLabel.toLowerCase().startsWith(query.toLowerCase()));
      if (matchesRaw || matchesProcessed) {
        let previewText = data.text;
        if (previewText.length > 30) {
          previewText = previewText.substring(0, 30) + "...";
        }
        let displayLabel = processedLabel;
        let placeholderParts = null;
        if (processedLabel) {
          placeholderParts = this.extractPlaceholderParts(rawLabel, placeholderContext);
        }
        suggestions.push({
          label: rawLabel,
          displayLabel,
          placeholderParts,
          previewText: previewText || "(no description)"
        });
      }
    }
    suggestions.sort((a, b) => a.label.localeCompare(b.label));
    return suggestions;
  }
  /**
   * Renders a suggestion item with styled placeholder display.
   */
  renderSuggestion(suggestion, el) {
    withErrorBoundary(() => this.renderSuggestionInternal(suggestion, el), void 0, "CustomLabelReferenceSuggest.renderSuggestion");
  }
  renderSuggestionInternal(suggestion, el) {
    const container = el.createDiv({ cls: CSS_CLASSES.SUGGESTION_CONTENT });
    const title = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_TITLE });
    if (suggestion.displayLabel && suggestion.placeholderParts) {
      title.setText("::");
      let lastIndex = 0;
      const sortedParts = [...suggestion.placeholderParts].sort((a, b) => a.index - b.index);
      for (const part of sortedParts) {
        if (part.index > lastIndex) {
          const beforeText = suggestion.label.substring(lastIndex, part.index);
          title.createSpan().setText(beforeText);
        }
        const numberSpan = title.createSpan({ cls: CSS_CLASSES.SUGGESTION_NUMBER });
        numberSpan.setText(part.replacement);
        const placeholderSpan = title.createSpan({ cls: CSS_CLASSES.SUGGESTION_PLACEHOLDER });
        placeholderSpan.setText(part.original);
        lastIndex = part.index + part.original.length;
      }
      if (lastIndex < suggestion.label.length) {
        const afterText = suggestion.label.substring(lastIndex);
        title.createSpan().setText(afterText);
      }
    } else {
      title.setText(`::${suggestion.label}`);
    }
    const preview = container.createDiv({ cls: CSS_CLASSES.SUGGESTION_PREVIEW });
    preview.setText(suggestion.previewText);
  }
  /**
   * Handles selection of a suggestion, inserting the original label.
   */
  selectSuggestion(suggestion, evt) {
    withErrorBoundary(() => this.selectSuggestionInternal(suggestion, evt), void 0, "CustomLabelReferenceSuggest.selectSuggestion");
  }
  selectSuggestionInternal(suggestion, evt) {
    if (!this.context) return;
    const { editor, start, end } = this.context;
    const line = editor.getLine(end.line);
    const afterCursor = line.substring(end.ch);
    const hasClosingBrace = afterCursor.startsWith("}");
    let replacement;
    if (hasClosingBrace) {
      replacement = `{::${suggestion.label}`;
    } else {
      replacement = `{::${suggestion.label}}`;
    }
    editor.replaceRange(replacement, start, end);
    let newCh = start.ch + replacement.length;
    if (hasClosingBrace) {
      newCh += 1;
    }
    editor.setCursor({
      line: start.line,
      ch: newCh
    });
  }
};

// src/listAutocompletion.ts
var import_state2 = require("@codemirror/state");

// src/utils/listHelpers.ts
function getNextLetter(letter) {
  if (letter === "Z" || letter === "z") {
    return null;
  }
  return String.fromCharCode(letter.charCodeAt(0) + 1);
}
function numberToLetter(num, isUpperCase) {
  const letter = String.fromCharCode("A".charCodeAt(0) + num - 1);
  return isUpperCase ? letter : letter.toLowerCase();
}
function romanToInt(roman) {
  const romanValues = {
    "i": 1,
    "iv": 4,
    "v": 5,
    "ix": 9,
    "x": 10,
    "xl": 40,
    "l": 50,
    "xc": 90,
    "c": 100,
    "cd": 400,
    "d": 500,
    "cm": 900,
    "m": 1e3,
    "I": 1,
    "IV": 4,
    "V": 5,
    "IX": 9,
    "X": 10,
    "XL": 40,
    "L": 50,
    "XC": 90,
    "C": 100,
    "CD": 400,
    "D": 500,
    "CM": 900,
    "M": 1e3
  };
  let value = 0;
  let i = 0;
  const normalizedRoman = roman.toLowerCase();
  while (i < normalizedRoman.length) {
    if (i + 1 < normalizedRoman.length && romanValues[normalizedRoman.substring(i, i + 2)]) {
      value += romanValues[normalizedRoman.substring(i, i + 2)];
      i += 2;
    } else {
      value += romanValues[normalizedRoman[i]] || 0;
      i++;
    }
  }
  return value;
}
function intToRoman(num, isUpperCase) {
  const intToRomanUpper = [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ];
  const intToRomanLower = [
    [1e3, "m"],
    [900, "cm"],
    [500, "d"],
    [400, "cd"],
    [100, "c"],
    [90, "xc"],
    [50, "l"],
    [40, "xl"],
    [10, "x"],
    [9, "ix"],
    [5, "v"],
    [4, "iv"],
    [1, "i"]
  ];
  let result = "";
  const table = isUpperCase ? intToRomanUpper : intToRomanLower;
  for (const [value, sym] of table) {
    while (num >= value) {
      result += sym;
      num -= value;
    }
  }
  return result;
}
function getNextRoman(roman) {
  const value = romanToInt(roman);
  const isUpperCase = roman[0] === roman[0].toUpperCase();
  return intToRoman(value + 1, isUpperCase);
}
function isEmptyListItem(line) {
  if (line.match(ListPatterns.EMPTY_HASH_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_FANCY_LIST)) return true;
  if (line.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL)) return true;
  if (line.match(ListPatterns.EMPTY_DEFINITION_LIST)) return true;
  return false;
}

// src/utils/listMarkerDetector.ts
function getNextListMarker(currentLine, allLines, currentLineIndex) {
  const hashMatch = ListPatterns.isHashList(currentLine);
  if (hashMatch) {
    return { marker: "#.", indent: hashMatch[1], spaces: hashMatch[3] };
  }
  const customLabelMatch = ListPatterns.isCustomLabelList(currentLine);
  if (customLabelMatch) {
    const indent = customLabelMatch[1];
    const spaces = customLabelMatch[4];
    return { marker: "{::}", indent, spaces };
  }
  const listMatch = currentLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
  if (listMatch) {
    const indent = listMatch[1];
    const marker = listMatch[2];
    const punctuation = listMatch[3];
    const spaces = listMatch[4];
    let isRoman = false;
    if (marker.length > 1 && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
      isRoman = true;
    } else if (marker.length === 1 && allLines && currentLineIndex !== void 0) {
      if (marker.match(ListPatterns.SINGLE_I)) {
        isRoman = true;
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
          const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.match(ListPatterns.SINGLE_H)) {
              isRoman = false;
              break;
            } else if (prevMarker.length > 1 && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = false;
              break;
            }
          }
        }
      } else {
        for (let i = currentLineIndex - 1; i >= 0; i--) {
          const prevLine = allLines[i];
          if (!prevLine.trim()) continue;
          if (!prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST)) break;
          const prevMatch = prevLine.match(ListPatterns.LETTER_OR_ROMAN_LIST);
          if (prevMatch && prevMatch[1] === indent && prevMatch[3] === punctuation) {
            const prevMarker = prevMatch[2];
            if (prevMarker.length > 1 && prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = true;
              break;
            } else if (!prevMarker.match(ListPatterns.ANY_ROMAN_CHARS)) {
              isRoman = false;
              break;
            } else if (prevMarker.match(ListPatterns.SINGLE_AB)) {
              isRoman = false;
              break;
            }
          }
        }
      }
    }
    if (isRoman) {
      if (marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
        const nextRoman = getNextRoman(marker);
        return { marker: `${nextRoman}${punctuation}`, indent, spaces };
      }
    } else {
      const nextLetter = getNextLetter(marker);
      if (nextLetter) {
        return { marker: `${nextLetter}${punctuation}`, indent, spaces };
      }
      return null;
    }
  }
  let exampleMatch = currentLine.match(ListPatterns.EXAMPLE_LIST);
  if (exampleMatch) {
    const indent = exampleMatch[1];
    const spaces = exampleMatch[4];
    return { marker: "(@)", indent, spaces };
  }
  const altMatch = currentLine.match(ListPatterns.EXAMPLE_LIST_OPTIONAL_SPACE);
  if (altMatch && currentLine.length > altMatch[0].length) {
    const indent = altMatch[1];
    const spaces = altMatch[3] || " ";
    return { marker: "(@)", indent, spaces };
  }
  const definitionMatch = currentLine.match(ListPatterns.DEFINITION_MARKER);
  if (definitionMatch) {
    const indent = definitionMatch[1];
    const marker = definitionMatch[2];
    const spaces = definitionMatch[3];
    return { marker, indent, spaces };
  }
  return null;
}

// src/utils/listRenumbering.ts
function renumberListItems(view, insertedLineNum) {
  const state = view.state;
  const doc = state.doc;
  const allLines = doc.toString().split("\n");
  let blockStart = insertedLineNum;
  let blockEnd = insertedLineNum;
  const insertedLine = allLines[insertedLineNum];
  const insertedIndentMatch = insertedLine.match(ListPatterns.INDENT_ONLY);
  const insertedIndent = insertedIndentMatch ? insertedIndentMatch[1] : "";
  for (let i = insertedLineNum - 1; i >= 0; i--) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockStart = i;
    }
  }
  for (let i = insertedLineNum + 1; i < allLines.length; i++) {
    const line = allLines[i];
    if (!line.trim()) {
      continue;
    }
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST);
    if (!listMatch) {
      break;
    }
    const lineIndent = listMatch[1];
    if (lineIndent.length < insertedIndent.length) {
      break;
    }
    if (lineIndent === insertedIndent) {
      blockEnd = i;
    }
  }
  const listItems = [];
  for (let i = blockStart; i <= blockEnd; i++) {
    const line = allLines[i];
    const listMatch = line.match(ListPatterns.LETTER_OR_ROMAN_OR_HASH_LIST_WITH_CONTENT);
    if (listMatch && listMatch[1] === insertedIndent) {
      const marker = listMatch[2];
      const punctuation = listMatch[3];
      const spaces = listMatch[4];
      const content = listMatch[5];
      let isRoman = false;
      let isAlpha = false;
      if (marker === "#") {
      } else if (marker.match(ListPatterns.ALPHABETIC_CHARS)) {
        if (marker.length > 1 && marker.match(ListPatterns.VALID_ROMAN_NUMERAL)) {
          isRoman = true;
        } else if (marker.length === 1 && marker.match(ListPatterns.SINGLE_ROMAN_CHAR)) {
          if (i === blockStart) {
            isRoman = marker.match(ListPatterns.SINGLE_I) !== null;
            if (!isRoman) {
              isAlpha = true;
            }
          } else {
            isRoman = listItems.length > 0 && listItems[0].isRoman;
            isAlpha = listItems.length > 0 && listItems[0].isAlpha;
          }
        } else {
          isAlpha = true;
        }
      }
      listItems.push({
        lineNum: i,
        marker,
        punctuation,
        spaces,
        content,
        isRoman,
        isAlpha
      });
    }
  }
  if (listItems.length > 1) {
    const changes = [];
    let currentValue = 1;
    const firstItem = listItems[0];
    for (let i = 0; i < listItems.length; i++) {
      const item = listItems[i];
      let newMarker;
      if (item.marker === "#") {
        newMarker = "#";
      } else if (item.isRoman) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = intToRoman(i + 1, isUpperCase);
      } else if (item.isAlpha) {
        const isUpperCase = item.marker[0] === item.marker[0].toUpperCase();
        newMarker = numberToLetter(i + 1, isUpperCase);
      } else {
        newMarker = item.marker;
      }
      const newLine = `${insertedIndent}${newMarker}${item.punctuation}${item.spaces}${item.content}`;
      const oldLine = allLines[item.lineNum];
      if (newLine !== oldLine) {
        const lineStartPos = doc.line(item.lineNum + 1).from;
        const lineEndPos = doc.line(item.lineNum + 1).to;
        changes.push({
          from: lineStartPos,
          to: lineEndPos,
          insert: newLine
        });
      }
    }
    if (changes.length > 0) {
      const transaction = state.update({ changes });
      view.dispatch(transaction);
    }
  }
}

// src/listAutocompletion.ts
function createListAutocompletionKeymap(settings) {
  const handleListEnter = {
    key: "Enter",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const isEmptyExampleList = lineText.match(ListPatterns.EMPTY_EXAMPLE_LIST_NO_LABEL);
      if (isEmptyExampleList) {
        const beforeCursor = state.doc.sliceString(line.from, selection.from);
        const afterCursor = state.doc.sliceString(selection.from, line.to);
        if (beforeCursor.endsWith("(@") && afterCursor.startsWith(")")) {
          const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
          const indent = indentMatch ? indentMatch[1] : "";
          const changes = {
            from: line.from,
            to: line.to,
            insert: indent
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + indent.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      const isEmptyCustomLabelList = lineText.match(ListPatterns.EMPTY_CUSTOM_LABEL_LIST_NO_LABEL);
      if (isEmptyCustomLabelList) {
        const beforeCursor = state.doc.sliceString(line.from, selection.from);
        const afterCursor = state.doc.sliceString(selection.from, line.to);
        if (beforeCursor.endsWith("{::") && afterCursor.startsWith("}")) {
          const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
          const indent = indentMatch ? indentMatch[1] : "";
          const changes = {
            from: line.from,
            to: line.to,
            insert: indent
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + indent.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      const isListItem2 = lineText.match(ListPatterns.ANY_LIST_MARKER);
      if (!isListItem2) {
        if (selection.from !== line.to || selection.from !== selection.to) {
          return false;
        }
      } else {
        const distanceFromEnd = line.to - selection.from;
        if (distanceFromEnd > 2 || selection.from !== selection.to) {
          return false;
        }
      }
      if (lineText.match(ListPatterns.NUMBERED_LIST_WITH_SPACE)) {
        return false;
      }
      if (isEmptyListItem(lineText)) {
        const indentMatch = lineText.match(ListPatterns.INDENT_ONLY);
        if (indentMatch && indentMatch[1].length >= INDENTATION.TAB_SIZE) {
          const currentIndent = indentMatch[1];
          let newIndent = "";
          if (currentIndent.startsWith(INDENTATION.FOUR_SPACES)) {
            newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
          } else if (currentIndent.startsWith(INDENTATION.TAB)) {
            newIndent = currentIndent.substring(1);
          } else {
            newIndent = currentIndent.substring(Math.min(INDENTATION.TAB_SIZE, currentIndent.length));
          }
          let previousMarker = null;
          for (let i = line.number - 1; i >= 1; i--) {
            const prevLine = state.doc.line(i);
            const prevText = prevLine.text;
            const prevIndentMatch = prevText.match(ListPatterns.INDENT_ONLY);
            if (prevIndentMatch && prevIndentMatch[1] === newIndent) {
              const allLines2 = state.doc.toString().split("\n");
              const markerInfo2 = getNextListMarker(prevText, allLines2, i - 1);
              if (markerInfo2) {
                previousMarker = markerInfo2;
                break;
              }
            }
          }
          if (previousMarker && newIndent.length > 0) {
            const spaces = previousMarker.spaces || " ";
            const newLine = `${newIndent}${previousMarker.marker}${spaces}`;
            const changes2 = {
              from: line.from,
              to: line.to,
              insert: newLine
            };
            const transaction2 = state.update({
              changes: changes2,
              selection: import_state2.EditorSelection.cursor(line.from + newLine.length)
            });
            view.dispatch(transaction2);
            return true;
          }
        }
        const changes = {
          from: line.from,
          to: line.to,
          insert: ""
        };
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from)
        });
        view.dispatch(transaction);
        return true;
      }
      const allLines = state.doc.toString().split("\n");
      const currentLineIndex = line.number - 1;
      const markerInfo = getNextListMarker(lineText, allLines, currentLineIndex);
      if (markerInfo) {
        const spaces = markerInfo.spaces || " ";
        const newLine = `
${markerInfo.indent}${markerInfo.marker}${spaces}`;
        const insertPos = selection.from === line.to ? selection.from : line.to;
        const changes = {
          from: insertPos,
          to: insertPos,
          insert: newLine
        };
        const cursorOffset = markerInfo.marker === "(@)" ? newLine.length - spaces.length - 1 : markerInfo.marker === "{::}" ? newLine.length - spaces.length - 1 : newLine.length;
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(insertPos + cursorOffset)
        });
        view.dispatch(transaction);
        if (settings.autoRenumberLists && markerInfo.marker !== "(@)" && markerInfo.marker !== "{::}" && markerInfo.marker !== "#." && !markerInfo.marker.match(ListPatterns.DEFINITION_MARKER_ONLY)) {
          const newLineNum = line.number;
          setTimeout(() => {
            renumberListItems(view, newLineNum);
          }, 0);
        }
        return true;
      }
      return false;
    }
  };
  const handleListTab = {
    key: "Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_SPACE);
      if (listMatch) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        if (selection.from === line.from + markerEnd && selection.to === selection.from) {
          const newIndent = currentIndent + INDENTATION.FOUR_SPACES;
          const newLine = newIndent + marker + space + lineText.substring(markerEnd);
          const changes = {
            from: line.from,
            to: line.to,
            insert: newLine
          };
          const transaction = state.update({
            changes,
            selection: import_state2.EditorSelection.cursor(line.from + newIndent.length + marker.length + space.length)
          });
          view.dispatch(transaction);
          return true;
        }
      }
      return false;
    }
  };
  const handleListShiftTab = {
    key: "Shift-Tab",
    run: (view) => {
      const state = view.state;
      const selection = state.selection.main;
      const line = state.doc.lineAt(selection.from);
      const lineText = line.text;
      const listMatch = lineText.match(ListPatterns.ANY_LIST_MARKER_WITH_INDENT_AND_SPACE);
      if (listMatch && listMatch[1].length > 0) {
        const currentIndent = listMatch[1];
        const marker = listMatch[2];
        const space = listMatch[3];
        const markerEnd = currentIndent.length + marker.length + space.length;
        let newIndent = "";
        if (currentIndent.startsWith("    ")) {
          newIndent = currentIndent.substring(INDENTATION.TAB_SIZE);
        } else if (currentIndent.startsWith("	")) {
          newIndent = currentIndent.substring(1);
        } else {
          newIndent = currentIndent.substring(Math.min(4, currentIndent.length));
        }
        const newLine = newIndent + marker + space + lineText.substring(markerEnd);
        const changes = {
          from: line.from,
          to: line.to,
          insert: newLine
        };
        const oldCursorOffset = selection.from - line.from;
        const indentDiff = currentIndent.length - newIndent.length;
        const newCursorOffset = Math.max(newIndent.length + marker.length + space.length, oldCursorOffset - indentDiff);
        const transaction = state.update({
          changes,
          selection: import_state2.EditorSelection.cursor(line.from + newCursorOffset)
        });
        view.dispatch(transaction);
        return true;
      }
      return false;
    }
  };
  return [
    handleListEnter,
    handleListTab,
    handleListShiftTab
  ];
}

// src/views/CustomLabelView.ts
var import_obsidian12 = require("obsidian");

// src/utils/customLabelExtractor.ts
function extractCustomLabels(content, moreExtendedSyntax) {
  return withErrorBoundary(() => {
    const lines = content.split("\n");
    const labels = [];
    if (!moreExtendedSyntax) {
      return labels;
    }
    const { processedLabels, rawToProcessed } = processLabels(lines);
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = ListPatterns.isCustomLabelList(line);
      if (match) {
        const fullMarker = match[2];
        const rawLabel = match[3];
        const restOfLine = line.substring(match[0].length);
        const processedLabel = rawToProcessed.get(rawLabel) || rawLabel;
        const renderedLabel = processedLabel;
        let renderedContent = restOfLine.trim();
        renderedContent = renderedContent.replace(ListPatterns.CUSTOM_LABEL_REFERENCE, (match2, ref) => {
          const processedRef = rawToProcessed.get(ref) || ref;
          return processedRef;
        });
        labels.push({
          label: renderedLabel,
          rawLabel: fullMarker,
          content: restOfLine.trim(),
          renderedContent,
          lineNumber: i,
          position: { line: i, ch: 0 }
        });
      }
    }
    return labels;
  }, [], "CustomLabelExtractor.extractCustomLabels");
}
function processLabels(lines) {
  const placeholderContext = new PlaceholderContext();
  const processedLabels = /* @__PURE__ */ new Map();
  const rawToProcessed = /* @__PURE__ */ new Map();
  for (const line of lines) {
    const match = ListPatterns.isCustomLabelList(line);
    if (match) {
      const rawLabel = match[3];
      const fullMatch = match[0];
      const restOfLine = line.substring(fullMatch.length);
      const processedLabel = placeholderContext.processLabel(rawLabel);
      processedLabels.set(processedLabel, restOfLine.trim());
      rawToProcessed.set(rawLabel, processedLabel);
    }
  }
  return { processedLabels, rawToProcessed };
}

// src/utils/mathRenderer.ts
function renderMathToText(mathContent) {
  let rendered = mathContent;
  for (const [latex, unicode] of Object.entries(MATH_SYMBOLS.LATEX_TO_UNICODE)) {
    rendered = rendered.replace(new RegExp(latex.replace(/\\/g, "\\\\"), "g"), unicode);
  }
  rendered = rendered.replace(/\\/g, "").replace(/\s+/g, " ").trim();
  return rendered;
}
function tokenizeMath(mathContent) {
  const tokens = [];
  let current = "";
  let i = 0;
  while (i < mathContent.length) {
    if (mathContent[i] === "\\") {
      if (current) {
        tokens.push(current);
        current = "";
      }
      let command = "\\";
      i++;
      while (i < mathContent.length && /[a-zA-Z]/.test(mathContent[i])) {
        command += mathContent[i];
        i++;
      }
      if (i < mathContent.length && mathContent[i] === " ") {
        if (command.length > 1) {
          command += " ";
          i++;
        }
      }
      tokens.push(command);
    } else {
      current += mathContent[i];
      i++;
    }
  }
  if (current) {
    tokens.push(current);
  }
  return tokens;
}
function truncateMathContent(mathContent, maxRenderedLength) {
  const tokens = tokenizeMath(mathContent);
  let result = "$";
  let tokenCount = 0;
  let accumulatedTokens = [];
  for (const token of tokens) {
    const testTokens = [...accumulatedTokens, token];
    const testLatex = testTokens.join("");
    const testRendered = renderMathToText(testLatex);
    if (testRendered.length <= maxRenderedLength) {
      accumulatedTokens.push(token);
      tokenCount++;
    } else {
      break;
    }
  }
  let latexContent = accumulatedTokens.join("");
  latexContent = latexContent.trimEnd();
  result += latexContent;
  if (!result.endsWith("$")) {
    result += "$";
  }
  return result;
}
function truncateMathAtLimit(mathBuffer, currentResult, remainingSpace) {
  if (remainingSpace > 1) {
    const truncatedMath = truncateMathContent(mathBuffer, remainingSpace - 1);
    return currentResult + truncatedMath.slice(1) + "\u2026";
  } else if (currentResult.endsWith("$")) {
    return currentResult.slice(0, -1) + "\u2026";
  } else {
    return currentResult + "\u2026";
  }
}

// src/utils/views/contentTruncator.ts
function truncateLabel(label) {
  if (label.length > UI_CONSTANTS.LABEL_MAX_LENGTH) {
    return label.slice(0, UI_CONSTANTS.LABEL_TRUNCATION_LENGTH) + "\u2026";
  }
  return label;
}
function truncateContent(content) {
  if (content.length > UI_CONSTANTS.CONTENT_MAX_LENGTH) {
    return content.slice(0, UI_CONSTANTS.CONTENT_TRUNCATION_LENGTH) + "\u2026";
  }
  return content;
}
function truncateContentWithRendering(content) {
  if (!content.includes("$")) {
    return truncateContent(content);
  }
  const parseResult = parseContentWithMath(content);
  return parseResult.truncated ? parseResult.result : content;
}
function parseContentWithMath(content) {
  const normalizedContent = normalizeMathSpaces(content);
  const state = initializeParsingState();
  for (let i = 0; i < normalizedContent.length; i++) {
    const char = normalizedContent[i];
    const parseResult = processCharacter(char, state);
    if (parseResult.shouldBreak) {
      return { result: parseResult.result, truncated: true };
    }
  }
  if (state.inMath) {
    return handleUnclosedMathWrapper(state);
  }
  return { result: state.result, truncated: false };
}
function normalizeMathSpaces(content) {
  if (content.includes("$")) {
    return content.replace(/\s+\$/g, "$");
  }
  return content;
}
function initializeParsingState() {
  return {
    renderedLength: 0,
    result: "",
    inMath: false,
    mathBuffer: ""
  };
}
function processCharacter(char, state) {
  if (char === "$") {
    const mathResult = processMathDelimiter(
      state.inMath,
      state.mathBuffer,
      state.result,
      state.renderedLength
    );
    state.result = mathResult.result;
    state.renderedLength = mathResult.renderedLength;
    state.mathBuffer = mathResult.mathBuffer;
    state.inMath = mathResult.inMath;
    return { result: mathResult.result, shouldBreak: mathResult.shouldBreak };
  } else if (state.inMath) {
    state.mathBuffer += char;
    return { result: state.result, shouldBreak: false };
  } else {
    const textResult = processRegularCharacter(char, state.result, state.renderedLength);
    state.result = textResult.result;
    state.renderedLength = textResult.renderedLength;
    return { result: textResult.result, shouldBreak: textResult.shouldBreak };
  }
}
function handleUnclosedMathWrapper(state) {
  const finalResult = handleUnclosedMath(state.mathBuffer, state.result, state.renderedLength);
  return { result: finalResult.result, truncated: finalResult.truncated };
}
function processMathDelimiter(inMath, mathBuffer, currentResult, currentLength) {
  if (inMath) {
    const renderedMath = renderMathToText(mathBuffer);
    const remainingSpace = UI_CONSTANTS.CONTENT_MAX_LENGTH - currentLength;
    if (renderedMath.length <= remainingSpace) {
      return {
        result: currentResult + mathBuffer.trimEnd() + "$",
        renderedLength: currentLength + renderedMath.length,
        mathBuffer: "",
        inMath: false,
        shouldBreak: false
      };
    } else {
      const truncatedResult = truncateMathAtLimit(
        mathBuffer,
        currentResult,
        remainingSpace
      );
      return {
        result: truncatedResult,
        renderedLength: UI_CONSTANTS.CONTENT_MAX_LENGTH,
        mathBuffer: "",
        inMath: false,
        shouldBreak: true
      };
    }
  } else {
    return {
      result: currentResult + "$",
      renderedLength: currentLength,
      mathBuffer: "",
      inMath: true,
      shouldBreak: false
    };
  }
}
function processRegularCharacter(char, currentResult, currentLength) {
  if (currentLength < UI_CONSTANTS.CONTENT_MAX_LENGTH) {
    return {
      result: currentResult + char,
      renderedLength: currentLength + 1,
      shouldBreak: false
    };
  } else {
    const truncated = currentResult.length > 0 && !currentResult.endsWith("\u2026") ? currentResult.slice(0, -1) + "\u2026" : currentResult + "\u2026";
    return {
      result: truncated,
      renderedLength: UI_CONSTANTS.CONTENT_MAX_LENGTH,
      shouldBreak: true
    };
  }
}
function handleUnclosedMath(mathBuffer, currentResult, currentLength) {
  const renderedMath = renderMathToText(mathBuffer);
  const remainingSpace = UI_CONSTANTS.CONTENT_MAX_LENGTH - currentLength;
  if (renderedMath.length <= remainingSpace) {
    return {
      result: currentResult + mathBuffer.trimEnd() + "$",
      truncated: false
    };
  } else {
    const truncatedResult = truncateMathAtLimit(
      mathBuffer,
      currentResult,
      remainingSpace
    );
    return {
      result: truncatedResult,
      truncated: true
    };
  }
}

// src/utils/views/viewInteractions.ts
var import_obsidian11 = require("obsidian");
function highlightLine(view, lineNumber) {
  try {
    const editor = view.editor;
    const lineContent = editor.getLine(lineNumber);
    const lineStart = { line: lineNumber, ch: 0 };
    const lineEnd = { line: lineNumber, ch: lineContent.length };
    editor.setSelection(lineStart, lineEnd);
    const cm = editor.cm;
    if (cm && cm.dom) {
      const selections = cm.dom.querySelectorAll(".cm-selectionBackground");
      selections.forEach((sel) => {
        sel.style.transition = "opacity 2s ease-out";
        sel.style.opacity = "0.3";
        setTimeout(() => {
          sel.style.opacity = "0";
        }, UI_CONSTANTS.SELECTION_FADE_DELAY_MS);
      });
    }
    setTimeout(() => {
      editor.setCursor(lineStart);
    }, UI_CONSTANTS.SELECTION_CLEAR_DELAY_MS);
  } catch (error) {
    console.error("Error highlighting line:", error);
  }
}
function setupLabelClickHandler(element, rawLabel) {
  element.addEventListener("click", () => {
    try {
      navigator.clipboard.writeText(rawLabel).then(() => {
        new import_obsidian11.Notice(MESSAGES.LABEL_COPIED);
      }).catch((error) => {
        console.error("Failed to copy label:", error);
      });
    } catch (error) {
      console.error("Error in label click handler:", error);
    }
  });
}
function setupContentClickHandler(element, label, lastActiveMarkdownView, app) {
  element.addEventListener("click", () => {
    try {
      const targetView = lastActiveMarkdownView;
      if (targetView && targetView.editor) {
        const editor = targetView.editor;
        const leaves = app.workspace.getLeavesOfType("markdown");
        const targetLeaf = leaves.find((leaf) => leaf.view === targetView);
        if (targetLeaf) {
          app.workspace.setActiveLeaf(targetLeaf, { focus: true });
        }
        editor.setCursor(label.position);
        editor.scrollIntoView({ from: label.position, to: label.position }, true);
        highlightLine(targetView, label.lineNumber);
      }
    } catch (error) {
      console.error("Error scrolling to label:", error);
    }
  });
}
function setupLabelHoverPreview(element, fullLabel) {
  let hoverPopover = null;
  const removePopover = () => {
    if (hoverPopover) {
      hoverPopover.remove();
      hoverPopover = null;
    }
  };
  element.addEventListener("mouseenter", () => {
    const hoverEl = document.createElement("div");
    hoverEl.classList.add(CSS_CLASSES.HOVER_POPOVER, CSS_CLASSES.HOVER_POPOVER_LABEL);
    hoverEl.textContent = fullLabel;
    document.body.appendChild(hoverEl);
    const rect = element.getBoundingClientRect();
    hoverEl.style.left = `${rect.left}px`;
    hoverEl.style.top = `${rect.bottom + 5}px`;
    const hoverRect = hoverEl.getBoundingClientRect();
    if (hoverRect.right > window.innerWidth) {
      hoverEl.style.left = `${window.innerWidth - hoverRect.width - 10}px`;
    }
    if (hoverRect.bottom > window.innerHeight) {
      hoverEl.style.top = `${rect.top - hoverRect.height - 5}px`;
    }
    hoverPopover = hoverEl;
  });
  element.addEventListener("mouseleave", removePopover);
  element.addEventListener("click", removePopover);
}
function renderContentWithMath(element, truncatedContent, app, component) {
  import_obsidian11.MarkdownRenderer.render(
    app,
    truncatedContent,
    element,
    "",
    component
  );
}
function setupContentHoverPreview(element, label, app, component) {
  let hoverPopover = null;
  const removePopover = () => {
    if (hoverPopover) {
      hoverPopover.remove();
      hoverPopover = null;
    }
  };
  element.addEventListener("mouseenter", () => {
    const hoverEl = document.createElement("div");
    hoverEl.classList.add(CSS_CLASSES.HOVER_POPOVER, CSS_CLASSES.HOVER_POPOVER_CONTENT);
    const contentToShow = label.renderedContent || label.content;
    if (contentToShow.includes("$")) {
      import_obsidian11.MarkdownRenderer.render(
        app,
        contentToShow,
        hoverEl,
        "",
        component
      );
    } else {
      hoverEl.textContent = contentToShow;
    }
    document.body.appendChild(hoverEl);
    const rect = element.getBoundingClientRect();
    hoverEl.style.left = `${rect.left}px`;
    hoverEl.style.top = `${rect.bottom + 5}px`;
    const hoverRect = hoverEl.getBoundingClientRect();
    if (hoverRect.right > window.innerWidth) {
      hoverEl.style.left = `${window.innerWidth - hoverRect.width - 10}px`;
    }
    if (hoverRect.bottom > window.innerHeight) {
      hoverEl.style.top = `${rect.top - hoverRect.height - 5}px`;
    }
    hoverPopover = hoverEl;
  });
  element.addEventListener("mouseleave", removePopover);
  element.addEventListener("click", removePopover);
}

// src/views/CustomLabelView.ts
var VIEW_TYPE_CUSTOM_LABEL = "custom-label-view";
var CustomLabelView = class extends import_obsidian12.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.labels = [];
    this.updateTimer = null;
    this.lastActiveMarkdownView = null;
    this.plugin = plugin;
    this.hoverLinkSource = {
      display: MESSAGES.CUSTOM_LABELS_VIEW_TITLE,
      defaultMod: true
    };
  }
  getViewType() {
    return VIEW_TYPE_CUSTOM_LABEL;
  }
  getDisplayText() {
    return MESSAGES.CUSTOM_LABELS_VIEW_TITLE;
  }
  getIcon() {
    return ICONS.CUSTOM_LABEL_ID;
  }
  async onOpen() {
    await this.updateView();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.scheduleUpdate();
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.scheduleUpdate();
      })
    );
    this.plugin.registerHoverLinkSource(VIEW_TYPE_CUSTOM_LABEL, this.hoverLinkSource);
  }
  async onClose() {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    while (this.contentEl.firstChild) {
      this.contentEl.removeChild(this.contentEl.firstChild);
    }
  }
  scheduleUpdate() {
    if (this.updateTimer) {
      clearTimeout(this.updateTimer);
    }
    this.updateTimer = setTimeout(() => {
      this.updateView();
    }, UI_CONSTANTS.UPDATE_DEBOUNCE_MS);
  }
  async updateView() {
    try {
      const activeLeaf = this.app.workspace.activeLeaf;
      let markdownView = null;
      if (activeLeaf && activeLeaf.view instanceof import_obsidian12.MarkdownView) {
        markdownView = activeLeaf.view;
        if (markdownView.file) {
          this.lastActiveMarkdownView = markdownView;
        }
      }
      if (!markdownView || !markdownView.file) {
        markdownView = this.lastActiveMarkdownView;
      }
      if (!markdownView || !markdownView.file) {
        this.showNoFileMessage();
        return;
      }
      const content = markdownView.editor.getValue();
      this.labels = this.extractCustomLabels(content);
      this.renderLabels(markdownView);
    } catch (error) {
      console.error("Error updating CustomLabelView:", error);
      this.showNoFileMessage();
    }
  }
  showNoFileMessage() {
    while (this.contentEl.firstChild) {
      this.contentEl.removeChild(this.contentEl.firstChild);
    }
    this.contentEl.createEl("div", {
      text: MESSAGES.NO_ACTIVE_FILE,
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_EMPTY
    });
    this.labels = [];
  }
  /**
   * Extracts custom labels from markdown content.
   * Delegates to the customLabelExtractor utility.
   */
  extractCustomLabels(content) {
    var _a;
    return extractCustomLabels(content, ((_a = this.plugin.settings) == null ? void 0 : _a.moreExtendedSyntax) || false);
  }
  renderLabels(activeView) {
    while (this.contentEl.firstChild) {
      this.contentEl.removeChild(this.contentEl.firstChild);
    }
    if (this.labels.length === 0) {
      this.contentEl.createEl("div", {
        text: MESSAGES.NO_CUSTOM_LABELS,
        cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_EMPTY
      });
      return;
    }
    const container = this.contentEl.createEl("div", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_CONTAINER
    });
    const header = container.createEl("div", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_HEADER
    });
    header.createEl("span", {
      text: "Label",
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_HEADER_LABEL
    });
    header.createEl("span", {
      text: "Content",
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_HEADER_CONTENT
    });
    for (const label of this.labels) {
      this.renderLabelRow(container, label, activeView);
    }
  }
  renderLabelRow(container, label, activeView) {
    const row = container.createEl("div", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_ROW
    });
    const labelEl = row.createEl("div", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_LABEL
    });
    const displayLabel = truncateLabel(label.label);
    labelEl.textContent = displayLabel;
    if (displayLabel !== label.label) {
      setupLabelHoverPreview(labelEl, label.label);
    }
    setupLabelClickHandler(labelEl, label.rawLabel);
    const contentEl = row.createEl("div", {
      cls: CSS_CLASSES.CUSTOM_LABEL_VIEW_CONTENT
    });
    const contentToShow = label.renderedContent || label.content;
    const truncatedContent = truncateContentWithRendering(contentToShow);
    if (truncatedContent.includes("$")) {
      renderContentWithMath(contentEl, truncatedContent, this.plugin.app, this);
    } else {
      contentEl.textContent = truncatedContent;
    }
    setupContentClickHandler(contentEl, label, this.lastActiveMarkdownView, this.app);
    if (truncatedContent !== contentToShow) {
      setupContentHoverPreview(contentEl, label, this.plugin.app, this);
    }
  }
  getCustomLabels() {
    return this.labels;
  }
};

// src/main.ts
var PandocExtendedMarkdownPlugin = class extends import_obsidian13.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerCustomLabelIcon();
    this.addSettingTab(new PandocExtendedMarkdownSettingTab(this.app, this));
    this.registerExtensions();
    this.registerPostProcessor();
    this.setupModeChangeDetection();
    this.suggester = new ExampleReferenceSuggest(this);
    this.registerEditorSuggest(this.suggester);
    this.customLabelSuggester = new CustomLabelReferenceSuggest(this);
    this.registerEditorSuggest(this.customLabelSuggester);
    this.registerView(
      VIEW_TYPE_CUSTOM_LABEL,
      (leaf) => new CustomLabelView(leaf, this)
    );
    this.addRibbonIcon(ICONS.CUSTOM_LABEL_ID, "Open custom labels view", () => {
      this.activateCustomLabelView();
    });
    this.registerCommands();
  }
  registerCustomLabelIcon() {
    (0, import_obsidian13.addIcon)(ICONS.CUSTOM_LABEL_ID, ICONS.CUSTOM_LABEL_SVG);
  }
  registerExtensions() {
    this.registerEditorExtension(pandocExtendedMarkdownExtension(
      () => this.settings,
      () => {
        var _a;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
        return ((_a = activeView == null ? void 0 : activeView.file) == null ? void 0 : _a.path) || null;
      }
    ));
    this.registerEditorExtension(import_state3.Prec.highest(import_view11.keymap.of(createListAutocompletionKeymap(this.settings))));
  }
  registerPostProcessor() {
    this.registerMarkdownPostProcessor((element, context) => {
      const config = createProcessorConfig(
        { strictLineBreaks: this.app.vault.getConfig("strictLineBreaks") },
        this.settings
      );
      processReadingMode(element, context, config);
    });
  }
  setupModeChangeDetection() {
    const updateStates = () => {
      const leaves = this.app.workspace.getLeavesOfType("markdown");
      const hadChanges = pluginStateManager.scanAllLeaves(leaves);
      if (hadChanges) {
        setTimeout(() => {
          this.app.workspace.iterateCodeMirrors((cm) => {
            if (cm.dispatch) {
              cm.dispatch({ effects: [] });
            }
          });
        }, 10);
      }
    };
    updateStates();
    this.registerEvent(this.app.workspace.on("layout-change", updateStates));
    this.registerEvent(this.app.workspace.on("active-leaf-change", updateStates));
    this.registerEvent(this.app.workspace.on("file-open", updateStates));
  }
  registerCommands() {
    this.addCommand({
      id: COMMANDS.CHECK_PANDOC,
      name: "Check pandoc formatting",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const issues = checkPandocFormatting(content, this.settings.moreExtendedSyntax);
        if (issues.length === 0) {
          new import_obsidian13.Notice(MESSAGES.PANDOC_COMPLIANT);
        } else {
          const issueList = issues.map(
            (issue) => `Line ${issue.line}: ${issue.message}`
          ).join("\n");
          new import_obsidian13.Notice(`${MESSAGES.FORMATTING_ISSUES(issues.length)}:
${issueList}`, UI_CONSTANTS.NOTICE_DURATION_MS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.FORMAT_PANDOC,
      name: "Format document to pandoc standard",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const formatted = formatToPandocStandard(content, this.settings.moreExtendedSyntax);
        if (content !== formatted) {
          editor.setValue(formatted);
          new import_obsidian13.Notice(MESSAGES.FORMAT_SUCCESS);
        } else {
          new import_obsidian13.Notice(MESSAGES.FORMAT_ALREADY_COMPLIANT);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_BOLD,
      name: "Toggle definition list bold style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionBoldStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian13.Notice(MESSAGES.TOGGLE_BOLD_SUCCESS);
        } else {
          new import_obsidian13.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.TOGGLE_DEFINITION_UNDERLINE,
      name: "Toggle definition list underline style",
      editorCallback: (editor) => {
        const content = editor.getValue();
        const toggled = this.toggleDefinitionUnderlineStyle(content);
        if (content !== toggled) {
          editor.setValue(toggled);
          new import_obsidian13.Notice(MESSAGES.TOGGLE_UNDERLINE_SUCCESS);
        } else {
          new import_obsidian13.Notice(MESSAGES.NO_DEFINITION_TERMS);
        }
      }
    });
    this.addCommand({
      id: COMMANDS.OPEN_CUSTOM_LABEL_VIEW,
      name: "Open custom labels view",
      callback: () => {
        this.activateCustomLabelView();
      }
    });
  }
  onunload() {
    pluginStateManager.clearAllStates();
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CUSTOM_LABEL);
  }
  async activateCustomLabelView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CUSTOM_LABEL);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (leaf) {
        await leaf.setViewState({ type: VIEW_TYPE_CUSTOM_LABEL, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  isDefinitionTerm(lines, index) {
    if (index + 1 >= lines.length) {
      return false;
    }
    const nextLine = lines[index + 1].trim();
    if (ListPatterns.isDefinitionMarker(nextLine)) {
      return true;
    }
    if (nextLine === "" && index + 2 < lines.length) {
      const lineAfterEmpty = lines[index + 2].trim();
      return ListPatterns.isDefinitionMarker(lineAfterEmpty) !== null;
    }
    return false;
  }
  identifyDefinitionTerms(lines) {
    const definitionTerms = [];
    let anyHasBold = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasBold = ListPatterns.BOLD_TEXT.test(trimmedLine);
        definitionTerms.push({ index: i, hasBold });
        if (hasBold) {
          anyHasBold = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasBold };
  }
  identifyDefinitionTermsWithUnderline(lines) {
    const definitionTerms = [];
    let anyHasUnderline = false;
    for (let i = 0; i < lines.length; i++) {
      const trimmedLine = lines[i].trim();
      if (!trimmedLine || ListPatterns.isDefinitionMarker(trimmedLine)) {
        continue;
      }
      if (this.isDefinitionTerm(lines, i)) {
        const hasUnderline = ListPatterns.UNDERLINE_SPAN.test(trimmedLine);
        definitionTerms.push({ index: i, hasUnderline });
        if (hasUnderline) {
          anyHasUnderline = true;
        }
      }
    }
    return { terms: definitionTerms, anyHasUnderline };
  }
  toggleDefinitionBoldStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasBold } = this.identifyDefinitionTerms(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasBold) {
        const match = trimmedLine.match(ListPatterns.BOLD_TEXT);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.BOLD_TEXT.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + "**" + trimmedLine + "**";
        }
      }
    }
    return modifiedLines.join("\n");
  }
  toggleDefinitionUnderlineStyle(content) {
    const lines = content.split("\n");
    const modifiedLines = [...lines];
    const { terms, anyHasUnderline } = this.identifyDefinitionTermsWithUnderline(lines);
    for (const term of terms) {
      const line = lines[term.index];
      const trimmedLine = line.trim();
      const originalIndent = ListPatterns.getIndent(line);
      if (anyHasUnderline) {
        const match = trimmedLine.match(ListPatterns.UNDERLINE_SPAN);
        if (match) {
          modifiedLines[term.index] = originalIndent + match[1];
        }
      } else {
        if (!ListPatterns.UNDERLINE_SPAN.test(trimmedLine)) {
          modifiedLines[term.index] = originalIndent + '<span class="underline">' + trimmedLine + "</span>";
        }
      }
    }
    return modifiedLines.join("\n");
  }
};
var main_default = PandocExtendedMarkdownPlugin;
